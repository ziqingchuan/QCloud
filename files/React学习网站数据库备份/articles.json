[{"id":"028fcc04-74b2-4765-9692-ef2461af4b86","title":"React-Redux","content":"Redux 本身是独立的状态管理库，与 React 无关——React-Redux 是官方提供的“桥梁库”，负责将 Redux Store 与 React 组件连接，实现组件对 Redux 状态的读取和修改。\n\n# 1. 核心准备：Provider 全局注入 Store\n要让所有 React 组件访问 Redux Store，需在应用根组件外层包裹 `Provider` 组件（从 `react-redux` 导入），并传入 Store 实例：\n\n```javascript\n// src/index.js\nimport React from 'react';\nimport ReactDOM from 'react-dom/client';\nimport { Provider } from 'react-redux';\nimport store from './store';\nimport App from './App';\n\nconst root = ReactDOM.createRoot(document.getElementById('root'));\nroot.render(\n  // 包裹 Provider，注入 Store\n  <Provider store={store}>\n    <App />\n  </Provider>\n);\n```\n\n# 2. useSelector：读取 Redux 状态\n`useSelector` 是 React-Redux 提供的 Hook，用于从 Redux Store 中提取需要的状态，并订阅状态变化——当对应状态更新时，组件会自动重新渲染。\n\n## 2.1 语法\n```javascript\nimport { useSelector } from 'react-redux';\n\n// 传入选择器函数（参数为全局 state，返回需要的状态）\nconst 状态变量 = useSelector((state) => state.模块名.具体属性);\n```\n\n## 2.2 关键注意事项\n- 选择器函数需返回“组件需要的最小状态”（避免不必要的重渲染）；\n- 默认使用“严格相等（===）”比较前后状态，若返回对象/数组（引用类型），需注意不可变（或使用 `shallowEqual` 浅比较）；\n- 可多次调用 `useSelector` 提取不同状态。\n\n## 2.3 示例\n```javascript\nimport { useSelector } from 'react-redux';\n\nfunction TodoList() {\n  // 提取 todos 状态（state.todos 对应 Store 中 todoSlice 的状态）\n  const todos = useSelector((state) => state.todos.todos);\n  // 提取用户登录状态\n  const isLogin = useSelector((state) => state.user.isLogin);\n\n  return (\n    <div>\n      {isLogin ? (\n        <ul>\n          {todos.map((todo) => (\n            <li key={todo.id}>{todo.text}</li>\n          ))}\n        </ul>\n      ) : (\n        <p>请登录后查看待办</p>\n      )}\n    </div>\n  );\n}\n```\n\n## 2.4 浅比较优化（避免引用类型导致的重渲染）\n若选择器返回对象/数组（如 `state.todos.filter(...)`），每次渲染会生成新引用，导致组件不必要重渲染，可使用 `shallowEqual` 作为第二个参数：\n\n```javascript\nimport { useSelector, shallowEqual } from 'react-redux';\n\n// 提取已完成的待办（返回新数组）\nconst completedTodos = useSelector(\n  (state) => state.todos.todos.filter(todo => todo.completed),\n  shallowEqual // 浅比较：仅比较数组元素是否相同，而非引用\n);\n```\n\n# 3. useDispatch：触发 Action 并修改状态\n`useDispatch` 是 React-Redux 提供的 Hook，用于获取 Redux Store 的 `dispatch` 函数，通过调用 `dispatch(action)` 触发状态更新。\n\n## 3.1 语法\n```javascript\nimport { useDispatch } from 'react-redux';\nimport { 动作创建函数 } from './features/xxxSlice';\n\nconst dispatch = useDispatch();\n\n// 触发 Action：dispatch(动作创建函数(参数))\ndispatch(动作创建函数(数据));\n```\n\n## 3.2 示例\n```javascript\nimport { useState } from 'react';\nimport { useDispatch, useSelector } from 'react-redux';\nimport { addTodo } from './features/todo/todoSlice';\n\nfunction AddTodoForm() {\n  const [text, setText] = useState('');\n  const dispatch = useDispatch();\n  const isLogin = useSelector((state) => state.user.isLogin);\n\n  const handleSubmit = (e) => {\n    e.preventDefault();\n    if (!text.trim() || !isLogin) return;\n\n    // 触发 addTodo Action，携带 payload 数据\n    dispatch(\n      addTodo({\n        id: Date.now(),\n        text,\n        completed: false\n      })\n    );\n\n    setText(''); // 清空输入框\n  };\n\n  return (\n    <form onSubmit={handleSubmit}>\n      <input\n        type=\"text\"\n        value={text}\n        onChange={(e) => setText(e.target.value)}\n        placeholder=\"请输入待办事项\"\n        disabled={!isLogin}\n      />\n      <button type=\"submit\" disabled={!text.trim() || !isLogin}>\n        添加待办\n      </button>\n    </form>\n  );\n}\n```\n\n# 4. 组件连接核心流程\n1. 根组件用 `Provider` 注入 Store，让所有子组件可访问；\n2. 组件内用 `useSelector` 读取需要的 Redux 状态；\n3. 组件内用 `useDispatch` 获取 dispatch 函数，通过调用 Action 创建函数触发状态更新；\n4. Redux Store 接收 Action 后，通过 Reducer 计算新状态；\n5. `useSelector` 订阅的状态更新，组件自动重新渲染。","directory_id":"a3109983-f66b-42c0-afb5-8d07e97cbc4e","is_published":true,"created_at":"2025-12-22 03:12:17.715894+00","updated_at":"2025-12-23 08:38:24.169184+00"},{"id":"04242d24-3e5d-4d42-8202-f65133cb9762","title":"React Router 安装与核心组件","content":"React Router 是 React 生态中最常用的路由解决方案，用于实现单页应用（SPA）的页面跳转与路由管理。其核心是通过组件化的方式定义路由规则，实现 URL 与组件的映射。以下是 React Router 的安装流程及三大核心组件的详细解析：\n\n# 1. React Router 安装\nReact Router 分为 Web 端（`react-router-dom`）和原生端（`react-router-native`），Web 开发需安装 `react-router-dom`（当前稳定版本为 v6+，与 v5 有较大差异，以下内容基于 v6 版本）。\n\n## 1.1 安装命令\n```bash\nnpm 安装\nnpm install react-router-dom --save\n\nyarn 安装\nyarn add react-router-dom\n```\n\n## 1.2 环境配置验证\n安装完成后，可在项目入口文件（如 `index.js`）中引入核心组件，验证是否安装成功：\n```jsx\nimport { BrowserRouter } from 'react-router-dom';\n// 若未报错，则安装成功\n```\n\n# 2. 核心组件解析\nReact Router v6 的核心组件包括 `BrowserRouter`、`Routes`、`Route`，三者各司其职，共同构成路由系统的基础。\n\n## 2.1 BrowserRouter：路由根容器\n`BrowserRouter` 是所有路由组件的顶层容器，用于包裹整个应用的路由结构，提供路由上下文（如 URL 监听、路由状态管理）。\n\n### 2.1.1 核心作用\n- 监听浏览器 URL 变化，同步路由状态；\n- 提供路由相关的上下文（通过 `useContext` 可在子组件中获取路由信息）；\n- 支持 HTML5 的 History API（无 `#` 号的 URL 形式）。\n\n### 2.1.2 使用方式\n需在应用最顶层包裹（通常是 `App` 组件外层）：\n```jsx\n// index.js\nimport React from 'react';\nimport ReactDOM from 'react-dom/client';\nimport { BrowserRouter } from 'react-router-dom';\nimport App from './App';\n\nconst root = ReactDOM.createRoot(document.getElementById('root'));\nroot.render(\n  <BrowserRouter>\n    <App /> {/* 所有路由相关组件需在 BrowserRouter 内部 */}\n  </BrowserRouter>\n);\n```\n\n### 2.1.3 注意事项\n- 整个应用只能有一个 `BrowserRouter` 根容器，不可嵌套；\n- 若部署到非根路径的服务器（如 `https://example.com/app/`），需配置 `basename` 属性：\n  ```jsx\n  <BrowserRouter basename=\"/app\">\n    {/* 路由路径会自动拼接 /app，如 /home → /app/home */}\n  </BrowserRouter>\n  ```\n\n## 2.2 Routes：路由匹配容器\n`Routes`（替代 v5 中的 `Switch`）是路由规则的容器，用于包裹多个 `Route` 组件，其核心作用是**匹配当前 URL 与路由规则，仅渲染第一个匹配成功的 `Route` 组件**。\n\n### 2.2.1 核心特性\n- 排他性匹配：仅渲染匹配成功的第一个 `Route`，避免多个路由同时渲染；\n- 支持嵌套路由：可在子组件中再次使用 `Routes` 定义嵌套路由规则；\n- 自动处理路由优先级：路径更具体的路由（如 `/user/:id`）会优先于模糊路由（如 `/user`）匹配。\n\n### 2.2.2 使用方式\n在 `BrowserRouter` 内部使用，包裹所有 `Route` 组件：\n```jsx\n// App.js\nimport { Routes, Route } from 'react-router-dom';\nimport Home from './pages/Home';\nimport About from './pages/About';\nimport NotFound from './pages/NotFound';\n\nfunction App() {\n  return (\n    <div className=\"App\">\n      <Routes>\n        {/* 定义路由规则：path 为 URL 路径，element 为匹配后渲染的组件 */}\n        <Route path=\"/\" element={<Home />} />\n        <Route path=\"/about\" element={<About />} />\n        {/* 404 路由：path=\"*\" 匹配所有未定义的路由 */}\n        <Route path=\"*\" element={<NotFound />} />\n      </Routes>\n    </div>\n  );\n}\n\nexport default App;\n```\n\n## 2.3 Route：路由规则组件\n`Route` 是单个路由规则的定义，用于关联 URL 路径与组件，是路由系统的核心最小单元。\n\n### 2.3.1 核心属性\n| 属性名   | 类型          | 说明                                                                 |\n|----------|---------------|----------------------------------------------------------------------|\n| `path`   | string        | 路由路径（相对路径，基于父组件的 `path`），支持静态路径、动态路径、通配符 |\n| `element`| ReactElement  | 路由匹配成功后渲染的组件（必须是 React 元素，如 `<Home />`，而非 `Home`） |\n| `index`  | boolean       | 索引路由：当父路由路径匹配，但子路由无匹配时，渲染该索引组件（替代 `path=\"\"`） |\n| `children`| Route[]      | 嵌套路由的子路由规则                                                 |\n\n### 2.3.2 常用用法\n1. **静态路由**：路径固定的路由（最常用）\n   ```jsx\n   <Route path=\"/home\" element={<Home />} />\n   <Route path=\"/about/team\" element={<Team />} /> {/* 多级静态路径 */}\n   ```\n\n2. **索引路由（index）**：父路由默认渲染的组件，无需额外路径\n   ```jsx\n   <Route path=\"/user\" element={<UserLayout />}>\n     {/* 当 URL 为 /user 时，渲染 UserProfile（索引组件） */}\n     <Route index element={<UserProfile />} />\n     <Route path=\"settings\" element={<UserSettings />} /> {/* /user/settings */}\n   </Route>\n   ```\n\n3. **通配符路由（404）**：`path=\"*\"` 匹配所有未定义的路由，用于 404 页面\n   ```jsx\n   <Route path=\"*\" element={<NotFound />} />\n   ```\n\n### 2.3.3 注意事项\n- `element` 属性必须传入 React 元素（带 `<>`），不能传入组件函数（如 `element={Home}` 是错误的）；\n- 路由路径默认是**相对路径**，若需绝对路径，可在路径前加 `/`（如 `/about` 是绝对路径，`about` 是相对父路由的路径）；\n- `Routes` 内部的 `Route` 无需排序（v6 会自动按路径特异性排序），但通配符路由（`path=\"*\"`）需放在最后。\n\n# 3. 核心组件工作流程\n1. `BrowserRouter` 初始化路由上下文，监听 URL 变化；\n2. 当 URL 改变时，`Routes` 遍历所有子 `Route` 组件，匹配当前 URL；\n3. 找到第一个匹配的 `Route`，渲染其 `element` 属性指定的组件；\n4. 若未找到匹配的路由，渲染 `path=\"*\"` 对应的 404 组件。\n\n## 4. 常见问题与注意事项\n1. **v6 与 v5 差异**：v6 移除了 `Switch`（替换为 `Routes`）、`Redirect`（替换为 `Navigate`），`Route` 的 `component` 属性替换为 `element`；\n2. **路由组件必须在 BrowserRouter 内部**：所有使用 `Link`、`useNavigate` 等路由相关 API 的组件，必须包裹在 `BrowserRouter` 中，否则会报错；\n3. **路径匹配规则**：v6 中路由路径匹配是“精确匹配”（无需 `exact` 属性），如 `/home` 仅匹配 `/home`，不匹配 `/home/123`（动态路由除外）。","directory_id":"aee449bc-0035-43a6-834d-3e6ce98b6aff","is_published":true,"created_at":"2025-12-22 02:05:57.233923+00","updated_at":"2025-12-23 02:36:30.475034+00"},{"id":"04b2256d-0593-40ee-a70e-fd9117a36658","title":"路由跳转","content":"在 React Router v6 中，路由跳转主要通过三种方式实现：`Link` 组件（普通跳转）、`NavLink` 组件（带激活状态的跳转）、`useNavigate` 钩子（编程式跳转）。三者分别适用于不同场景，以下是详细解析：\n\n# 1. Link 组件：普通路由跳转\n`Link` 是 React Router 提供的基础跳转组件，用于在页面中创建可点击的跳转链接，本质是对原生 `<a>` 标签的封装，但不会触发页面刷新（单页应用核心特性）。\n\n## 1.1 核心作用\n- 实现无刷新跳转，保持 SPA 应用的状态；\n- 生成与路由规则匹配的 URL，避免手动拼接路径；\n- 支持相对路径和绝对路径跳转。\n\n## 1.2 核心属性\n| 属性名   | 类型          | 说明                                                                 |\n|----------|---------------|----------------------------------------------------------------------|\n| `to`     | string/object | 跳转目标路径，支持字符串（绝对/相对路径）或对象（复杂跳转配置）       |\n| `replace` | boolean       | 若为 `true`，则使用 `history.replace` 跳转（不添加新历史记录，无法回退）；默认 `false`（添加历史记录） |\n\n## 1.3 使用方式\n### 1.3.1 字符串路径（最常用）\n```jsx\nimport { Link } from 'react-router-dom';\n\nfunction Navbar() {\n  return (\n    <nav>\n      {/* 绝对路径：从根路径开始 */}\n      <Link to=\"/\">首页</Link>\n      <Link to=\"/about\">关于我们</Link>\n      \n      {/* 相对路径：基于当前路由路径 */}\n      {/* 若当前路径是 /user，则跳转后为 /user/settings */}\n      <Link to=\"settings\">用户设置</Link>\n      {/* 若当前路径是 /user/settings，则跳转后为 /user */}\n      <Link to=\"..\">返回用户中心</Link>\n    </nav>\n  );\n}\n```\n\n### 1.3.2 对象形式路径（复杂跳转）\n当需要传递搜索参数、状态等信息时，可使用对象形式的 `to` 属性：\n```jsx\n<Link\n  to={{\n    pathname: '/user', // 目标路径\n    search: '?id=123', // 搜索参数（query参数）\n    state: { from: 'navbar' } // 隐式状态（不会显示在URL中，通过useLocation获取）\n  }}\n>\n  查看用户详情\n</Link>\n```\n\n### 1.3.3 replace 模式跳转\n```jsx\n// 跳转后不会添加新历史记录，点击回退会回到上上个页面\n<Link to=\"/login\" replace>\n  登录（不可回退）\n</Link>\n```\n\n## 1.4 注意事项\n- `Link` 组件必须在 `BrowserRouter` 内部使用，否则会报错；\n- 避免在 `Link` 内部嵌套 `<a>` 标签，可能导致冲突；\n- 相对路径的基准是当前路由的**路径部分**，而非文件目录结构。\n\n# 2. NavLink 组件：带激活状态的跳转\n`NavLink` 是 `Link` 组件的增强版，除了具备 `Link` 的所有功能外，还支持在路由匹配时自动添加激活状态（如高亮样式），适用于导航菜单、Tab 切换等场景。\n\n## 2.1 核心特性\n- 路由匹配时，自动为组件添加激活类名或样式；\n- 支持自定义激活条件、激活类名、激活样式；\n- 完全兼容 `Link` 的所有属性（`to`、`replace` 等）。\n\n## 2.2 核心属性（新增属性）\n| 属性名         | 类型          | 说明                                                                 |\n|----------------|---------------|----------------------------------------------------------------------|\n| `className`    | string/function | 静态类名，或接收 `isActive` 参数的函数（返回动态类名）               |\n| `style`        | object/function | 静态样式，或接收 `isActive` 参数的函数（返回动态样式）               |\n| `isActive`     | function      | 自定义激活判定函数，接收 `match` 和 `location` 参数，返回布尔值       |\n| `caseSensitive`| boolean       | 是否大小写敏感匹配路径，默认 `false`                                 |\n\n## 2.3 使用方式\n### 2.3.1 基础激活样式（默认类名）\nReact Router v6 中，`NavLink` 匹配成功时默认添加 `active` 类名，可直接通过 CSS 样式控制高亮：\n```jsx\n// 组件代码\nimport { NavLink } from 'react-router-dom';\nimport './Navbar.css';\n\nfunction Navbar() {\n  return (\n    <nav>\n      <NavLink to=\"/\">首页</NavLink>\n      <NavLink to=\"/about\">关于我们</NavLink>\n      <NavLink to=\"/user\">用户中心</NavLink>\n    </nav>\n  );\n}\n\n// Navbar.css\n/* 匹配成功时的高亮样式 */\nnav a.active {\n  color: #1890ff;\n  font-weight: bold;\n  border-bottom: 2px solid #1890ff;\n}\n```\n\n### 2.3.2 自定义激活类名\n通过 `className` 函数自定义激活类名：\n```jsx\n<NavLink\n  to=\"/about\"\n  // isActive 为布尔值，true 表示当前路由匹配\n  className={(isActive) => (isActive ? 'nav-active' : 'nav-normal')}\n>\n  关于我们\n</NavLink>\n\n// CSS\n.nav-active {\n  color: red;\n  background: #f5f5f5;\n}\n.nav-normal {\n  color: #333;\n}\n```\n\n### 2.3.3 自定义激活样式\n通过 `style` 函数直接设置激活样式：\n```jsx\n<NavLink\n  to=\"/user\"\n  style={(isActive) => ({\n    color: isActive ? '#1890ff' : '#666',\n    padding: '8px 16px',\n    textDecoration: 'none',\n  })}\n>\n  用户中心\n</NavLink>\n```\n\n### 2.3.4 自定义激活判定逻辑\n通过 `isActive` 函数控制激活条件（适用于复杂路由匹配）：\n```jsx\n// 当路径包含 /user 时（如 /user、/user/settings），均视为激活\n<NavLink\n  to=\"/user\"\n  isActive={(match) => {\n    if (!match) return false;\n    // match.pathname 为当前匹配的路径\n    return match.pathname.startsWith('/user');\n  }}\n>\n  用户中心（包含子路由激活）\n</NavLink>\n```\n\n# 3. useNavigate 钩子：编程式跳转\n`useNavigate` 是 React Router v6 提供的钩子函数，用于在组件逻辑中（如按钮点击、请求成功后）触发路由跳转，支持更灵活的编程式控制（替代 v5 中的 `useHistory`）。\n\n## 3.1 核心作用\n- 在函数组件中通过代码触发跳转（无需手动操作 DOM）；\n- 支持前进、后退、替换历史记录等操作；\n- 可传递搜索参数、状态信息。\n\n## 3.2 基本用法\n### 3.2.1 导入与初始化\n```jsx\nimport { useNavigate } from 'react-router-dom';\n\nfunction LoginButton() {\n  // 初始化 navigate 函数\n  const navigate = useNavigate();\n\n  const handleLogin = () => {\n    // 模拟登录成功\n    const loginSuccess = true;\n    if (loginSuccess) {\n      // 跳转至首页\n      navigate('/');\n    }\n  };\n\n  return <button onClick={handleLogin}>登录</button>;\n}\n```\n\n### 3.2.2 核心跳转 API\n```jsx\nconst navigate = useNavigate();\n\n// 1. 基础跳转（添加历史记录，可回退）\nnavigate('/about'); // 绝对路径\nnavigate('settings'); // 相对路径（基于当前路由）\n\n// 2. 替换历史记录（不可回退）\nnavigate('/login', { replace: true });\n\n// 3. 前进/后退（类似浏览器的前进后退按钮）\nnavigate(-1); // 后退一页\nnavigate(1); // 前进一页\nnavigate(-2); // 后退两页\n\n// 4. 传递状态（隐式参数，不会显示在URL中）\nnavigate('/user', {\n  state: { from: 'login', userId: 123 } // 状态数据\n});\n\n// 5. 传递搜索参数（显式参数，URL中可见）\nnavigate('/user?id=123&name=张三');\n// 或通过 URLSearchParams 拼接\nconst params = new URLSearchParams({ id: 123, name: '张三' });\nnavigate(`/user?${params}`);\n```\n\n### 3.2.3 结合异步操作跳转\n```jsx\nfunction UserForm() {\n  const navigate = useNavigate();\n\n  const handleSubmit = async (e) => {\n    e.preventDefault();\n    try {\n      // 模拟提交表单请求\n      await fetch('/api/submit', { method: 'POST', body: JSON.stringify(formData) });\n      // 请求成功后跳转至结果页，并传递状态\n      navigate('/submit-success', {\n        state: { message: '提交成功！' },\n        replace: true // 避免回退到表单页\n      });\n    } catch (error) {\n      console.error('提交失败：', error);\n    }\n  };\n\n  return <form onSubmit={handleSubmit}>{/* 表单内容 */}</form>;\n}\n```\n\n## 3.3 注意事项\n- `useNavigate` 只能在函数组件或自定义 Hooks 中使用，不能在类组件或普通函数中调用；\n- 传递的 `state` 数据会存储在浏览器的历史记录中，刷新页面后会丢失（若需持久化，需使用本地存储或后端存储）；\n- 相对路径跳转的基准是当前路由的路径，而非文件目录，若需跳转到根路径，需使用绝对路径（如 `/home`）。\n\n# 4. 三种跳转方式对比与场景选择\n| 跳转方式   | 核心优势                  | 适用场景                                  |\n|------------|---------------------------|-------------------------------------------|\n| `Link`     | 简单易用，无额外逻辑      | 页面中静态跳转链接（如导航栏、文本链接）  |\n| `NavLink`  | 自带激活状态，支持样式控制 | 导航菜单、Tab 切换、需要高亮当前页的场景  |\n| `useNavigate` | 编程式控制，支持异步跳转  | 按钮点击、表单提交、请求成功后等动态场景  |\n\n# 5. 常见问题与解决方案\n1. **跳转后页面不刷新**：SPA 特性，路由跳转仅替换组件内容，不会刷新整个页面，若需刷新数据，可在组件的 `useEffect` 中监听路由变化；\n2. **`state` 数据丢失**：`state` 存储在内存中的历史记录，刷新页面后丢失，解决方案：\n   - 重要数据通过搜索参数传递（URL 可见）；\n   - 非敏感数据使用 `localStorage` 持久化；\n3. **相对路径跳转错误**：确保相对路径的基准是当前路由的路径，而非文件目录，可通过 `useLocation` 钩子获取当前路径，辅助调试：\n   ```jsx\n   import { useLocation } from 'react-router-dom';\n   const location = useLocation();\n   console.log('当前路径：', location.pathname); // 查看当前路径，辅助拼接相对路径\n   ```","directory_id":"aee449bc-0035-43a6-834d-3e6ce98b6aff","is_published":true,"created_at":"2025-12-22 02:06:18.567992+00","updated_at":"2025-12-23 02:40:11.081143+00"},{"id":"0753cad5-fccc-4a27-8085-ed21e72b1a3b","title":"React Hook Form 入门","content":"# 1. React Hook Form 核心优势\nReact Hook Form（RHF）是一款轻量级、高性能的 React 表单库，核心设计理念是“非受控表单 + 原生验证”，相比传统受控表单方案，具有以下优势：\n- **性能优异**：减少不必要的组件重渲染（仅追踪需要验证的字段）；\n- **体积小巧**：核心包体积约 10KB（gzip 后），无冗余依赖；\n- **易用性高**：基于 Hooks 设计，API 简洁直观；\n- **原生兼容**：支持原生 HTML 表单验证，可与第三方 UI 库无缝集成；\n- **扩展性强**：支持自定义验证、表单嵌套、异步验证等复杂场景。\n\n# 2. 基础安装与配置\n```bash\nnpm install react-hook-form\n\nyarn add react-hook-form\n```\n\n# 3. 核心 API 详解\n## 3.1 useForm：初始化表单\n`useForm` 是 RHF 的核心 Hook，用于初始化表单实例，返回一系列操作表单的方法和状态。\n\n**基础用法**：\n```javascript\nimport { useForm } from 'react-hook-form';\n\nfunction BasicForm() {\n  // 初始化表单实例\n  const {\n    register, // 注册表单字段\n    handleSubmit, // 处理表单提交\n    formState: { errors } // 表单状态（错误信息）\n  } = useForm();\n\n  // 提交成功回调\n  const onSubmit = (data) => {\n    console.log('表单数据：', data);\n  };\n\n  return (\n    <form onSubmit={handleSubmit(onSubmit)}>\n      {/* 注册表单字段 */}\n      <div>\n        <label>用户名：</label>\n        <input {...register('username')} placeholder=\"请输入用户名\" />\n      </div>\n      <button type=\"submit\">提交</button>\n    </form>\n  );\n}\n```\n\n**useForm 配置项**：\n```javascript\nconst { register, handleSubmit } = useForm({\n  mode: 'onSubmit', // 验证时机：onSubmit（默认）/onChange/onBlur/onTouched\n  defaultValues: { // 表单默认值\n    username: '',\n    password: ''\n  },\n  reValidateMode: 'onChange', // 重新验证时机\n  shouldFocusError: true, // 提交时自动聚焦到第一个错误字段\n  criteriaMode: 'firstError' // 错误展示模式：firstError（默认）/allErrors\n});\n```\n\n## 3.2 register：注册表单字段\n`register` 用于将表单元素与 RHF 实例关联，支持配置验证规则、默认值等。\n\n**语法**：\n```javascript\nregister(name, options)\n```\n\n**参数说明**：\n- `name`：字段名（支持嵌套，如 `user.name`）；\n- `options`：验证规则配置（可选）。\n\n**基础验证规则示例**：\n```javascript\nimport { useForm } from 'react-hook-form';\n\nfunction RegisterForm() {\n  const { register, handleSubmit, formState: { errors } } = useForm();\n\n  const onSubmit = (data) => console.log(data);\n\n  return (\n    <form onSubmit={handleSubmit(onSubmit)}>\n      {/* 用户名：必填 + 长度 3-10 位 */}\n      <div>\n        <label>用户名：</label>\n        <input\n          {...register('username', {\n            required: '用户名不能为空', // 必填验证（自定义错误信息）\n            minLength: {\n              value: 3,\n              message: '用户名长度不能少于 3 位'\n            },\n            maxLength: {\n              value: 10,\n              message: '用户名长度不能超过 10 位'\n            }\n          })}\n          placeholder=\"请输入用户名\"\n        />\n        {/* 显示错误信息 */}\n        {errors.username && <span style={{ color: 'red' }}>{errors.username.message}</span>}\n      </div>\n\n      {/* 密码：必填 + 最小长度 6 位 */}\n      <div>\n        <label>密码：</label>\n        <input\n          type=\"password\"\n          {...register('password', {\n            required: '密码不能为空',\n            minLength: { value: 6, message: '密码长度不能少于 6 位' }\n          })}\n          placeholder=\"请输入密码\"\n        />\n        {errors.password && <span style={{ color: 'red' }}>{errors.password.message}</span>}\n      </div>\n\n      <button type=\"submit\">提交</button>\n    </form>\n  );\n}\n```\n\n## 3.3 handleSubmit：处理表单提交\n`handleSubmit` 用于包装提交回调函数，自动触发表单验证：\n- 验证通过：执行 `onSubmit` 回调，传入表单数据；\n- 验证失败：不执行 `onSubmit`，更新 `errors` 状态。\n\n**支持错误回调**：\n```javascript\nconst onSubmit = (data) => console.log('成功：', data);\nconst onError = (errors) => console.log('失败：', errors);\n\n<form onSubmit={handleSubmit(onSubmit, onError)}>\n  {/* 表单内容 */}\n</form>\n```\n\n# 4. 常用验证规则\nRHF 支持丰富的内置验证规则，也支持自定义验证函数：\n\n| 规则 | 说明 | 示例 |\n|------|------|------|\n| `required` | 必填项 | `required: '字段不能为空'` |\n| `minLength` | 最小长度 | `minLength: { value: 3, message: '长度≥3' }` |\n| `maxLength` | 最大长度 | `maxLength: { value: 10, message: '长度≤10' }` |\n| `min` | 最小值（数值） | `min: { value: 18, message: '≥18' }` |\n| `max` | 最大值（数值） | `max: { value: 60, message: '≤60' }` |\n| `pattern` | 正则匹配 | `pattern: { value: /^1[3-9]\\d{9}$/, message: '手机号格式错误' }` |\n| `validate` | 自定义验证 | `validate: (value) => value !== 'admin' || '不能为admin'` |\n\n## 自定义验证示例（异步验证）：\n```javascript\n<input\n  {...register('email', {\n    required: '邮箱不能为空',\n    pattern: {\n      value: /^[\\w.-]+@[a-zA-Z0-9-]+\\.[a-zA-Z]{2,}$/,\n      message: '邮箱格式错误'\n    },\n    // 异步验证：检查邮箱是否已注册\n    validate: async (value) => {\n      const res = await fetch(`/api/check-email?email=${value}`);\n      const data = await res.json();\n      return data.available || '该邮箱已被注册';\n    }\n  })}\n/>\n```\n\n# 5. 高级用法\n## 5.1 嵌套字段（复杂表单）\n支持嵌套字段名（如 `user.name`、`user.address.city`），表单数据会自动生成嵌套对象：\n```javascript\nfunction NestedForm() {\n  const { register, handleSubmit, formState: { errors } } = useForm({\n    defaultValues: {\n      user: {\n        name: '',\n        email: ''\n      },\n      address: {\n        city: '',\n        street: ''\n      }\n    }\n  });\n\n  const onSubmit = (data) => {\n    console.log(data);\n    // 输出：{ user: { name: '', email: '' }, address: { city: '', street: '' } }\n  };\n\n  return (\n    <form onSubmit={handleSubmit(onSubmit)}>\n      <div>\n        <label>姓名：</label>\n        <input {...register('user.name', { required: '姓名不能为空' })} />\n        {errors.user?.name && <span style={{ color: 'red' }}>{errors.user.name.message}</span>}\n      </div>\n      <div>\n        <label>邮箱：</label>\n        <input {...register('user.email', { required: '邮箱不能为空' })} />\n        {errors.user?.email && <span style={{ color: 'red' }}>{errors.user.email.message}</span>}\n      </div>\n      <div>\n        <label>城市：</label>\n        <input {...register('address.city', { required: '城市不能为空' })} />\n        {errors.address?.city && <span style={{ color: 'red' }}>{errors.address.city.message}</span>}\n      </div>\n      <button type=\"submit\">提交</button>\n    </form>\n  );\n}\n```\n\n## 5.2 表单重置与setValue\n- `reset`：重置表单到默认值（或指定值）；\n- `setValue`：手动设置单个字段值。\n\n```javascript\nimport { useForm } from 'react-hook-form';\n\nfunction ResetForm() {\n  const { register, handleSubmit, reset, setValue } = useForm({\n    defaultValues: { username: '' }\n  });\n\n  const onSubmit = (data) => console.log(data);\n\n  return (\n    <form onSubmit={handleSubmit(onSubmit)}>\n      <input {...register('username')} placeholder=\"用户名\" />\n      <button type=\"submit\">提交</button>\n      <button type=\"button\" onClick={() => reset()}>重置默认值</button>\n      <button type=\"button\" onClick={() => reset({ username: '默认用户名' })}>重置为指定值</button>\n      <button type=\"button\" onClick={() => setValue('username', '手动设置值')}>手动设置值</button>\n    </form>\n  );\n}\n```\n\n## 5.3 与 UI 库集成（以 Ant Design 为例）\nRHF 可与 Ant Design、Material UI 等组件库无缝集成，通过 `register` 绑定组件的 `onChange` 和 `value`：\n```javascript\nimport { useForm } from 'react-hook-form';\nimport { Input, Button, Form, message } from 'antd';\n\nfunction AntdForm() {\n  const { register, handleSubmit, formState: { errors } } = useForm();\n\n  const onSubmit = (data) => {\n    message.success('提交成功');\n    console.log(data);\n  };\n\n  return (\n    <Form onFinish={handleSubmit(onSubmit)}>\n      <Form.Item\n        label=\"用户名\"\n        validateStatus={errors.username ? 'error' : ''}\n        help={errors.username?.message}\n      >\n        <Input\n          placeholder=\"请输入用户名\"\n          {...register('username', {\n            required: '用户名不能为空',\n            minLength: { value: 3, message: '用户名长度≥3' }\n          })}\n        />\n      </Form.Item>\n      <Form.Item\n        label=\"密码\"\n        validateStatus={errors.password ? 'error' : ''}\n        help={errors.password?.message}\n      >\n        <Input.Password\n          placeholder=\"请输入密码\"\n          {...register('password', {\n            required: '密码不能为空',\n            minLength: { value: 6, message: '密码长度≥6' }\n          })}\n        />\n      </Form.Item>\n      <Form.Item>\n        <Button type=\"primary\" htmlType=\"submit\">提交</Button>\n      </Form.Item>\n    </Form>\n  );\n}\n```\n\n# 6. 性能优化\n- **减少重渲染**：使用 `useForm` 的 `shouldUnregister` 配置（默认 `true`），卸载组件时自动注销字段，避免无效渲染；\n- **延迟验证**：通过 `mode: 'onBlur'` 或 `mode: 'onSubmit'` 减少实时验证的性能开销；\n- **批量更新**：使用 `batch` 方法批量更新表单状态，避免多次重渲染。","directory_id":"fa2521c5-ab87-4500-9375-449364eb3b13","is_published":true,"created_at":"2025-12-22 03:19:01.863528+00","updated_at":"2025-12-23 13:10:57.109815+00"},{"id":"0cb041b2-afd7-4c00-a4f3-c73502ccfa50","title":"React 单元测试","content":"# 1. 测试核心概念与工具选型\n## 1.1 单元测试的价值\nReact 项目中单元测试聚焦于最小可测试单元（组件、函数、Hook），核心价值：\n- 验证代码功能正确性，减少回归 bug；\n- 提升代码可维护性（测试用例即文档）；\n- 支持重构信心（重构后测试通过即功能稳定）。\n\n## 1.2 主流测试工具组合\n- **Jest**：Facebook 开发的测试运行器，提供测试框架、断言库、模拟（Mock）功能、覆盖率统计；\n- **React Testing Library**：轻量级测试库，强调“用户行为驱动测试”（而非测试实现细节），与 Jest 无缝集成；\n- 替代方案：Enzyme（更关注组件内部实现，维护频率降低，逐渐被 React Testing Library 取代）。\n\n# 2. 环境搭建\n## 2.1 新建项目（内置测试环境）\n- **Create React App（CRA）**：默认内置 Jest + React Testing Library，无需额外配置：\n  ```bash\n  npx create-react-app my-test-app --template typescript # TypeScript 项目\n  ```\n- **Vite 项目**：需手动安装依赖：\n  ```bash\n  npm install -D jest @testing-library/react @testing-library/jest-dom @testing-library/user-event jsdom @types/jest ts-jest # TypeScript 项目\n  ```\n  配置 `jest.config.js`：\n  ```javascript\n  export default {\n    testEnvironment: 'jsdom', // 模拟浏览器环境\n    transform: {\n      '^.+\\\\.(ts|tsx)$': 'ts-jest', // 处理 TypeScript\n    },\n    moduleFileExtensions: ['ts', 'tsx', 'js', 'jsx'],\n    setupFilesAfterEnv: ['<rootDir>/src/setupTests.ts'], // 全局配置\n  };\n  ```\n  创建 `src/setupTests.ts`（扩展匹配器）：\n  ```typescript\n  import '@testing-library/jest-dom'; // 提供额外断言（如 toBeInTheDocument）\n  ```\n\n## 2.2 已有项目集成\n```bash\nnpm install -D jest @testing-library/react @testing-library/jest-dom @testing-library/user-event\n\nnpm install -D @types/jest ts-jest\n\nnpm install -D jsdom\n```\n\n# 3. 核心 API 详解\n## 3.1 React Testing Library 核心 API\n| API 名称               | 作用                                                                 |\n|------------------------|----------------------------------------------------------------------|\n| `render(component)`    | 渲染 React 组件到测试 DOM 中，返回查询方法（getBy*、queryBy* 等）|\n| `screen`               | 全局查询对象，替代 render 返回的查询方法（推荐使用）|\n| `fireEvent`            | 触发 DOM 事件（如 click、change）|\n| `userEvent`            | 模拟真实用户行为（更贴近真实操作，如 type、click，推荐替代 fireEvent） |\n| `waitFor`              | 等待异步操作完成（如接口请求、状态更新）|\n| `act()`                | 包裹 React 渲染/更新逻辑（React Testing Library 已自动封装，无需手动调用） |\n\n## 3.2 查询方法分类（优先级从高到低）\nReact Testing Library 推荐按“用户可感知”的方式查询元素，而非 DOM 结构：\n1. **getByRole**：按 ARIA 角色查询（最推荐，符合无障碍设计）\n   ```tsx\n   screen.getByRole('button', { name: /提交/i }); // 查询名称包含“提交”的按钮\n   ```\n2. **getByLabelText**：按表单标签文本查询（适用于输入框）\n   ```tsx\n   screen.getByLabelText(/用户名/i); // 查询标签为“用户名”的输入框\n   ```\n3. **getByPlaceholderText**：按占位符文本查询\n   ```tsx\n   screen.getByPlaceholderText(/请输入密码/i);\n   ```\n4. **getByText**：按文本内容查询\n   ```tsx\n   screen.getByText(/登录成功/i);\n   ```\n5. **getByTestId**：按自定义测试 ID 查询（万不得已时使用，需给元素加 `data-testid` 属性）\n   ```tsx\n   // 组件中：<div data-testid=\"user-card\">...</div>\n   screen.getByTestId('user-card');\n   ```\n\n**查询方法后缀差异**：\n- `getBy*`：立即查询，找不到元素抛出错误（适用于元素肯定存在的场景）；\n- `queryBy*`：立即查询，找不到元素返回 `null`（适用于元素可能不存在的场景）；\n- `findBy*`：异步查询（返回 Promise），等待元素出现（适用于异步渲染的元素，如接口请求后显示）。\n\n## 3.3 Jest 核心功能\n- **断言**：使用 Jest 内置断言库验证结果：\n  ```tsx\n  expect(screen.getByText(/hello/i)).toBeInTheDocument(); // 元素存在\n  expect(screen.queryByText(/error/i)).not.toBeInTheDocument(); // 元素不存在\n  expect(input).toHaveValue('test'); // 输入框值为 test\n  ```\n- **Mock 函数**：模拟函数并验证调用：\n  ```tsx\n  const mockClick = jest.fn();\n  render(<Button onClick={mockClick}>点击</Button>);\n  userEvent.click(screen.getByRole('button'));\n  expect(mockClick).toHaveBeenCalledTimes(1); // 被调用 1 次\n  ```\n- **覆盖率统计**：\n  ```bash\n  npm test -- --coverage # 生成覆盖率报告\n  ```\n\n# 4. 基础测试示例\n## 4.1 组件渲染测试\n测试组件是否正常渲染核心内容：\n```tsx\n// Button.tsx\nimport React from 'react';\n\ninterface ButtonProps {\n  children: React.ReactNode;\n  onClick?: () => void;\n}\n\nconst Button = ({ children, onClick }: ButtonProps) => {\n  return <button onClick={onClick}>{children}</button>;\n};\n\nexport default Button;\n\n// Button.test.tsx\nimport React from 'react';\nimport { screen, render } from '@testing-library/react';\nimport userEvent from '@testing-library/user-event';\nimport Button from './Button';\n\ntest('Button 渲染正确的文本', () => {\n  // 渲染组件\n  render(<Button>提交</Button>);\n  // 验证文本存在\n  const button = screen.getByRole('button', { name: /提交/i });\n  expect(button).toBeInTheDocument();\n});\n\ntest('Button 点击触发回调', async () => {\n  const user = userEvent.setup(); // 初始化 userEvent\n  const mockClick = jest.fn();\n  render(<Button onClick={mockClick}>提交</Button>);\n  // 模拟用户点击\n  await user.click(screen.getByRole('button', { name: /提交/i }));\n  // 验证回调被调用\n  expect(mockClick).toHaveBeenCalledTimes(1);\n});\n```\n\n## 4.2 自定义 Hook 测试\n使用 `@testing-library/react-hooks` 测试自定义 Hook（需安装依赖：`npm install -D @testing-library/react-hooks`）：\n```tsx\n// useCounter.ts\nimport { useState } from 'react';\n\nconst useCounter = (initialValue = 0) => {\n  const [count, setCount] = useState(initialValue);\n  const increment = () => setCount(count + 1);\n  const decrement = () => setCount(count - 1);\n  return { count, increment, decrement };\n};\n\nexport default useCounter;\n\n// useCounter.test.ts\nimport { renderHook, act } from '@testing-library/react-hooks';\nimport useCounter from './useCounter';\n\ntest('useCounter 初始化值正确', () => {\n  const { result } = renderHook(() => useCounter(5));\n  expect(result.current.count).toBe(5);\n});\n\ntest('increment 方法增加计数', () => {\n  const { result } = renderHook(() => useCounter());\n  act(() => {\n    result.current.increment();\n  });\n  expect(result.current.count).toBe(1);\n});\n```\n\n# 5. 测试最佳实践\n1. **测试用户行为，而非实现细节**：\n   - 坏：测试组件内部状态变量（如 `expect(component.state.count).toBe(1)`）；\n   - 好：测试用户可见的结果（如 `expect(screen.getByText('Count: 1')).toBeInTheDocument()`）。\n2. **使用 `screen` 全局查询**：避免依赖 render 返回的查询对象，简化代码。\n3. **优先使用 `userEvent` 而非 `fireEvent`**：`userEvent` 模拟真实用户行为（如输入时触发 focus/change 事件），更贴近实际场景。\n4. **异步测试使用 `waitFor`/`findBy*`**：处理接口请求、定时器等异步逻辑。\n5. **避免测试第三方组件**：聚焦于自己编写的业务代码。","directory_id":"a563f346-3dac-4331-b926-8587cb32b144","is_published":true,"created_at":"2025-12-22 03:20:23.998591+00","updated_at":"2025-12-23 13:43:12.068041+00"},{"id":"0f7107cf-5ab8-4ebd-8e82-871bde498644","title":"React 项目打包优化","content":"# 1. 打包优化核心目标\n- 减小打包体积（减少加载时间、降低带宽消耗）；\n- 提升加载速度（按需加载、缓存优化、CDN 加速）；\n- 优化构建效率（缩短打包时间）。\n\n# 2. Tree Shaking（摇树优化）\n## 2.1 核心原理\nTree Shaking 是基于 ES 模块（`import`/`export`）的静态分析技术，移除代码中未被使用的部分（死代码），核心依赖：\n- 模块必须是 ES 模块（CommonJS 模块 `require` 为动态导入，无法静态分析）；\n- 打包工具（Webpack/Rollup）识别未使用的导出并删除；\n- 代码压缩工具（Terser）移除死代码。\n\n## 2.2 启用条件\n1. **确保模块为 ES 模块**：\n   - 项目代码使用 `import`/`export`（避免 `require`）；\n   - 第三方库优先选择 ES 模块版本（查看 `package.json` 中的 `module` 字段）；\n   - Webpack 中设置 `mode: 'production'`（自动启用 Tree Shaking）。\n\n2. **避免破坏 Tree Shaking 的写法**：\n   - 不使用 `import * as xxx` 导入所有模块（无法静态分析）；\n   - 不将导出赋值给变量后使用（如 `const func = xxx; func()`）；\n   - 避免副作用（如导入时执行代码的模块，需在 `package.json` 中标记 `sideEffects`）。\n\n3. **标记副作用（sideEffects）**：\n   在 `package.json` 中声明无副作用的文件，让 Webpack 放心删除未使用代码：\n   ```json\n   {\n     \"sideEffects\": [\n       \"*.css\", // CSS 文件有副作用（导入即生效）\n       \"*.scss\",\n       \"src/global.js\" // 全局代码有副作用\n     ]\n   }\n   ```\n   若项目无副作用文件，可设为 `\"sideEffects\": false`。\n\n## 2.3 实战配置\n### 2.3.1 Webpack 配置\n```javascript\n// webpack.config.js\nmodule.exports = {\n  mode: 'production', // 生产模式自动启用 Tree Shaking\n  optimization: {\n    usedExports: true, // 标记未使用的导出\n    sideEffects: true, // 启用副作用分析\n  },\n  resolve: {\n    extensions: ['.tsx', '.ts', '.js'],\n    mainFields: ['module', 'main'], // 优先加载 ES 模块版本\n  },\n};\n```\n\n### 2.3.2 Vite 配置（天然支持 Tree Shaking）\nVite 生产环境基于 Rollup 构建，默认启用 Tree Shaking，无需额外配置，只需确保：\n- 项目使用 ES 模块；\n- 第三方库提供 ES 模块版本；\n- 标记 `sideEffects`（同 Webpack）。\n\n## 2.4 验证 Tree Shaking 效果\n- 使用 `webpack-bundle-analyzer` 分析打包体积：\n  ```bash\n  npm install -D webpack-bundle-analyzer\n  ```\n  ```javascript\n  // webpack.config.js\n  const BundleAnalyzerPlugin = require('webpack-bundle-analyzer').BundleAnalyzerPlugin;\n  module.exports = {\n    plugins: [new BundleAnalyzerPlugin()], // 打包后自动打开分析页面\n  };\n  ```\n- 查看分析报告中是否存在未使用的代码块，确认体积是否减小。\n\n# 3. 代码/资源压缩\n## 3.1 JS 压缩\n- **Webpack**：生产模式默认使用 `TerserPlugin` 压缩 JS，可自定义配置：\n  ```javascript\n  // webpack.config.js\n  const TerserPlugin = require('terser-webpack-plugin');\n  module.exports = {\n    optimization: {\n      minimizer: [\n        new TerserPlugin({\n          parallel: true, // 多线程压缩（提升速度）\n          terserOptions: {\n            compress: {\n              drop_console: true, // 生产环境移除 console\n              drop_debugger: true, // 移除 debugger\n              pure_funcs: ['console.log'], // 移除指定函数调用\n            },\n            mangle: true, // 混淆变量名\n            keep_classnames: false, // 不保留类名\n            keep_fnames: false, // 不保留函数名\n          },\n        }),\n      ],\n    },\n  };\n  ```\n- **Vite**：默认使用 Esbuild 压缩 JS（比 Terser 快 20-40 倍），如需更深度压缩可切换为 Terser：\n  ```javascript\n  // vite.config.js\n  import { defineConfig } from 'vite';\n  export default defineConfig({\n    build: {\n      minify: 'terser', // 默认为 'esbuild'\n      terserOptions: {\n        compress: {\n          drop_console: true,\n        },\n      },\n    },\n  });\n  ```\n\n## 3.2 CSS 压缩\n- **Webpack**：使用 `css-minimizer-webpack-plugin` 压缩 CSS：\n  ```bash\n  npm install -D css-minimizer-webpack-plugin\n  ```\n  ```javascript\n  // webpack.config.js\n  const CssMinimizerPlugin = require('css-minimizer-webpack-plugin');\n  module.exports = {\n    optimization: {\n      minimizer: [new CssMinimizerPlugin()], // 压缩 CSS\n    },\n    module: {\n      rules: [\n        {\n          test: /\\.css$/,\n          use: [MiniCssExtractPlugin.loader, 'css-loader'], // 提取 CSS 为单独文件\n        },\n      ],\n    },\n    plugins: [new MiniCssExtractPlugin({ filename: 'css/[name].[contenthash].css' })],\n  };\n  ```\n- **Vite**：默认压缩 CSS（使用 Esbuild），无需额外配置：\n  ```javascript\n  // vite.config.js\n  export default defineConfig({\n    build: {\n      cssMinify: true, // 默认为 true\n    },\n  });\n  ```\n\n## 3.3 图片/资源压缩\n- **Webpack**：使用 `image-webpack-loader` 压缩图片：\n  ```bash\n  npm install -D image-webpack-loader\n  ```\n  ```javascript\n  // webpack.config.js\n  module.exports = {\n    module: {\n      rules: [\n        {\n          test: /\\.(png|jpe?g|gif|svg)$/i,\n          use: [\n            { loader: 'file-loader' },\n            {\n              loader: 'image-webpack-loader',\n              options: {\n                mozjpeg: { quality: 80 }, // JPEG 压缩质量\n                optipng: { enabled: false }, // 禁用 OptiPNG\n                pngquant: { quality: [0.6, 0.8] }, // PNG 压缩质量范围\n              },\n            },\n          ],\n        },\n      ],\n    },\n  };\n  ```\n- **Vite**：使用 `vite-plugin-imagemin` 压缩图片：\n  ```bash\n  npm install -D vite-plugin-imagemin\n  ```\n  ```javascript\n  // vite.config.js\n  import viteImagemin from 'vite-plugin-imagemin';\n  export default defineConfig({\n    plugins: [\n      viteImagemin({\n        gifsicle: { optimizationLevel: 3 },\n        optipng: { optimizationLevel: 2 },\n        mozjpeg: { quality: 80 },\n        pngquant: { quality: [0.6, 0.8] },\n      }),\n    ],\n  });\n  ```\n\n# 4. CDN 加速与外部化依赖\n## 4.1 核心原理\n将体积大的第三方依赖（如 React、ReactDOM、Antd）通过 CDN 引入，不打包到项目中，减少打包体积，利用 CDN 边缘节点加速加载。\n\n## 4.2 实战配置\n### 4.2.1 Webpack 外部化依赖（externals）\n```javascript\n// webpack.config.js\nmodule.exports = {\n  externals: {\n    react: 'React', // 全局变量 React 对应 import React from 'react'\n    'react-dom': 'ReactDOM', // 全局变量 ReactDOM 对应 import ReactDOM from 'react-dom'\n    antd: 'antd', // 全局变量 antd 对应 import antd from 'antd'\n  },\n};\n```\n\n在 `public/index.html` 中引入 CDN 资源：\n```html\n<!-- React & ReactDOM -->\n<script src=\"https://cdn.jsdelivr.net/npm/react@18.2.0/umd/react.production.min.js\"></script>\n<script src=\"https://cdn.jsdelivr.net/npm/react-dom@18.2.0/umd/react-dom.production.min.js\"></script>\n<!-- Antd -->\n<link rel=\"stylesheet\" href=\"https://cdn.jsdelivr.net/npm/antd@5.12.2/dist/antd.min.css\" />\n<script src=\"https://cdn.jsdelivr.net/npm/antd@5.12.2/dist/antd.min.js\"></script>\n```\n\n### 4.2.2 Vite 外部化依赖（build.rollupOptions.external）\n```javascript\n// vite.config.js\nexport default defineConfig({\n  build: {\n    rollupOptions: {\n      external: ['react', 'react-dom', 'antd'], // 外部化依赖\n      output: {\n        globals: {\n          react: 'React',\n          'react-dom': 'ReactDOM',\n          antd: 'antd',\n        },\n      },\n    },\n  },\n});\n```\n\n在 `index.html` 中引入 CDN 资源（同 Webpack）。\n\n## 4.3 注意事项\n- 选择稳定的 CDN 服务商（如 jsDelivr、UNPKG、cdnjs）；\n- 锁定依赖版本（避免 CDN 资源更新导致兼容性问题）；\n- 考虑回退方案（CDN 加载失败时使用本地资源）：\n  ```html\n  <script src=\"https://cdn.jsdelivr.net/npm/react@18.2.0/umd/react.production.min.js\"></script>\n  <script>\n    window.React || document.write('<script src=\"/js/react.production.min.js\"><\\/script>');\n  </script>\n  ```\n\n# 5. 其他优化手段\n## 5.1 代码分割（Code Splitting）\n- **路由懒加载**（React Router）：\n  ```tsx\n  import { lazy, Suspense } from 'react';\n  import { BrowserRouter, Routes, Route } from 'react-router-dom';\n\n  // 懒加载组件\n  const Home = lazy(() => import('./pages/Home'));\n  const About = lazy(() => import('./pages/About'));\n\n  function App() {\n    return (\n      <BrowserRouter>\n        <Suspense fallback={<div>Loading...</div>}>\n          <Routes>\n            <Route path=\"/\" element={<Home />} />\n            <Route path=\"/about\" element={<About />} />\n          </Routes>\n        </Suspense>\n      </BrowserRouter>\n    );\n  }\n  ```\n- **Webpack 手动分割代码**：\n  ```javascript\n  // webpack.config.js\n  module.exports = {\n    optimization: {\n      splitChunks: {\n        chunks: 'all', // 分割所有模块（同步 + 异步）\n        cacheGroups: {\n          vendors: {\n            test: /[\\\\/]node_modules[\\\\/]/,\n            name: 'vendors', // 第三方依赖打包为 vendors.js\n            priority: -10,\n          },\n          common: {\n            name: 'common', // 公共代码打包为 common.js\n            minChunks: 2,\n            priority: -20,\n          },\n        },\n      },\n    },\n  };\n  ```\n\n## 5.2 缓存优化\n- 静态资源添加哈希（`[contenthash]`）：确保文件内容不变时哈希不变，利用浏览器缓存；\n  ```javascript\n  // Webpack\n  output: {\n    filename: 'js/[name].[contenthash].js',\n    chunkFilename: 'js/[name].[contenthash].chunk.js',\n  },\n  // Vite\n  build: {\n    rollupOptions: {\n      output: {\n        entryFileNames: 'js/[name].[contenthash].js',\n        chunkFileNames: 'js/[name].[contenthash].js',\n        assetFileNames: '[ext]/[name].[contenthash].[ext]',\n      },\n    },\n  },\n  ```\n- 配置服务器缓存策略（Nginx）：对哈希资源设置长期缓存，对 `index.html` 设置不缓存。\n\n## 5.3 预加载/预获取\n- **预加载（preload）**：提前加载当前页面需要的资源；\n- **预获取（prefetch）**：空闲时加载未来可能需要的资源（如路由懒加载组件）；\n  ```tsx\n  // React Router 预获取\n  const About = lazy(() => import(/* webpackPrefetch: true */ './pages/About'));\n  ```\n\n# 6. 打包体积分析工具\n- **Webpack**：`webpack-bundle-analyzer`（可视化打包内容）；\n- **Vite**：`rollup-plugin-visualizer`（Vite 内置支持）：\n  ```javascript\n  // vite.config.js\n  import { visualizer } from 'rollup-plugin-visualizer';\n  export default defineConfig({\n    plugins: [visualizer({ open: true })],\n  });\n  ```...","directory_id":"4e45758d-1053-4937-b961-5a3cef9e566a","is_published":true,"created_at":"2025-12-22 03:20:53.753904+00","updated_at":"2025-12-23 13:59:46.121879+00"},{"id":"16754dea-2ebd-45c8-a8ec-a7516796f5ab","title":"React 是什么？","content":"# 1. 什么是 React？\nReact 是由 Facebook（现 Meta）于 2013 年开源的**前端 JavaScript 库**，专注于构建用户界面（UI），尤其擅长开发复杂、交互式的单页应用（SPA）。它并非完整的前端框架（如 Angular），而是聚焦于视图层（V 层），可与路由库（React Router）、状态管理库（Redux）等搭配，形成完整的开发解决方案。\n\n核心定位：**用组件化思想构建可复用、高性能的 UI 界面**，让开发者专注于数据变化与 UI 渲染的映射关系，无需手动操作 DOM。\n\n# 2. 核心特性\n- **组件化（Component-Based）**：将 UI 拆分为独立、可复用的组件（如按钮、导航栏、表单），组件内部维护自身状态与逻辑，可跨项目复用，降低代码冗余。\n- **声明式编程（Declarative）**：开发者只需描述“UI 应该是什么样子”（基于当前数据），React 自动处理“如何渲染”（DOM 操作），相比命令式编程（手动操作 DOM）更简洁、不易出错。\n- **虚拟 DOM（Virtual DOM）**：React 不直接操作真实 DOM，而是先在内存中构建虚拟 DOM（JavaScript 对象，映射真实 DOM 结构）。当数据变化时，先对比新旧虚拟 DOM 的差异（Diff 算法），仅将变化的部分更新到真实 DOM，大幅减少 DOM 操作次数，提升性能。\n- **单向数据流（One-Way Data Flow）**：数据只能从父组件通过 props 传递给子组件，子组件不能直接修改父组件数据，需通过触发父组件回调函数实现数据更新。这种模式让数据流向清晰，便于调试和维护。\n- **JSX 语法**：允许在 JavaScript 中嵌入 HTML 风格的代码，既保留 JavaScript 的灵活性，又简化 UI 结构描述（后续 详细讲解）。\n\n# 3. 设计理念\nReact 的核心设计理念是“**数据驱动视图**”：UI 是数据的映射，当数据发生变化时，UI 自动同步更新，开发者无需关注 DOM 操作细节。这种理念让开发重心从“操作 DOM”转移到“管理数据”，尤其适合复杂交互场景（如电商购物车、后台管理系统）。\n\n同时，React 强调“**组件化复用**”：通过拆分复杂 UI 为小型组件，实现代码复用和团队协作效率提升。组件具有独立的状态和逻辑，可单独开发、测试和维护。\n","directory_id":"885129c3-bae4-445c-979c-09863b3895f8","is_published":true,"created_at":"2025-12-19 06:43:55.588445+00","updated_at":"2025-12-19 09:04:23.929447+00"},{"id":"17d75ca9-d6a9-43ea-9175-71ae31e35d91","title":"useLayoutEffect：同步副作用","content":"`useLayoutEffect` 是 React 中用于处理**同步副作用**的 Hook，功能与 `useEffect` 类似，但执行时机不同：`useLayoutEffect` 在 DOM 更新后、浏览器绘制前同步执行，而 `useEffect` 在浏览器绘制后异步执行。`useLayoutEffect` 适用于需要同步修改 DOM、获取 DOM 布局信息（如尺寸、位置）的场景，可避免页面闪烁问题。\n\n# 1. useLayoutEffect 与 useEffect 的核心区别\n## 1.1 执行时机对比\nReact 组件渲染/更新的完整流程：\n```\n1. 组件触发渲染（state/props 变化）\n2. 执行组件函数，生成新的虚拟 DOM\n3. React 更新真实 DOM（DOM 变化）\n4. 执行 useLayoutEffect 副作用（同步，阻塞绘制）\n5. 浏览器绘制页面（用户看到更新后的 UI）\n6. 执行 useEffect 副作用（异步，不阻塞绘制）\n```\n\n| 特性         | useLayoutEffect                  | useEffect                        |\n|--------------|---------------------------------|---------------------------------|\n| 执行时机     | DOM 更新后、浏览器绘制前（同步） | DOM 更新后、浏览器绘制后（异步） |\n| 阻塞性       | 阻塞浏览器绘制（同步执行）| 不阻塞浏览器绘制（异步执行）|\n| 适用场景     | 同步修改 DOM、获取布局信息       | 数据请求、订阅、非紧急 DOM 操作  |\n| 执行顺序     | 先于 useEffect 执行              | 后于 useLayoutEffect 执行        |\n| 视觉影响     | 可避免页面闪烁                   | 可能导致页面闪烁（DOM 操作延迟） |\n\n## 1.2 直观示例：页面闪烁问题\n### 场景：根据 DOM 尺寸动态修改样式\n```jsx\n// 使用 useEffect：可能出现闪烁\nfunction EffectFlash() {\n  const [width, setWidth] = useState(0);\n  const ref = useRef(null);\n\n  useEffect(() => {\n    // 浏览器已绘制页面后执行，修改 DOM 会导致二次绘制（闪烁）\n    setWidth(ref.current.offsetWidth);\n    ref.current.style.backgroundColor = 'red';\n  }, []);\n\n  return <div ref={ref} style={{ width: '200px', height: '200px' }}>Effect 示例</div>;\n}\n\n// 使用 useLayoutEffect：无闪烁\nfunction LayoutEffectNoFlash() {\n  const [width, setWidth] = useState(0);\n  const ref = useRef(null);\n\n  useLayoutEffect(() => {\n    // 浏览器绘制前执行，DOM 修改一次性完成（无闪烁）\n    setWidth(ref.current.offsetWidth);\n    ref.current.style.backgroundColor = 'red';\n  }, []);\n\n  return <div ref={ref} style={{ width: '200px', height: '200px' }}>LayoutEffect 示例</div>;\n}\n```\n- `useEffect` 版本：组件先渲染为默认样式（无背景色），浏览器绘制后执行副作用，修改背景色 → 页面出现“默认样式 → 红色背景”的闪烁。\n- `useLayoutEffect` 版本：DOM 更新后立即执行副作用，修改背景色后浏览器才绘制页面 → 直接显示红色背景，无闪烁。\n\n# 2. useLayoutEffect 基本语法与使用场景\n## 2.1 基本语法\n与 `useEffect` 完全一致，仅执行时机不同：\n```jsx\nimport { useLayoutEffect } from 'react';\n\nuseLayoutEffect(() => {\n  // 同步副作用逻辑（DOM 操作、布局计算）\n\n  // 清理函数（可选）\n  return () => {\n    // 清理资源（如移除事件监听）\n  };\n}, [依赖项数组]);\n```\n\n## 2.2 核心使用场景\n### 场景1：获取/修改 DOM 布局信息（尺寸、位置、滚动位置）\n需要在浏览器绘制前获取 DOM 布局数据并同步修改，避免闪烁：\n```jsx\nfunction ScrollToTop() {\n  const ref = useRef(null);\n\n  useLayoutEffect(() => {\n    // 组件挂载后，同步滚动到顶部（绘制前完成，无滚动动画闪烁）\n    ref.current.scrollTop = 0;\n  }, []);\n\n  return <div ref={ref} style={{ height: '300px', overflow: 'auto' }}>\n    {/* 长列表内容 */}\n  </div>;\n}\n```\n\n### 场景2：同步修改 DOM 样式（基于布局的动态样式）\n根据 DOM 尺寸/位置动态调整样式，需确保样式修改在绘制前完成：\n```jsx\nfunction DynamicStyle() {\n  const ref = useRef(null);\n\n  useLayoutEffect(() => {\n    const dom = ref.current;\n    // 根据元素宽度设置字体大小\n    if (dom.offsetWidth < 300) {\n      dom.style.fontSize = '14px';\n    } else {\n      dom.style.fontSize = '18px';\n    }\n  }, []);\n\n  return <div ref={ref} style={{ width: '100%' }}>动态字体大小</div>;\n}\n```\n\n### 场景3：测量 DOM 元素并更新状态（避免视觉不一致）\n测量 DOM 尺寸后更新状态，确保状态与 DOM 同步：\n```jsx\nfunction MeasureDom() {\n  const [height, setHeight] = useState(0);\n  const ref = useRef(null);\n\n  useLayoutEffect(() => {\n    // 测量 DOM 高度并更新状态（绘制前完成，状态与 DOM 同步）\n    setHeight(ref.current.offsetHeight);\n  }, []);\n\n  return (\n    <div>\n      <div ref={ref}>测量我的高度</div>\n      <p>元素高度：{height}px</p>\n    </div>\n  );\n}\n```\n\n## 2.3 清理函数\n与 `useEffect` 一致，`useLayoutEffect` 的清理函数在组件卸载前或副作用重新执行前执行，且执行时机仍为“绘制前”：\n```jsx\nfunction LayoutEffectCleanup() {\n  const ref = useRef(null);\n\n  useLayoutEffect(() => {\n    const handleResize = () => {\n      console.log('窗口尺寸变化');\n      ref.current.style.width = `${window.innerWidth / 2}px`;\n    };\n\n    window.addEventListener('resize', handleResize);\n\n    // 清理函数：移除监听（组件卸载前执行）\n    return () => {\n      window.removeEventListener('resize', handleResize);\n    };\n  }, []);\n\n  return <div ref={ref} style={{ height: '200px', backgroundColor: 'blue' }}>清理示例</div>;\n}\n```\n\n# 3. useLayoutEffect 的使用注意事项\n## 3.1 避免执行耗时操作\n`useLayoutEffect` 阻塞浏览器绘制，若执行耗时逻辑（如复杂计算、循环），会导致页面加载/更新延迟，出现卡顿：\n```jsx\n// 错误示例：耗时操作阻塞绘制\nfunction SlowLayoutEffect() {\n  useLayoutEffect(() => {\n    // 耗时循环：阻塞浏览器绘制，页面卡顿\n    for (let i = 0; i < 1000000000; i++) {}\n  }, []);\n\n  return <div>耗时操作示例</div>;\n}\n```\n- 解决方案：耗时操作移至 `useEffect`（异步不阻塞）或 Web Worker（后台执行）。\n\n## 3.2 优先使用 useEffect\n`useLayoutEffect` 是“特殊场景”Hook，大部分场景下 `useEffect` 已满足需求，且无阻塞风险。遵循“最小必要原则”：\n- 非布局相关的 DOM 操作、数据请求、订阅 → 使用 `useEffect`。\n- 仅当需要同步修改 DOM 避免闪烁时 → 使用 `useLayoutEffect`。\n\n## 3.3 服务端渲染（SSR）注意事项\n在服务端渲染（如 Next.js）中，`useLayoutEffect` 会在服务端执行时抛出警告（服务端无 DOM，无法执行布局操作）。解决方案：\n- 结合 `typeof window !== 'undefined'` 判断环境：\n  ```jsx\n  function SSRCompatible() {\n    const ref = useRef(null);\n\n    useEffect(() => {\n      // 仅在客户端执行布局操作（等价于 useLayoutEffect 客户端行为）\n      if (ref.current) {\n        ref.current.style.backgroundColor = 'red';\n      }\n    }, []);\n\n    return <div ref={ref}>SSR 兼容示例</div>;\n  }\n  ```\n- 或使用 `next/dynamic` 动态导入组件（禁用 SSR）。\n\n## 3.4 依赖项数组规则与 useEffect 一致\n`useLayoutEffect` 的依赖项数组规则、清理函数逻辑与 `useEffect` 完全相同：\n- 空数组 → 仅挂载/卸载时执行。\n- 包含依赖项 → 依赖变化时执行。\n- 省略数组 → 每次渲染执行。\n- 必须包含副作用中使用的所有变量（避免闭包陷阱）。\n\n# 4. useLayoutEffect 与 useEffect 选择原则\n1. **优先使用 useEffect**：\n   - 数据请求、事件订阅、定时器、非紧急 DOM 操作 → 用 `useEffect`（不阻塞绘制，性能更优）。\n2. **必要时使用 useLayoutEffect**：\n   - 需要同步获取/修改 DOM 布局信息（尺寸、位置、滚动）→ 用 `useLayoutEffect`（避免闪烁）。\n   - 需要确保状态更新与 DOM 同步（无视觉不一致）→ 用 `useLayoutEffect`。\n3. **禁止场景**：\n   - 耗时操作（如复杂计算、大数据处理）→ 禁止用 `useLayoutEffect`（阻塞页面渲染）。\n   - 服务端渲染中的 DOM 操作 → 禁止用 `useLayoutEffect`（服务端无 DOM）。\n\n# 5. 常见误区与避坑指南\n## 误区1：滥用 useLayoutEffect 替代 useEffect\n将所有副作用都用 `useLayoutEffect` 实现，导致页面卡顿（阻塞绘制）：\n```jsx\n// 错误示例：数据请求用 useLayoutEffect（阻塞绘制）\nfunction WrongUsage() {\n  useLayoutEffect(() => {\n    // 数据请求属于异步操作，无需同步执行\n    fetch('/api/data').then(res => res.json());\n  }, []);\n\n  return <div>错误示例</div>;\n}\n```\n- 修正：数据请求改用 `useEffect`。\n\n## 误区2：忽略清理函数导致内存泄漏\n与 `useEffect` 一样，`useLayoutEffect` 中添加的事件监听、定时器需在清理函数中移除：\n```jsx\n// 错误示例：未清理定时器\nfunction LeakExample() {\n  useLayoutEffect(() => {\n    const timer = setInterval(() => {\n      console.log('定时器执行');\n    }, 1000);\n    // 无清理函数 → 组件卸载后定时器仍运行（内存泄漏）\n  }, []);\n\n  return <div>内存泄漏示例</div>;\n}\n```\n- 修正：添加清理函数 `return () => clearInterval(timer)`。\n\n## 误区3：依赖项缺失导致闭包陷阱\n`useLayoutEffect` 同样存在闭包陷阱，需将副作用中使用的变量加入依赖项数组：\n```jsx\n// 错误示例：依赖项缺失\nfunction ClosureTrap() {\n  const [count, setCount] = useState(0);\n\n  useLayoutEffect(() => {\n    // 始终捕获初始 count 值（0），无法获取更新后的值\n    console.log('count：', count);\n  }, []); // 缺失 count 依赖\n\n  return <button onClick={() => setCount(prev => prev + 1)}>+1</button>;\n}\n```\n- 修正：将 `count` 加入依赖项数组 `[count]`。\n\n# 6. 核心总结\n1. **核心区别**：与 `useEffect` 唯一差异是执行时机——`useLayoutEffect` 在 DOM 更新后、浏览器绘制前同步执行，`useEffect` 在绘制后异步执行。\n2. **核心价值**：解决同步 DOM 操作的页面闪烁问题，确保布局相关修改在浏览器绘制前完成。\n3. **使用场景**：\n   - 获取/修改 DOM 布局信息（尺寸、位置、滚动）。\n   - 同步动态修改 DOM 样式（基于布局的调整）。\n   - 测量 DOM 元素并同步更新状态。\n4. **避坑要点**：\n   - 优先使用 `useEffect`，仅在必要时用 `useLayoutEffect`。\n   - 禁止在 `useLayoutEffect` 中执行耗时操作或数据请求。\n   - 服务端渲染中避免使用 `useLayoutEffect`（或做客户端判断）。\n   - 依赖项和清理函数规则与 `useEffect` 一致。...","directory_id":"aac29662-babe-4c96-8f61-0a16830155d4","is_published":true,"created_at":"2025-12-19 15:19:19.936943+00","updated_at":"2025-12-22 02:43:20.869055+00"},{"id":"1807dd75-2e8f-4dfb-80f8-1e8ee994a6c8","title":"React Profiler 性能分析工具","content":"React Profiler 是 React 官方提供的性能分析工具，集成在 React DevTools 中，用于**定位组件渲染性能问题**（如不必要的重渲染、渲染耗时过长），是 React 性能优化的“诊断利器”。\n\n# 1. 开启 React Profiler\n1. 安装 React DevTools 浏览器扩展（Chrome/Firefox）；\n2. 打开开发者工具，切换到 `Profiler` 标签；\n3. 若提示“Profiling is disabled”，需开启应用的 profiling 模式：\n   - 开发环境：React 18 已默认开启，无需配置；\n   - 生产环境：需通过 `React.enableProfiling = true` 开启（不建议线上开启）。\n\n# 2. 核心功能与使用流程\n## 2.1 基本使用流程\n1. **录制性能数据**：\n   - 点击 Profiler 面板中的录制按钮（圆形红点）；\n   - 操作应用（如点击按钮、滚动列表、输入文本）；\n   - 再次点击录制按钮停止录制，生成性能报告。\n2. **分析性能报告**：\n   - 查看组件渲染次数、渲染耗时；\n   - 定位不必要的重渲染、耗时过长的组件；\n   - 分析渲染链路（父组件→子组件的渲染触发关系）。\n\n## 2.2 核心视图解读\n1. **火焰图（Flame Chart）**：\n   - 横向：组件渲染链路（上层为父组件，下层为子组件）；\n   - 纵向：组件渲染耗时（高度越高，耗时越长）；\n   - 颜色：\n     - 蓝色：首次渲染（mount）；\n     - 红色：重渲染（update）；\n     - 颜色深浅：耗时占比（越深越耗时）。\n   - 关键操作：\n     - 点击组件块，查看详细信息（渲染原因、耗时、props 变化）；\n     - 筛选组件（搜索框输入组件名），聚焦目标组件。\n\n2. **排名图（Ranked Chart）**：\n   - 按组件渲染耗时从高到低排序，快速定位最耗时的组件；\n   - 显示组件总耗时、平均耗时、渲染次数。\n\n3. **组件图（Component Chart）**：\n   - 显示单个组件的渲染历史（每次渲染的耗时、触发原因）；\n   - 适合分析特定组件的渲染规律（如是否频繁重渲染）。\n\n## 2.3 关键指标解读\n- **Duration**：组件渲染总耗时（包括子组件渲染耗时）；\n- **Self Time**：组件自身渲染耗时（不包括子组件）；\n- **Count**：组件渲染次数；\n- **Render Reason**：组件渲染的触发原因（如 “props changed”、“state changed”、“context changed”）。\n\n# 3. 实战：定位并解决性能问题\n## 3.1 场景：列表筛选后卡顿\n1. **录制性能数据**：\n   - 开启录制，在列表筛选框输入内容，触发列表重渲染；\n   - 停止录制，查看火焰图。\n2. **分析报告**：\n   - 发现 `List` 组件每次筛选耗时 500ms（过长）；\n   - 查看 `List` 组件的子组件 `ListItem`，发现所有列表项都重渲染（即使内容未变化）。\n3. **定位问题**：\n   - `ListItem` 组件未使用 `React.memo` 缓存；\n   - 传递给 `ListItem` 的 `onClick` 函数每次渲染生成新引用。\n4. **解决问题**：\n   - 用 `React.memo` 包装 `ListItem` 组件；\n   - 用 `useCallback` 缓存 `onClick` 函数；\n   - 重新录制，验证 `ListItem` 仅在内容变化时重渲染，列表筛选耗时降至 50ms。\n\n## 3.2 场景：父组件重渲染导致子组件无意义重渲染\n1. **录制性能数据**：\n   - 点击父组件的按钮（修改自身 state），触发父组件重渲染；\n   - 发现子组件 `Child` 也重渲染（props 未变化）。\n2. **定位问题**：\n   - `Child` 组件未使用 `React.memo` 缓存；\n   - 父组件传递给 `Child` 的 `user` 对象每次渲染生成新引用。\n3. **解决问题**：\n   - 用 `React.memo` 包装 `Child` 组件；\n   - 用 `useMemo` 缓存 `user` 对象；\n   - 重新录制，验证 `Child` 不再因父组件重渲染而重渲染。\n\n# 4. 使用注意事项\n1. **开发环境使用**：Profiler 会增加性能开销，仅在开发环境分析，生产环境禁用；\n2. **模拟真实场景**：分析时使用真实数据量（如 1000 条列表项），避免测试环境数据量过小导致问题隐藏；\n3. **多次录制验证**：单次录制可能受网络、浏览器卡顿影响，多次录制取平均值；\n4. **结合其他工具**：Profiler 定位渲染问题，Chrome Performance 工具分析 JS 执行、DOM 重排耗时，全面排查性能瓶颈。\n\n## 5. 性能优化的闭环流程\n1. **测量**：用 React Profiler 录制性能数据，定位瓶颈；\n2. **优化**：根据瓶颈类型（重渲染/耗时计算/长列表），使用对应优化策略；\n3. **验证**：重新录制性能数据，确认优化效果；\n4. **迭代**：重复上述步骤，直到性能达标。\n","directory_id":"e9432055-c489-48b5-964a-81d34278fc72","is_published":true,"created_at":"2025-12-22 03:16:38.599933+00","updated_at":"2025-12-23 09:48:34.189832+00"},{"id":"2a4fe712-3365-4605-9faf-d81931a23f20","title":"Webpack 配置 React 项目","content":"# 1. Webpack 核心概念\nWebpack 是一个静态模块打包工具，核心概念包括：\n- **入口（Entry）**：项目打包的起始文件（如 `src/index.js`）；\n- **输出（Output）**：打包后的文件路径与名称；\n- **Loader**：处理非 JS/TS 文件（如 JSX、CSS、图片），将其转为模块；\n- **Plugin**：执行打包后的优化、压缩、资源管理等任务（如 HtmlWebpackPlugin）；\n- **模式（Mode）**：分为 `development`（开发）、`production`（生产）、`none`，不同模式下内置不同优化。\n\n# 2. 手动搭建 Webpack + React 项目\n## 2.1 初始化项目\n```bash\nmkdir my-react-webpack-project\ncd my-react-webpack-project\nnpm init -y # 初始化 package.json\n```\n\n## 2.2 安装核心依赖\n```bash\nnpm install react react-dom\n\nnpm install -D webpack webpack-cli webpack-dev-server\n\nnpm install -D @babel/core @babel/preset-env @babel/preset-react babel-loader\n\nnpm install -D html-webpack-plugin\n\nnpm install -D clean-webpack-plugin\n```\n\n## 2.3 创建项目目录结构\n```\nmy-react-webpack-project/\n├── src/\n│   ├── App.js\n│   └── index.js\n├── public/\n│   └── index.html\n├── webpack.config.js # Webpack 配置文件\n└── package.json\n```\n\n# 3. Webpack 基础配置（webpack.config.js）\n## 3.1 基础结构\n```javascript\nconst path = require('path');\nconst HtmlWebpackPlugin = require('html-webpack-plugin');\nconst { CleanWebpackPlugin } = require('clean-webpack-plugin');\n\nmodule.exports = {\n  // 入口\n  entry: './src/index.js',\n  // 输出\n  output: {\n    path: path.resolve(__dirname, 'dist'), // 打包输出目录\n    filename: 'js/[name].[hash].js', // 输出文件名（带哈希防缓存）\n    publicPath: '/', // 公共路径\n  },\n  // 模式\n  mode: 'development',\n  // 开发服务器\n  devServer: {\n    port: 3000, // 端口\n    open: true, // 自动打开浏览器\n    hot: true, // 热更新\n    historyApiFallback: true, // 支持 React Router 路由刷新\n  },\n  // 模块解析规则\n  module: {\n    rules: [\n      // 处理 JS/JSX（Babel）\n      {\n        test: /\\.(js|jsx)$/,\n        exclude: /node_modules/, // 排除 node_modules\n        use: 'babel-loader',\n      },\n    ],\n  },\n  // 插件\n  plugins: [\n    new CleanWebpackPlugin(), // 清理 dist 目录\n    new HtmlWebpackPlugin({\n      template: './public/index.html', // 模板 HTML\n      filename: 'index.html', // 输出 HTML 名称\n      inject: 'body', // 将 JS 注入到 body 底部\n    }),\n  ],\n  // 解析别名\n  resolve: {\n    extensions: ['.js', '.jsx'], // 省略文件后缀\n    alias: {\n      '@': path.resolve(__dirname, 'src'), // 路径别名\n    },\n  },\n};\n```\n\n## 3.2 配置 Babel（.babelrc 或 babel.config.json）\n创建 `.babelrc` 文件，配置 Babel 预设：\n```json\n{\n  \"presets\": [\n    \"@babel/preset-env\", // 转换 ES6+ 为 ES5\n    [\"@babel/preset-react\", { \"runtime\": \"automatic\" }] // 转换 JSX，自动导入 React\n  ]\n}\n```\n\n## 3.3 编写 React 基础代码\n- `public/index.html`：\n```html\n<!DOCTYPE html>\n<html lang=\"en\">\n<head>\n  <meta charset=\"UTF-8\">\n  <title>Webpack + React</title>\n</head>\n<body>\n  <div id=\"root\"></div>\n</body>\n</html>\n```\n- `src/App.js`：\n```jsx\nimport React from 'react';\n\nconst App = () => {\n  return <h1>Hello Webpack + React!</h1>;\n};\n\nexport default App;\n```\n- `src/index.js`：\n```jsx\nimport React from 'react';\nimport ReactDOM from 'react-dom/client';\nimport App from './App';\n\nconst root = ReactDOM.createRoot(document.getElementById('root'));\nroot.render(<App />);\n```\n\n## 3.4 配置 npm 脚本\n修改 `package.json`：\n```json\n\"scripts\": {\n  \"start\": \"webpack serve --config webpack.config.js\",\n  \"build\": \"webpack --config webpack.config.js --mode production\"\n}\n```\n启动项目：\n```bash\nnpm run start # 开发环境\nnpm run build # 生产打包\n```\n\n# 4. Loader 配置（处理非 JS 资源）\n## 4.1 处理 CSS/Scss\n```bash\n\nnpm install -D style-loader css-loader sass sass-loader\n```\n在 `webpack.config.js` 的 `module.rules` 中添加：\n```javascript\n// 处理 CSS\n{\n  test: /\\.css$/,\n  use: ['style-loader', 'css-loader'], // 顺序：从右到左执行\n},\n// 处理 Scss\n{\n  test: /\\.scss$/,\n  use: ['style-loader', 'css-loader', 'sass-loader'],\n},\n```\n- `css-loader`：解析 CSS 文件；\n- `style-loader`：将 CSS 注入到 DOM 中；\n- `sass-loader`：编译 Scss 为 CSS。\n\n## 4.2 处理图片/字体资源\n```bash\nnpm install -D file-loader url-loader asset-modules\n```\nWebpack 5 内置 `asset-modules`，无需额外安装 loader：\n```javascript\n// 处理图片\n{\n  test: /\\.(png|jpg|jpeg|gif|svg)$/,\n  type: 'asset',\n  parser: {\n    dataUrlCondition: {\n      maxSize: 8 * 1024, // 小于 8KB 的图片转为 base64\n    },\n  },\n  generator: {\n    filename: 'images/[name].[hash][ext]', // 输出路径\n  },\n},\n// 处理字体\n{\n  test: /\\.(woff|woff2|eot|ttf|otf)$/,\n  type: 'asset/resource',\n  generator: {\n    filename: 'fonts/[name].[hash][ext]',\n  },\n},\n```\n\n## 4.3 处理 TypeScript\n```bash\nnpm install -D typescript ts-loader @babel/preset-typescript\nnpm install -D @types/react @types/react-dom\n```\n- 创建 `tsconfig.json`：\n```json\n{\n  \"compilerOptions\": {\n    \"target\": \"ES5\",\n    \"module\": \"ESNext\",\n    \"jsx\": \"react-jsx\",\n    \"strict\": true,\n    \"esModuleInterop\": true,\n    \"resolveJsonModule\": true,\n    \"baseUrl\": \"./\",\n    \"paths\": {\n      \"@/*\": [\"src/*\"]\n    }\n  },\n  \"include\": [\"src/**/*\"],\n  \"exclude\": [\"node_modules\"]\n}\n```\n- 修改 Webpack 配置：\n```javascript\nmodule: {\n  rules: [\n    {\n      test: /\\.(ts|tsx)$/,\n      exclude: /node_modules/,\n      use: 'ts-loader', // 或 babel-loader（需配置 @babel/preset-typescript）\n    },\n  ],\n},\nresolve: {\n  extensions: ['.ts', '.tsx', '.js', '.jsx'],\n},\n```\n\n# 5. Plugin 配置（优化与扩展）\n## 5.1 核心插件详解\n1. **HtmlWebpackPlugin**：生成 HTML 文件并自动引入打包后的 JS/CSS；\n2. **CleanWebpackPlugin**：每次打包前清理输出目录；\n3. **MiniCssExtractPlugin**：生产环境下将 CSS 提取为单独文件（替代 style-loader）：\n   ```bash\n   npm install -D mini-css-extract-plugin\n   ```\n   ```javascript\n   const MiniCssExtractPlugin = require('mini-css-extract-plugin');\n\n   module.exports = {\n     module: {\n       rules: [\n         {\n           test: /\\.css$/,\n           use: [MiniCssExtractPlugin.loader, 'css-loader'], // 生产环境使用\n         },\n       ],\n     },\n     plugins: [\n       new MiniCssExtractPlugin({\n         filename: 'css/[name].[hash].css',\n       }),\n     ],\n   };\n   ```\n4. **DefinePlugin**：定义全局常量（如环境变量）：\n   ```javascript\n   const { DefinePlugin } = require('webpack');\n\n   plugins: [\n     new DefinePlugin({\n       'process.env.NODE_ENV': JSON.stringify(process.env.NODE_ENV),\n       'process.env.REACT_APP_API_URL': JSON.stringify('http://api.example.com'),\n     }),\n   ];\n   ```\n5. **HotModuleReplacementPlugin**：开启热更新（开发环境）：\n   ```javascript\n   const { HotModuleReplacementPlugin } = require('webpack');\n\n   plugins: [new HotModuleReplacementPlugin()],\n   devServer: { hot: true },\n   ```\n6. **TerserPlugin**：生产环境压缩 JS 代码（Webpack 5 生产模式下默认开启）：\n   ```bash\n   npm install -D terser-webpack-plugin\n   ```\n   ```javascript\n   const TerserPlugin = require('terser-webpack-plugin');\n\n   module.exports = {\n     optimization: {\n       minimizer: [\n         new TerserPlugin({\n           parallel: true, // 多线程压缩\n           terserOptions: {\n             compress: { drop_console: true }, // 移除 console\n           },\n         }),\n       ],\n     },\n   };\n   ```\n\n## 5.2 代码分割（Code Splitting）\n通过 `optimization.splitChunks` 分割第三方依赖与业务代码：\n```javascript\nmodule.exports = {\n  optimization: {\n    splitChunks: {\n      chunks: 'all', // 分割所有模块（同步 + 异步）\n      cacheGroups: {\n        vendors: {\n          test: /[\\\\/]node_modules[\\\\/]/,\n          name: 'vendors', // 第三方依赖打包为 vendors.js\n          priority: -10,\n        },\n        common: {\n          name: 'common', // 公共业务代码打包为 common.js\n          minChunks: 2, // 至少被 2 个模块引用\n          priority: -20,\n          reuseExistingChunk: true,\n        },\n      },\n    },\n    runtimeChunk: 'single', // 将运行时代码分割为单独文件\n  },\n};\n```\n\n# 6. 开发与生产环境配置分离\n大型项目建议拆分配置文件：\n- `webpack.common.js`：公共配置；\n- `webpack.dev.js`：开发环境配置（继承公共配置）；\n- `webpack.prod.js`：生产环境配置（继承公共配置）。\n\n使用 `webpack-merge` 合并配置：\n```bash\nnpm install -D webpack-merge\n```\n示例（`webpack.dev.js`）：\n```javascript\nconst { merge } = require('webpack-merge');\nconst common = require('./webpack.common.js');\nconst { HotModuleReplacementPlugin } = require('webpack');\n\nmodule.exports = merge(common, {\n  mode: 'development',\n  devtool: 'inline-source-map', // 开发环境 sourcemap\n  devServer: {\n    hot: true,\n    open: true,\n  },\n  plugins: [new HotModuleReplacementPlugin()],\n});\n```\n\n# 7. 常见优化策略\n1. **缩小打包范围**：通过 `exclude`/`include` 限定 loader 处理范围；\n2. **开启缓存**：`cache-loader` 或 Webpack 5 内置缓存：\n   ```javascript\n   module.exports = {\n     cache: {\n       type: 'filesystem', // 文件系统缓存\n     },\n   };\n   ```\n3. **Tree Shaking**：生产模式下默认开启，需确保代码为 ES 模块（不可使用 CommonJS）；\n4. **CDN 引入第三方库**：通过 `externals` 排除无需打包的依赖：\n   ```javascript\n   module.exports = {\n     externals: {\n       react: 'React',\n       'react-dom': 'ReactDOM',\n     },\n   };\n   ```\n   然后在 HTML 中引入 CDN：\n   ```html\n   <script src=\"https://cdn.jsdelivr.net/npm/react@18/umd/react.production.min.js\"></script>\n   <script src=\"https://cdn.jsdelivr.net/npm/react-dom@18/umd/react-dom.production.min.js\"></script>\n   ```\n\n# 8. 与 CRA 的区别\nCRA（Create React App）是官方封装的 Webpack 配置，无需手动配置，但灵活性低；手动配置 Webpack 可完全掌控打包流程，适合复杂项目（如需要自定义 loader、plugin、代码分割策略）。\n\n# 9. 常见问题解决\n- **热更新不生效**：确保开启 `HotModuleReplacementPlugin` 且 `devServer.hot = true`；\n- **打包体积过大**：开启代码分割、Tree Shaking、CDN 引入第三方库；\n- **TypeScript 类型报错**：检查 `tsconfig.json` 配置，确保 `jsx` 模式正确；\n- **路径别名不生效**：Webpack 与 `tsconfig.json` 需同步配置别名。...","directory_id":"d8343213-03f7-4f4f-b6e3-6926e0f500a1","is_published":true,"created_at":"2025-12-22 03:19:38.515843+00","updated_at":"2025-12-23 13:20:16.945415+00"},{"id":"2c38b02a-e848-4b13-a42a-cf84c3efe428","title":"useState/Context vs Zustand vs Redux","content":"前端状态管理的核心目标是**统一管理、高效共享、可预测更新**，不同方案的设计理念和能力差异显著，选择的核心原则是：**匹配项目规模、团队熟悉度、状态复杂度**。以下从核心特性、优缺点、适用场景三方面深度对比三大主流方案。\n\n# 1. useState + Context（React 原生方案）\n## 1.1 核心特性\n- `useState`：管理组件内部局部状态，触发组件重渲染；\n- `Context`：创建全局上下文，通过 `Provider` 注入状态，`useContext` 读取状态，实现跨组件共享；\n- 无额外依赖，完全基于 React 原生 API；\n- 状态更新会触发所有消费 `Context` 的组件重渲染（即使只用到部分状态）。\n\n## 1.2 优缺点\n| 优点 | 缺点 |\n|------|------|\n| 零学习成本，React 开发者天然掌握 | 状态粒度粗，更新时全局消费组件重渲染（性能瓶颈） |\n| 无需安装第三方库，减小打包体积 | 缺乏内置的异步处理、持久化、中间件等能力 |\n| 轻量简单，适合小型场景 | 状态逻辑分散，复杂场景下（如多模块联动）代码冗余 |\n| 原生集成，与 React 生命周期深度兼容 | 无调试工具，状态变化追踪困难 |\n\n## 1.3 适用场景\n- **小型项目/独立组件**：如个人博客、简单表单页面、单组件内的状态共享（如弹窗显隐、表单输入）；\n- **原型开发**：快速验证功能，无需引入复杂工具；\n- **局部状态共享**：跨 2-3 层组件的状态传递（如父组件向深层子组件传值，替代 props 透传）；\n- **无复杂异步逻辑**：状态更新仅依赖同步操作，无需处理 API 请求、定时器等异步场景。\n\n## 1.4 典型示例（Theme 切换）\n```javascript\n// 创建 Context\nconst ThemeContext = React.createContext();\n\n// 提供状态的 Provider 组件\nfunction ThemeProvider({ children }) {\n  const [theme, setTheme] = useState('light');\n  \n  const toggleTheme = () => {\n    setTheme(prev => prev === 'light' ? 'dark' : 'light');\n  };\n  \n  return (\n    <ThemeContext.Provider value={{ theme, toggleTheme }}>\n      {children}\n    </ThemeContext.Provider>\n  );\n}\n\n// 消费状态的组件\nfunction Header() {\n  const { theme, toggleTheme } = useContext(ThemeContext);\n  return (\n    <header className={theme}>\n      <button onClick={toggleTheme}>切换主题</button>\n    </header>\n  );\n}\n```\n\n# 2. Zustand（轻量级集中式状态管理）\n## 2.1 核心特性\n- 基于发布-订阅模式，状态存储在独立的 store 中（非 React 组件内）；\n- 通过 `useStore` Hook 订阅状态，仅当订阅的状态变化时组件才重渲染（精准更新）；\n- 支持中间件（如持久化、日志）、异步操作（无需额外依赖）、状态分片；\n- 体积小巧（约 1KB gzip），API 极简，无 Provider 嵌套；\n- 支持 TypeScript 友好，天然类型提示。\n\n## 2.2 优缺点\n| 优点 | 缺点 |\n|------|------|\n| 体积小，性能优（精准重渲染） | 生态不如 Redux 丰富（第三方工具、插件较少） |\n| API 简洁，学习成本低（比 Redux 简单） | 大型项目中状态模块化需手动规范（无强制约束） |\n| 内置异步支持（store 中可直接写 async/await） | 调试工具功能较基础（依赖 Redux DevTools 兼容层） |\n| 无 Provider 嵌套，组件层级更清晰 | 不适用于非 React 环境（专注 React 生态） |\n\n## 2.3 适用场景\n- **中小型项目**：如管理后台、电商小程序、需要跨组件共享状态但逻辑不极端复杂的应用；\n- **对性能敏感的场景**：避免 Context 全局重渲染问题（如列表页、高频更新的状态）；\n- **团队追求开发效率**：不想引入 Redux 复杂的概念（Action/Reducer/中间件），快速实现状态共享；\n- **需要持久化/异步逻辑**：如用户登录状态持久化、API 请求状态管理（无需额外配置中间件）；\n- **TypeScript 项目**：天然的类型支持，减少类型定义工作量。\n\n## 2.4 典型示例（待办事项 Store）\n```javascript\n// 创建 store\nimport { create } from 'zustand';\nimport { persist } from 'zustand/middleware';\n\nconst useTodoStore = create(\n  persist(\n    (set) => ({\n      todos: [],\n      // 同步操作\n      addTodo: (text) => set((state) => ({\n        todos: [...state.todos, { id: Date.now(), text, completed: false }]\n      })),\n      // 异步操作\n      fetchTodos: async () => {\n        const res = await fetch('https://jsonplaceholder.typicode.com/todos');\n        const data = await res.json();\n        set({ todos: data.slice(0, 10) });\n      }\n    }),\n    { name: 'todo-storage' } // 持久化到 localStorage\n  )\n);\n\n// 消费组件\nfunction TodoList() {\n  // 仅订阅 todos 状态，仅 todos 变化时重渲染\n  const todos = useTodoStore((state) => state.todos);\n  const fetchTodos = useTodoStore((state) => state.fetchTodos);\n  \n  useEffect(() => {\n    fetchTodos();\n  }, [fetchTodos]);\n  \n  return (\n    <ul>\n      {todos.map((todo) => (\n        <li key={todo.id}>{todo.title}</li>\n      ))}\n    </ul>\n  );\n}\n```\n\n# 3. Redux（重量级集中式状态管理）\n## 3.1 核心特性\n- 严格遵循单向数据流，状态存储在单一 Store 中；\n- 基于 Action/Reducer 模式，状态更新可预测、可追踪；\n- 丰富的中间件生态（Thunk/Saga/Observable），处理复杂异步逻辑；\n- 强大的调试工具（Redux DevTools），支持时间旅行、状态回溯；\n- 跨框架兼容（可用于 React/Vue/原生 JS 项目）；\n- Redux Toolkit 简化样板代码，成为官方推荐写法。\n\n## 3.2 优缺点\n| 优点 | 缺点 |\n|------|------|\n| 状态变化完全可预测，适合大型团队协作 | 学习成本高（Action/Reducer/中间件/单向数据流等概念） |\n| 强大的调试工具，便于定位问题 | 样板代码多（原生 Redux，RTK 已优化） |\n| 丰富的生态系统，解决方案成熟 | 体积较大（含中间件后），小型项目过度设计 |\n| 强制规范的状态管理流程，代码可维护性高 | 简单场景下开发效率低（相比 Zustand/Context） |\n| 跨框架复用，状态逻辑与 UI 解耦 | 组件与 Redux 耦合度较高（需 Provider/useSelector） |\n\n## 3.3 适用场景\n- **大型复杂项目**：如企业级后台、电商平台、多人协作的大型应用（状态模块多、联动逻辑复杂）；\n- **需要严格状态追踪**：如金融、医疗等对状态可追溯性要求高的领域；\n- **复杂异步流程**：如并发请求、依赖请求、任务取消/重试（Redux-Saga 擅长处理）；\n- **跨框架项目**：状态逻辑需在 React 与其他框架（如 Vue）之间复用；\n- **团队需要强规范**：通过 Redux 的强制流程约束代码风格，降低协作成本。\n\n## 3.4 典型场景（电商购物车）\n- 购物车状态需同步到多个组件（商品列表、结算页、导航栏）；\n- 需处理商品添加/删除/修改数量的同步逻辑；\n- 需处理库存检查、价格计算等异步逻辑；\n- 需持久化购物车数据，支持页面刷新后恢复；\n- 需通过调试工具追踪购物车状态变化，定位问题。\n\n# 4. 核心对比总结表\n| 维度                | useState + Context       | Zustand                  | Redux（RTK）|\n|---------------------|--------------------------|--------------------------|--------------------------|\n| 学习成本            | 极低（原生 API）| 低（极简 API）| 高（多概念）|\n| 性能                | 差（全局重渲染）| 优（精准订阅）| 中（精准订阅）|\n| 调试能力            | 无                       | 基础（兼容 DevTools）| 极强（DevTools 全功能）|\n| 异步处理            | 需手动实现               | 内置支持（async/await）| 中间件支持（Thunk/Saga）|\n| 持久化              | 需手动实现               | 内置中间件               | 需插件（redux-persist）|\n| 团队协作友好性      | 差（无规范）| 中（需手动规范）| 优（强制规范）|\n| 打包体积            | 0（原生）| 极小（~1KB）| 中等（~10KB+）|\n| 适用项目规模        | 小型/原型                | 中小型/中型              | 中大型/大型              |\n\n# 5. 选择建议\n1. **优先用 useState + Context**：\n   - 项目规模小（单页面、少量组件）；\n   - 状态仅在局部组件共享；\n   - 无复杂异步逻辑；\n   - 追求零依赖、快速开发。\n\n2. **优先用 Zustand**：\n   - 中小型项目，需要跨组件状态共享；\n   - 对性能有要求（避免全局重渲染）；\n   - 需简单异步处理/持久化；\n   - 不想引入 Redux 的复杂概念；\n   - TypeScript 项目追求简洁类型支持。\n\n3. **优先用 Redux**：\n   - 大型项目，多人协作；\n   - 状态逻辑复杂（多模块联动、复杂异步）；\n   - 需严格的状态追踪和调试；\n   - 跨框架复用状态逻辑；\n   - 团队需要强规范约束。","directory_id":"7a39499e-a54e-4dd5-89ed-f24202ec0992","is_published":true,"created_at":"2025-12-22 03:13:52.354574+00","updated_at":"2025-12-23 09:07:05.118703+00"},{"id":"2c480f6d-15ba-4ed9-8589-727c24aa663b","title":"React 性能优化核心思路","content":"React 应用的性能瓶颈主要集中在两个方面：**不必要的组件渲染**（重复执行 render 函数）和**昂贵的计算操作**（如复杂数据处理、DOM 操作）。性能优化的核心思路可总结为：**减少渲染次数、优化渲染过程、降低计算开销**，最终实现“更快的首屏加载、更流畅的交互响应”。\n\n# 1. 减少渲染次数（核心方向）\n组件渲染是 React 最核心的性能消耗点，每次渲染会执行 render 函数、对比虚拟 DOM、更新真实 DOM（若有差异）。减少渲染次数的关键是：让组件仅在必要时渲染（状态/属性真正变化时）。\n\n## 1.1 避免不必要的重渲染触发条件\nReact 组件重渲染的触发条件：\n- 组件自身 `state` 变化；\n- 父组件重渲染（即使子组件 props 未变化）；\n- 上下文（Context）值变化（所有消费上下文的组件重渲染）；\n- 强制触发（`forceUpdate`）。\n\n## 1.2 减少重渲染的核心策略\n1. **精准控制 props 传递**：\n   - 避免传递不稳定的 props（如每次渲染生成新对象/数组/函数）；\n   - 拆分组件，让子组件仅接收必要的 props（避免因无关 props 变化触发重渲染）。\n2. **优化 Context 使用**：\n   - 将大上下文拆分为多个小上下文（如用户信息上下文、主题上下文），避免一处变化导致所有组件重渲染；\n   - 上下文值仅存储全局共享状态，不存储局部状态。\n3. **使用缓存工具**：\n   - 用 `React.memo` 缓存组件（避免父组件重渲染导致子组件无意义重渲染）；\n   - 用 `useMemo` 缓存计算结果、`useCallback` 缓存函数（避免生成新引用触发重渲染）。\n\n# 2. 优化渲染过程（减少渲染耗时）\n即使无法避免渲染，也可通过优化渲染过程降低耗时：\n1. **简化虚拟 DOM 结构**：\n   - 减少组件嵌套层级（避免深层组件树增加 Diff 算法耗时）；\n   - 移除无用的 DOM 节点和组件（如空 div、隐藏的冗余组件）。\n2. **延迟渲染非关键内容**：\n   - 用 `React.lazy` + `Suspense` 懒加载非首屏组件；\n   - 用 `useTransition` 标记非紧急渲染（如列表筛选结果），优先保证用户交互响应。\n3. **避免渲染期间的昂贵操作**：\n   - 不在 render 函数、JSX 中执行复杂计算（如数组排序、数据格式化）；\n   - 不在组件挂载时同步执行大量数据处理（改为异步或分批次执行）。\n\n# 3. 降低计算开销（减少非渲染耗时）\n除渲染外，应用中的计算操作（如数据处理、事件处理）也可能导致性能问题：\n1. **缓存计算结果**：\n   - 用 `useMemo` 缓存重复计算的结果（如列表过滤、统计数据）；\n   - 用全局缓存（如 localStorage、Redux）存储高频访问的静态数据（如字典表）。\n2. **优化数据处理**：\n   - 避免在循环中执行 DOM 操作、API 请求；\n   - 对大数据集采用分批次处理（如分页加载、虚拟列表）。\n3. **使用高效的算法和数据结构**：\n   - 用 Map/Set 替代数组进行查找操作（时间复杂度从 O(n) 降至 O(1)）；\n   - 对列表排序使用稳定的排序算法（如快速排序），避免重复排序。\n\n# 4. 性能优化的优先级\n性能优化需遵循“先瓶颈后细节”的原则，优先级从高到低：\n1. **首屏加载优化**：\n   - 代码分割（路由级/组件级）、懒加载；\n   - 静态资源压缩（JS/CSS/图片）、CDN 加速；\n   - 服务端渲染（SSR）/静态站点生成（SSG）（针对 SEO 敏感、首屏耗时高的应用）。\n2. **交互响应优化**：\n   - 减少重渲染、优化渲染过程；\n   - 用 `useTransition` 处理非紧急更新，避免阻塞用户输入。\n3. **长尾优化**：\n   - 优化大数据集处理、复杂计算；\n   - 修复内存泄漏（如未清除的定时器、事件监听）。","directory_id":"e9432055-c489-48b5-964a-81d34278fc72","is_published":true,"created_at":"2025-12-22 03:15:29.624469+00","updated_at":"2025-12-23 09:41:01.887886+00"},{"id":"32ad2319-a792-4713-bb15-7bc3201cefe6","title":"自定义组件封装","content":"# 1. 组件封装核心原则\n1. **单一职责**：一个组件只负责一个功能（如按钮组件不处理表单逻辑）；\n2. **可复用性**：通过 Props 暴露配置项，适配不同业务场景；\n3. **可维护性**：代码结构清晰，注释完善，逻辑解耦；\n4. **可扩展性**：支持二次封装，预留扩展接口；\n5. **类型安全**：TypeScript 定义完整的 Props 类型，避免隐式错误；\n6. **用户体验**：兼容无障碍访问（ARIA 标签）、支持键盘操作。\n\n# 2. 按钮组件封装\n## 2.1 需求分析\n- 支持基础样式（主按钮、次按钮、危险按钮、文本按钮）；\n- 支持尺寸（小、中、大）；\n- 支持加载状态、禁用状态；\n- 支持图标、自定义颜色；\n- 支持点击事件、防抖处理。\n\n## 2.2 代码实现\n```tsx\n// components/MyButton/MyButton.tsx\nimport React, { useState, useCallback } from 'react';\nimport { Spin } from 'antd'; // 复用 AntD 加载组件（或自定义）\nimport { LoadingOutlined } from '@ant-design/icons';\nimport './MyButton.less';\n\n// 定义 Props 类型\nexport interface MyButtonProps {\n  /** 按钮类型 */\n  type?: 'primary' | 'secondary' | 'danger' | 'text';\n  /** 按钮尺寸 */\n  size?: 'small' | 'middle' | 'large';\n  /** 按钮文本 */\n  children: React.ReactNode;\n  /** 点击事件 */\n  onClick?: (e: React.MouseEvent<HTMLButtonElement>) => void;\n  /** 是否禁用 */\n  disabled?: boolean;\n  /** 是否加载中 */\n  loading?: boolean;\n  /** 防抖时间（ms） */\n  debounceTime?: number;\n  /** 自定义类名 */\n  className?: string;\n  /** 自定义样式 */\n  style?: React.CSSProperties;\n  /** 图标（前置） */\n  prefixIcon?: React.ReactNode;\n  /** 图标（后置） */\n  suffixIcon?: React.ReactNode;\n}\n\nconst MyButton: React.FC<MyButtonProps> = ({\n  type = 'primary',\n  size = 'middle',\n  children,\n  onClick,\n  disabled = false,\n  loading = false,\n  debounceTime = 0,\n  className = '',\n  style,\n  prefixIcon,\n  suffixIcon,\n}) => {\n  // 防抖逻辑\n  const [isClicking, setIsClicking] = useState(false);\n  const debouncedClick = useCallback(\n    (e: React.MouseEvent<HTMLButtonElement>) => {\n      if (disabled || loading || isClicking) return;\n      if (debounceTime > 0) {\n        setIsClicking(true);\n        setTimeout(() => {\n          onClick?.(e);\n          setIsClicking(false);\n        }, debounceTime);\n      } else {\n        onClick?.(e);\n      }\n    },\n    [onClick, disabled, loading, debounceTime, isClicking]\n  );\n\n  // 拼接类名\n  const baseClassName = `my-button my-button--${type} my-button--${size}`;\n  const finalClassName = [baseClassName, className].filter(Boolean).join(' ');\n\n  return (\n    <button\n      className={finalClassName}\n      style={style}\n      onClick={debouncedClick}\n      disabled={disabled || loading}\n      aria-disabled={disabled || loading}\n      aria-label={children as string}\n    >\n      <span className=\"my-button__content\">\n        {loading && <Spin indicator={<LoadingOutlined />} size=\"small\" className=\"my-button__loading\" />}\n        {prefixIcon && <span className=\"my-button__prefix-icon\">{prefixIcon}</span>}\n        {!loading && <span className=\"my-button__text\">{children}</span>}\n        {suffixIcon && <span className=\"my-button__suffix-icon\">{suffixIcon}</span>}\n      </span>\n    </button>\n  );\n};\n\nexport default MyButton;\n```\n\n```less\n// components/MyButton/MyButton.less\n.my-button {\n  display: inline-flex;\n  align-items: center;\n  justify-content: center;\n  gap: 4px;\n  border: none;\n  border-radius: 4px;\n  cursor: pointer;\n  transition: all 0.2s ease;\n  font-size: 14px;\n  font-weight: 500;\n  padding: 0 16px;\n  box-sizing: border-box;\n\n  &--small {\n    height: 32px;\n    font-size: 12px;\n  }\n\n  &--middle {\n    height: 40px;\n  }\n\n  &--large {\n    height: 48px;\n    font-size: 16px;\n    padding: 0 20px;\n  }\n\n  &--primary {\n    background-color: #1890ff;\n    color: #fff;\n\n    &:hover:not(:disabled) {\n      background-color: #40a9ff;\n    }\n\n    &:active:not(:disabled) {\n      background-color: #096dd9;\n    }\n  }\n\n  &--secondary {\n    background-color: #f5f5f5;\n    color: #333;\n    border: 1px solid #d9d9d9;\n\n    &:hover:not(:disabled) {\n      background-color: #e6e6e6;\n    }\n  }\n\n  &--danger {\n    background-color: #ff4d4f;\n    color: #fff;\n\n    &:hover:not(:disabled) {\n      background-color: #ff7875;\n    }\n  }\n\n  &--text {\n    background-color: transparent;\n    color: #1890ff;\n    padding: 0 8px;\n\n    &:hover:not(:disabled) {\n      background-color: #f0f7ff;\n    }\n  }\n\n  &:disabled {\n    opacity: 0.6;\n    cursor: not-allowed;\n  }\n\n  &__content {\n    display: flex;\n    align-items: center;\n    justify-content: center;\n    gap: 4px;\n  }\n\n  &__loading {\n    margin-right: 4px;\n  }\n\n  &__prefix-icon,\n  &__suffix-icon {\n    display: flex;\n    align-items: center;\n  }\n}\n```\n\n## 2.3 使用示例\n```tsx\nimport MyButton from './components/MyButton/MyButton';\nimport { SearchOutlined } from '@ant-design/icons';\n\nconst App = () => {\n  const handleClick = () => {\n    console.log('按钮点击');\n  };\n\n  return (\n    <div style={{ padding: 20, gap: 16, display: 'flex' }}>\n      <MyButton type=\"primary\" onClick={handleClick}>\n        主按钮\n      </MyButton>\n      <MyButton type=\"danger\" loading>\n        危险按钮（加载中）\n      </MyButton>\n      <MyButton type=\"text\" prefixIcon={<SearchOutlined />} debounceTime={500}>\n        文本按钮（防抖）\n      </MyButton>\n      <MyButton type=\"secondary\" size=\"large\" disabled>\n        大尺寸禁用按钮\n      </MyButton>\n    </div>\n  );\n};\n```\n\n# 3. 表单组件封装\n## 3.1 需求分析\n- 基于 AntD Form 二次封装，简化表单配置；\n- 支持表单项配置化（通过数组定义表单项）；\n- 支持表单验证、提交、重置；\n- 支持自定义表单项、布局调整。\n\n## 3.2 代码实现\n```tsx\n// components/MyForm/MyForm.tsx\nimport React from 'react';\nimport { Form, Input, Select, InputNumber, Checkbox, FormProps as AntdFormProps } from 'antd';\nimport MyButton from '../MyButton/MyButton';\nimport './MyForm.less';\n\n// 定义表单项类型\nexport type FormItemType = 'input' | 'select' | 'inputNumber' | 'checkbox' | 'custom';\n\nexport interface FormItemConfig {\n  /** 表单项字段名 */\n  name: string;\n  /** 表单项类型 */\n  type: FormItemType;\n  /** 表单项标签 */\n  label: string;\n  /** 表单项占位符 */\n  placeholder?: string;\n  /** 表单项规则 */\n  rules?: AntdFormProps['rules'][number][];\n  /** 下拉选项（select 类型） */\n  options?: { label: string; value: string | number }[];\n  /** 自定义组件（custom 类型） */\n  customComponent?: React.ReactNode;\n  /** 表单项属性（透传到底层组件） */\n  props?: Record<string, any>;\n  /** 表单项占宽（栅格数） */\n  span?: number;\n}\n\nexport interface MyFormProps {\n  /** 表单项配置 */\n  items: FormItemConfig[];\n  /** 表单初始值 */\n  initialValues?: AntdFormProps['initialValues'];\n  /** 表单提交事件 */\n  onFinish: AntdFormProps['onFinish'];\n  /** 表单提交失败事件 */\n  onFinishFailed?: AntdFormProps['onFinishFailed'];\n  /** 表单布局（水平/垂直） */\n  layout?: 'horizontal' | 'vertical';\n  /** 提交按钮文本 */\n  submitText?: string;\n  /** 是否显示重置按钮 */\n  showReset?: boolean;\n  /** 自定义样式 */\n  style?: React.CSSProperties;\n  /** 自定义类名 */\n  className?: string;\n}\n\nconst MyForm: React.FC<MyFormProps> = ({\n  items,\n  initialValues,\n  onFinish,\n  onFinishFailed,\n  layout = 'horizontal',\n  submitText = '提交',\n  showReset = true,\n  style,\n  className,\n}) => {\n  const [form] = Form.useForm();\n\n  // 渲染表单项\n  const renderFormItem = (item: FormItemConfig) => {\n    const { name, type, label, placeholder, options, customComponent, props, span = 24 } = item;\n\n    const formItemProps = {\n      name,\n      label,\n      rules: item.rules,\n      className: `my-form-item my-form-item--${span}`,\n    };\n\n    switch (type) {\n      case 'input':\n        return (\n          <Form.Item {...formItemProps}>\n            <Input placeholder={placeholder} {...props} />\n          </Form.Item>\n        );\n      case 'select':\n        return (\n          <Form.Item {...formItemProps}>\n            <Select placeholder={placeholder} options={options} {...props} />\n          </Form.Item>\n        );\n      case 'inputNumber':\n        return (\n          <Form.Item {...formItemProps}>\n            <InputNumber placeholder={placeholder} {...props} />\n          </Form.Item>\n        );\n      case 'checkbox':\n        return (\n          <Form.Item {...formItemProps} valuePropName=\"checked\">\n            <Checkbox {...props}>{label}</Checkbox>\n          </Form.Item>\n        );\n      case 'custom':\n        return <Form.Item {...formItemProps}>{customComponent}</Form.Item>;\n      default:\n        return null;\n    }\n  };\n\n  // 重置表单\n  const handleReset = () => {\n    form.resetFields();\n  };\n\n  return (\n    <Form\n      form={form}\n      layout={layout}\n      initialValues={initialValues}\n      onFinish={onFinish}\n      onFinishFailed={onFinishFailed}\n      className={`my-form ${className || ''}`}\n      style={style}\n    >\n      <div className=\"my-form__items\">\n        {items.map((item, index) => (\n          <React.Fragment key={`${item.name}-${index}`}>{renderFormItem(item)}</React.Fragment>\n        ))}\n      </div>\n      <div className=\"my-form__actions\">\n        <MyButton type=\"primary\" htmlType=\"submit\">\n          {submitText}\n        </MyButton>\n        {showReset && (\n          <MyButton type=\"secondary\" onClick={handleReset} style={{ marginLeft: 8 }}>\n            重置\n          </MyButton>\n        )}\n      </div>\n    </Form>\n  );\n};\n\nexport default MyForm;\n```\n\n```less\n// components/MyForm/MyForm.less\n.my-form {\n  width: 100%;\n  box-sizing: border-box;\n\n  &__items {\n    margin-bottom: 24px;\n  }\n\n  &-item {\n    margin-bottom: 16px;\n\n    &--8 {\n      width: 33.333%;\n      display: inline-block;\n      margin-right: 16px;\n    }\n\n    &--12 {\n      width: 50%;\n      display: inline-block;\n      margin-right: 16px;\n    }\n\n    &--24 {\n      width: 100%;\n      display: block;\n    }\n  }\n\n  &__actions {\n    margin-top: 16px;\n    display: flex;\n    align-items: center;\n  }\n}\n```\n\n## 3.3 使用示例\n```tsx\nimport MyForm from './components/MyForm/MyForm';\nimport { Input } from 'antd';\n\nconst App = () => {\n  // 表单项配置\n  const formItems = [\n    {\n      name: 'username',\n      type: 'input',\n      label: '用户名',\n      placeholder: '请输入用户名',\n      rules: [{ required: true, message: '请输入用户名' }],\n      span: 12,\n    },\n    {\n      name: 'password',\n      type: 'input',\n      label: '密码',\n      placeholder: '请输入密码',\n      rules: [{ required: true, message: '请输入密码' }],\n      props: { type: 'password' },\n      span: 12,\n    },\n    {\n      name: 'age',\n      type: 'inputNumber',\n      label: '年龄',\n      placeholder: '请输入年龄',\n      rules: [{ type: 'number', min: 0, max: 150, message: '年龄需在 0-150 之间' }],\n      span: 8,\n    },\n    {\n      name: 'gender',\n      type: 'select',\n      label: '性别',\n      placeholder: '请选择性别',\n      options: [\n        { label: '男', value: 'male' },\n        { label: '女', value: 'female' },\n      ],\n      span: 8,\n    },\n    {\n      name: 'agree',\n      type: 'checkbox',\n      label: '同意用户协议',\n      rules: [{ required: true, message: '请同意用户协议' }],\n    },\n    {\n      name: 'custom',\n      type: 'cus...","directory_id":"7fccb039-1e39-4894-ba93-5568169fef6e","is_published":true,"created_at":"2025-12-22 03:21:26.646609+00","updated_at":"2025-12-23 14:14:50.685922+00"},{"id":"35c6fe2d-a642-46cd-99b0-8d048a40e792","title":"跨层级传参——useContext","content":"当组件层级较深（如爷爷组件 → 父组件 → 子组件 → 孙组件），若通过 `props` 逐层传递数据，会产生“props 透传”问题（中间组件无需使用该数据，却必须中转传递），代码冗余且维护成本高。React 提供 **Context 上下文** 解决跨层级传参问题，允许数据直接在组件树中“穿透”传递，无需逐层手动传递。\n\n# 1. Context 核心概念\nContext 本质是一个“数据容器”，可以存储需要共享的数据（如用户信息、主题配置、权限状态），并允许组件树中的任意子组件（无论层级多深）直接访问该数据，无需通过 props 透传。\n\n## 1.1 关键 API\n- `React.createContext(defaultValue)`：创建一个 Context 对象，`defaultValue` 是默认值（仅当子组件没有匹配的 Provider 时生效）。\n- `Context.Provider`：提供数据的“生产者”组件，通过 `value` 属性传递数据，包裹需要共享数据的组件树。\n- `useContext(Context)`：函数组件中获取 Context 数据的 Hook（React 16.8+），替代老版本的 `Context.Consumer`。\n- `Context.Consumer`：类组件或函数组件中获取 Context 数据的组件形式（兼容老写法）。\n\n# 2. Context 基本使用流程（函数组件 + useContext）\n## 2.1 步骤 1：创建 Context 对象\n单独创建一个 Context 文件（如 `ThemeContext.js`），集中管理 Context 相关逻辑，便于复用和维护：\n```jsx\n// ThemeContext.js\nimport { createContext } from 'react';\n\n// 创建 Context，默认值为 { theme: 'light', toggleTheme: () => {} }\nconst ThemeContext = createContext({\n  theme: 'light',\n  toggleTheme: () => {}\n});\n\nexport default ThemeContext;\n```\n\n## 2.2 步骤 2：使用 Provider 提供数据\n在组件树的**顶层组件**（如 App 组件、爷爷组件）中，使用 `Context.Provider` 包裹子组件，并通过 `value` 属性传递需要共享的数据（可包含状态和方法）：\n```jsx\n// 顶层组件 App.jsx\nimport { useState } from 'react';\nimport ThemeContext from './ThemeContext';\nimport Parent from './Parent'; // 中间组件（无需透传数据）\n\nfunction App() {\n  // 共享的状态和方法\n  const [theme, setTheme] = useState('light'); // 主题状态（light/dark）\n  const toggleTheme = () => {\n    setTheme(prev => prev === 'light' ? 'dark' : 'light');\n  };\n\n  return (\n    // Provider 包裹需要共享数据的组件树\n    <ThemeContext.Provider value={{ theme, toggleTheme }}>\n      <h1>当前主题：{theme}</h1>\n      <Parent /> {/* 中间组件，无需传递 theme 和 toggleTheme */}\n    </ThemeContext.Provider>\n  );\n}\n```\n\n## 2.3 步骤 3：子组件获取 Context 数据\n无论子组件层级多深（如 Parent → Child → GrandChild），都可通过 `useContext` Hook 直接获取 Context 中的数据，无需通过 props 中转：\n```jsx\n// 中间组件 Parent.jsx（无需使用共享数据，仅作为容器）\nimport Child from './Child';\n\nfunction Parent() {\n  // 无需接收和传递 theme 相关数据，直接渲染子组件\n  return (\n    <div>\n      <h2>父组件（中间层）</h2>\n      <Child />\n    </div>\n  );\n}\n\n// 子组件 Child.jsx（可直接获取 Context 数据）\nimport GrandChild from './GrandChild';\n\nfunction Child() {\n  return (\n    <div>\n      <h3>子组件（中间层）</h3>\n      <GrandChild />\n    </div>\n  );\n}\n\n// 孙组件 GrandChild.jsx（跨层级获取数据）\nimport { useContext } from 'react';\nimport ThemeContext from './ThemeContext';\n\nfunction GrandChild() {\n  // 通过 useContext 直接获取 Context 中的数据\n  const { theme, toggleTheme } = useContext(ThemeContext);\n\n  return (\n    <div style={{ background: theme === 'light' ? '#fff' : '#333', color: theme === 'light' ? '#333' : '#fff' }}>\n      <h4>孙组件（层级最深）</h4>\n      <p>当前主题：{theme}</p>\n      <button onClick={toggleTheme}>切换主题</button>\n    </div>\n  );\n}\n```\n\n# 3. 类组件中使用 Context\n类组件无法使用 `useContext` Hook，需通过 `Context.Consumer` 组件或 `static contextType` 属性获取 Context 数据。\n\n## 方式 1：Context.Consumer 组件（推荐，支持多个 Context）\n`Consumer` 组件的 `children` 是一个函数，接收 Context 的 `value` 作为参数，返回 JSX 结构：\n```jsx\n// 类组件中使用 Context.Consumer\nimport ThemeContext from './ThemeContext';\nimport React from 'react';\n\nclass ClassChild extends React.Component {\n  render() {\n    return (\n      <ThemeContext.Consumer>\n        {/* 函数参数为 Context 的 value */}\n        {({ theme, toggleTheme }) => (\n          <div style={{ background: theme === 'light' ? '#fff' : '#333' }}>\n            <p>类组件 - 当前主题：{theme}</p>\n            <button onClick={toggleTheme}>切换主题</button>\n          </div>\n        )}\n      </ThemeContext.Consumer>\n    );\n  }\n}\n```\n\n## 方式 2：static contextType 属性（仅支持单个 Context）\n通过类的静态属性 `contextType` 关联 Context，然后通过 `this.context` 获取数据：\n```jsx\nimport ThemeContext from './ThemeContext';\nimport React from 'react';\n\nclass ClassChild extends React.Component {\n  // 关联 Context\n  static contextType = ThemeContext;\n\n  render() {\n    // 通过 this.context 获取数据\n    const { theme, toggleTheme } = this.context;\n    return (\n      <div>\n        <p>类组件 - 当前主题：{theme}</p>\n        <button onClick={toggleTheme}>切换主题</button>\n      </div>\n    );\n  }\n}\n```\n\n# 4. 多个 Context 联合使用\n实际开发中可能需要共享多种类型的数据（如主题、用户信息），可创建多个 Context 并嵌套使用 `Provider`，子组件通过 `useContext` 分别获取：\n```jsx\n// 1. 创建两个独立的 Context\nconst ThemeContext = createContext('light');\nconst UserContext = createContext({ name: '匿名用户' });\n\n// 2. 顶层组件嵌套 Provider\nfunction App() {\n  const user = { name: 'React 开发者', role: 'admin' };\n  return (\n    <UserContext.Provider value={user}>\n      <ThemeContext.Provider value=\"dark\">\n        <Parent />\n      </ThemeContext.Provider>\n    </UserContext.Provider>\n  );\n}\n\n// 3. 子组件分别获取多个 Context\nfunction GrandChild() {\n  const user = useContext(UserContext);\n  const theme = useContext(ThemeContext);\n\n  return (\n    <div>\n      <p>用户名：{user.name}</p>\n      <p>主题：{theme}</p>\n    </div>\n  );\n}\n```\n\n# 5. Context 注意事项\n## 5.1 避免过度使用 Context\nContext 适用于**全局共享数据**（如主题、用户信息、权限配置），若仅用于少数组件的局部通信，优先使用 props 或回调函数，避免 Context 滥用导致组件耦合度升高。\n\n## 5.2 Provider 的 value 变化触发重新渲染\n当 `Context.Provider` 的 `value` 属性变化时（引用变化，如对象、数组重新创建），所有消费该 Context 的子组件都会重新渲染。优化方案：\n- 用 `useState` 或 `useReducer` 管理 `value` 中的状态（保证状态更新时引用变化）。\n- 若 `value` 是对象，避免直接在 `Provider` 中创建新对象（导致每次渲染都触发子组件更新），可通过 `useMemo` 缓存：\n```jsx\n// 优化：用 useMemo 缓存 value 对象，仅当依赖变化时更新\nconst value = useMemo(() => ({\n  theme,\n  toggleTheme\n}), [theme]); // 仅 theme 变化时，value 引用才变化\n\nreturn <ThemeContext.Provider value={value}>{/* 子组件 */}</ThemeContext.Provider>;\n```\n\n## 5.3 defaultValue 的生效条件\n`createContext(defaultValue)` 中的默认值，仅当子组件**没有找到匹配的 Provider** 时才会生效，若存在 Provider，即使 Provider 的 `value` 为 `undefined`，也不会使用默认值：\n```jsx\nconst ThemeContext = createContext('light');\n\n// 场景 1：没有 Provider，使用默认值 'light'\nfunction NoProviderChild() {\n  const theme = useContext(ThemeContext);\n  console.log(theme); // 'light'\n}\n\n// 场景 2：有 Provider 但 value 为 undefined，不使用默认值\nfunction HasProviderChild() {\n  return (\n    <ThemeContext.Provider value={undefined}>\n      <Child /> {/* 子组件获取到的 theme 是 undefined */}\n    </ThemeContext.Provider>\n  );\n}\n```\n\n## 5.4 Context 与性能优化\n若消费 Context 的子组件是纯组件（如 `React.memo` 包装的函数组件、`PureComponent` 类组件），当 `value` 变化时仍会重新渲染（因为 `value` 是对象/数组时引用变化）。若需进一步优化，可将 Context 拆分为多个独立的 Context，让组件只消费需要的数据，减少不必要的渲染。\n\n# 6. 核心总结\n1. **核心作用**：解决跨层级组件传参问题，避免 props 透传。\n2. **核心 API**：`createContext`（创建 Context）、`Context.Provider`（提供数据）、`useContext`（函数组件获取数据）。\n3. **使用流程**：创建 Context → 顶层组件用 Provider 提供数据 → 深层子组件用 useContext 消费数据。\n4. **注意事项**：避免过度使用、缓存 Provider 的 value 避免不必要渲染、默认值仅在无 Provider 时生效。\n5. **适用场景**：全局共享数据（主题、用户信息、权限）、多层级组件通信。","directory_id":"803ada09-ee46-463c-b7f3-403560bfc20b","is_published":true,"created_at":"2025-12-19 11:05:48.570434+00","updated_at":"2025-12-19 11:05:48.570434+00"},{"id":"3d5fbcf7-8bd8-4214-a318-2492f7b7db49","title":"Redux 核心概念","content":"Redux 是一款专为 JavaScript 应用设计的**状态管理库**，核心目标是实现应用状态的集中式管理，保证状态变化可预测、可追踪。其核心设计围绕四个关键概念展开：\n\n# 1. Store（状态容器）\nStore 是 Redux 应用的“心脏”，是**唯一的全局状态容器**，负责存储整个应用的所有共享状态（state）。一个 Redux 应用只能有一个根 Store，避免状态分散导致的管理混乱。\n\n## 1.1 核心特性\n- 存储完整的应用状态树（state tree）；\n- 提供 `getState()` 方法获取当前状态；\n- 提供 `dispatch(action)` 方法触发状态更新；\n- 提供 `subscribe(listener)` 方法监听状态变化；\n- 状态只能通过 Redux 规定的流程修改，无法直接修改（单向数据流核心）。\n\n## 1.2 简单示例（创建 Store）\n```javascript\nimport { createStore } from 'redux';\nimport rootReducer from './reducers';\n\n// 创建 Store，传入根 Reducer\nconst store = createStore(rootReducer);\n\n// 获取当前状态\nconsole.log(store.getState()); // 初始状态\n```\n\n# 2. Action（状态变更指令）\nAction 是描述“状态要如何变更”的**纯对象**，是触发状态更新的唯一方式。它必须包含 `type` 字段（字符串类型，标识动作类型），可选包含 `payload` 字段（携带状态变更所需的数据）。\n\n## 2.1 核心规则\n- Action 是普通 JavaScript 对象，不可变；\n- `type` 字段必须唯一，通常用常量定义（避免硬编码错误）；\n- 仅描述“发生了什么”，不描述“如何改变状态”（状态修改逻辑由 Reducer 负责）。\n\n## 2.2 示例\n```javascript\n// 定义 Action 类型常量\nexport const ADD_TODO = 'ADD_TODO';\nexport const DELETE_TODO = 'DELETE_TODO';\n\n// 创建 Action 创建函数（返回 Action 对象的函数，简化调用）\nexport const addTodo = (text) => ({\n  type: ADD_TODO,\n  payload: { text, id: Date.now() } // 携带待办事项文本和唯一 ID\n});\n\nexport const deleteTodo = (id) => ({\n  type: DELETE_TODO,\n  payload: { id }\n});\n```\n\n# 3. Reducer（状态修改逻辑）\nReducer 是**纯函数**，负责根据接收到的 Action，计算并返回新的状态。它接收两个参数：`state`（当前状态）和 `action`（触发的动作），返回新的状态对象（不可直接修改原状态）。\n\n## 3.1 核心规则（纯函数要求）\n- 相同输入必须返回相同输出（无随机值、无异步操作）；\n- 不修改原状态（需返回新对象，如使用扩展运算符、Object.assign）；\n- 无副作用（不调用 API、不修改 DOM、不读写本地存储）。\n\n## 3.2 示例（单个 Reducer）\n```javascript\nimport { ADD_TODO, DELETE_TODO } from './actions';\n\n// 初始状态\nconst initialState = {\n  todos: []\n};\n\n// Todo Reducer\nconst todoReducer = (state = initialState, action) => {\n  switch (action.type) {\n    case ADD_TODO:\n      // 返回新状态，不修改原 state\n      return {\n        ...state,\n        todos: [...state.todos, action.payload]\n      };\n    case DELETE_TODO:\n      return {\n        ...state,\n        todos: state.todos.filter(todo => todo.id !== action.payload.id)\n      };\n    default:\n      // 未匹配到 Action 时返回原状态\n      return state;\n  }\n};\n\nexport default todoReducer;\n```\n\n## 3.3 根 Reducer（组合多个 Reducer）\n当应用状态复杂时，可将状态按模块拆分（如 todo、user），每个模块对应一个 Reducer，再通过 `combineReducers` 组合为根 Reducer：\n```javascript\nimport { combineReducers } from 'redux';\nimport todoReducer from './todoReducer';\nimport userReducer from './userReducer';\n\n// 根 Reducer，key 对应状态树的属性名\nconst rootReducer = combineReducers({\n  todos: todoReducer,\n  user: userReducer\n});\n\nexport default rootReducer;\n```\n\n# 4. 单向数据流（核心流程）\nRedux 严格遵循**单向数据流**原则，确保状态变化可追踪、可预测，核心流程如下：\n1. **组件触发 Action**：组件通过 `store.dispatch(action)` 发送动作（如用户点击“添加待办”按钮）；\n2. **Store 调用 Reducer**：Store 接收到 Action 后，将当前状态和 Action 传入 Reducer；\n3. **Reducer 计算新状态**：Reducer 根据 Action 类型处理状态，返回新状态；\n4. **Store 更新状态**：Store 用 Reducer 返回的新状态替换旧状态；\n5. **组件感知状态变化**：订阅了 Store 的组件收到通知，重新获取状态并更新视图。\n\n## 流程图解\n`组件 → dispatch(Action) → Store → Reducer(计算新状态) → Store 更新 → 组件重新渲染`","directory_id":"a3109983-f66b-42c0-afb5-8d07e97cbc4e","is_published":true,"created_at":"2025-12-22 03:11:25.300818+00","updated_at":"2025-12-23 03:23:17.603837+00"},{"id":"3deaebda-342d-4837-a3fb-29d60b5acd37","title":"React DevTools 调试技巧","content":"# 1. React DevTools 基础介绍\nReact DevTools 是 React 官方提供的调试工具，支持 Chrome/Firefox 浏览器扩展、React Native 调试，核心功能包括：\n- 组件层级可视化：查看组件树结构、props/state 数据；\n- 性能分析：定位渲染瓶颈、不必要的重渲染；\n- 组件交互调试：修改 props/state 实时预览效果；\n- Hook 调试：追踪 useState/useEffect/useContext 等 Hook 执行过程。\n\n# 2. 安装与配置\n## 2.1 浏览器扩展安装\n- Chrome：Chrome 网上应用店搜索「React Developer Tools」安装；\n- Firefox：Firefox 附加组件商店搜索「React Developer Tools」安装；\n- 本地开发（无网络）：下载扩展包手动安装（Chrome 开发者模式加载已解压的扩展程序）。\n\n## 2.2 React Native 配置\n```bash\nnpm install --save-dev react-devtools # 安装依赖\nnpx react-devtools # 启动调试工具\nimport ReactDevTools from 'react-devtools'; # 项目中集成（可选）\nif (process.env.NODE_ENV === 'development') {\n  ReactDevTools.connect();\n}\n```\n\n# 3. 核心功能与调试技巧\n## 3.1 组件检查器（Components 面板）\n### 3.1.1 查看组件树与数据\n- 左侧面板：展示组件层级结构（函数组件显示 `ƒ ComponentName`，类组件显示 `ClassComponent`）；\n- 右侧面板：\n  - **Props**：查看组件接收的 props（包括父组件传递、默认 props）；\n  - **State & Hooks**：查看组件内部 state、useState/useReducer 存储的数据；\n  - **Context**：查看组件订阅的 Context 数据；\n  - **HOCs**：穿透高阶组件（如 `withRouter`/`connect`）查看原始组件。\n\n### 3.1.2 实时修改数据\n- 点击 props/state 数值可直接编辑（支持字符串、数字、布尔值、对象）；\n- 示例：修改 `count` 状态为 10，组件会立即重新渲染，验证边界条件逻辑。\n\n### 3.1.3 组件筛选与搜索\n- 顶部搜索框输入组件名，快速定位目标组件；\n- 右键组件选择「Show in DOM」，跳转到浏览器元素面板对应的 DOM 节点。\n\n###3.1.4  组件标签与备注\n- 右键组件选择「Add tag」，添加自定义标签（如「性能问题组件」），便于团队协作调试。\n\n## 3.2 性能分析（Profiler 面板）\n### 3.2.1 录制渲染过程\n- 点击「Record」按钮，触发组件交互（如点击按钮、输入内容），停止录制后生成性能报告；\n- 报告核心指标：\n  - **渲染时间**：组件渲染耗时（毫秒）；\n  - **渲染原因**：触发重渲染的因素（props 变化、state 变化、Context 变化）；\n  - **组件层级**：渲染链路上的所有组件。\n\n### 3.2.2 定位重渲染问题\n- 筛选「Wasted time」列（不必要的重渲染耗时），数值越高说明优化空间越大；\n- 示例：父组件更新导致子组件无意义重渲染，可通过 `React.memo`/`useMemo`/`useCallback` 优化。\n\n### 3.2.3 火焰图与排名图\n- **火焰图**：展示组件渲染顺序与耗时占比（横向越长，耗时越久）；\n- **排名图**：按渲染耗时从高到低排序组件，快速定位性能瓶颈。\n\n## 3.3 Hook 调试技巧\n### 3.3.1 useEffect 依赖追踪\n- 组件面板中展开 `useEffect` Hook，查看「Deps」依赖项列表；\n- 若依赖项频繁变化（如每次渲染生成新对象），会导致 useEffect 重复执行，可通过 `useMemo` 缓存依赖项。\n\n### 3.3.2 useContext 订阅追踪\n- 查看组件订阅的 Context 数据，确认是否因 Context 频繁更新导致组件重渲染；\n- 优化方案：拆分 Context，避免无关数据共享。\n\n### 3.3.3 自定义 Hook 调试\n- 自定义 Hook 内部的 state/hooks 会显示在组件的「State & Hooks」面板中，命名建议前缀为 `use`（如 `useUser`），便于识别。\n\n## 3.4 高级调试技巧\n### 3.4.1 禁用 React 缓存（Strict Mode）\n- 开启 React 严格模式（`<React.StrictMode>`），DevTools 会强制组件重复渲染（模拟挂载/卸载），暴露潜在的副作用问题（如未清理的定时器）。\n\n### 3.4.2 组件快照对比\n- 右键组件选择「Take snapshot」，修改数据后再次快照，对比两次快照的 props/state 差异，定位数据变化原因。\n\n### 3.4.3 性能警告排查\n- 控制台中关注 React DevTools 输出的警告（如「Missing key prop」「Invalid hook call」），及时修复避免隐藏问题。\n\n# 4. 常见问题解决\n## 4.1 DevTools 不显示组件树\n- 确认项目使用 React 16.8+ 版本；\n- 检查是否开启生产环境构建（`process.env.NODE_ENV === 'production'` 会隐藏 DevTools）；\n- 确保页面中只有一个 React 版本（多版本冲突会导致 DevTools 失效）。\n\n## 4.2 Profiler 无数据\n- 确认组件使用 React 16.9+ 版本；\n- 检查是否在严格模式下录制（部分旧版本 React 存在兼容性问题）；\n- 确保录制过程中触发了组件渲染（如点击按钮修改 state）。\n\n## 4.3 无法修改 props/state\n- 生产环境构建的项目不支持修改数据（DevTools 只读）；\n- 类组件的 state 若为不可变对象（如冻结的 Object.freeze），无法直接编辑。\n\n# 5. 最佳实践\n1. 开发环境强制开启 React 严格模式，提前暴露副作用问题；\n2. 定期使用 Profiler 分析关键页面（如首页、列表页），优化重渲染耗时；\n3. 团队协作时，通过组件标签标注调试要点，提高沟通效率；\n4. 结合浏览器「Performance」面板，分析 React 渲染与 DOM 绘制的整体性能。","directory_id":"ac88594f-879e-410b-94ce-266d80cce0f4","is_published":true,"created_at":"2025-12-22 03:21:56.975556+00","updated_at":"2025-12-23 14:28:13.515961+00"},{"id":"4222d782-422a-43de-b53b-4f3c6dc29b69","title":"React 项目目录结构解析","content":"以 Create React App（CRA）和 Vite 创建的 React 项目为例，解析核心目录和文件的作用（聚焦开发中常用文件，忽略依赖和配置细节）。\n\n# 1. Create React App（CRA）项目结构\n```\nreact-demo/\n├── node_modules/       # 项目依赖包（npm install 安装，无需修改）\n├── public/             # 静态资源目录（不会被 Webpack 打包）\n│   ├── favicon.ico     # 网站图标\n│   ├── index.html      # 入口 HTML 文件（React 渲染的根容器）\n│   └── manifest.json   # PWA 配置文件（可选， Progressive Web App）\n├── src/                # 源代码目录（核心开发目录）\n│   ├── App.css         # App 组件的样式文件\n│   ├── App.js          # 根组件（整个应用的入口组件）\n│   ├── App.test.js     # App 组件的测试文件（可选，可删除）\n│   ├── index.css       # 全局样式文件（作用于整个应用）\n│   ├── index.js        # 入口 JavaScript 文件（启动 React 应用）\n│   ├── logo.svg        # React 默认图标（可删除）\n│   └── reportWebVitals.js  # 性能监控文件（可选，可删除）\n├── .gitignore          # Git 忽略文件（指定不提交到 Git 的文件）\n├── package.json        # 项目配置文件（依赖、脚本命令等）\n├── package-lock.json   # 依赖版本锁定文件（确保依赖一致性）\n└── README.md           # 项目说明文档\n```\n\n# 2. Vite + React 项目结构\n```\nreact-vite-demo/\n├── node_modules/       # 项目依赖包（无需修改）\n├── public/             # 静态资源目录（不会被 Vite 处理，原样输出）\n│   ├── favicon.ico     # 网站图标\n│   └── robots.txt      # 搜索引擎爬虫配置（可选）\n├── src/                # 源代码目录（核心开发目录）\n│   ├── App.css         # App 组件的样式文件\n│   ├── App.jsx         # 根组件（JSX 后缀，与 JS 功能一致，推荐使用）\n│   ├── index.css       # 全局样式文件\n│   ├── main.jsx        # 入口 JavaScript 文件（启动 React 应用）\n│   └── vite-env.d.ts   # Vite 类型声明文件（TS 项目必备，JS 项目可忽略）\n├── .gitignore          # Git 忽略文件\n├── index.html          # 入口 HTML 文件（与 CRA 不同，在根目录）\n├── package.json        # 项目配置文件\n├── package-lock.json   # 依赖版本锁定文件\n├── tsconfig.json       # TypeScript 配置文件（TS 项目才有）\n└── vite.config.js      # Vite 配置文件（可自定义构建规则）\n```\n\n# 3. 核心文件详解（重点关注）\n## 3.1 入口 HTML 文件\n- CRA 中：`public/index.html`；Vite 中：`index.html`。\n- 核心作用：提供 React 渲染的根容器，代码关键部分：\n  ```html\n  React 会将组件渲染到这个 div 中 -->\n  root\"> ```\n- 注意：无需在 HTML 中引入 JS 文件，CRA/Vite 会自动注入打包后的脚本。\n\n## 3.2 入口 JS/JSX 文件\n- CRA 中：`src/index.js`；Vite 中：`src/main.jsx`。\n- 核心作用：初始化 React 应用，将根组件渲染到根容器中。\n  - CRA 示例（`index.js`）：\n    ```jsx\n    import React from 'react';\n    import ReactDOM from 'react-dom/client';  // React 18+ 渲染 API\n    import './index.css';  // 引入全局样式\n    import App from './App';  // 引入根组件\n\n    // 获取根容器，创建 React 根实例\n    const root = ReactDOM.createRoot(document.getElementById('root'));\n    // 渲染根组件 App 到根容器\n    root.render(\n      Mode>  {/* 严格模式：检测代码潜在问题，开发环境有效 */}\n              >\n    );\n    ```\n  - Vite 示例（`main.jsx`）：\n    ```jsx\n    import React from 'react';\n    import ReactDOM from 'react-dom/client';\n    import './index.css';\n    import App from './App.jsx';\n\n    ReactDOM.createRoot(document.getElementById('root')).render(\n      \n              >\n    );\n    ```\n\n## 3.3 根组件：App.js / App.jsx\n- 整个应用的顶层组件，所有页面和功能组件都嵌套在 App 组件中。\n- 示例（`App.jsx`）：\n  ```jsx\n  import './App.css';\n\n  function App() {\n    // 组件返回 JSX 语法描述 UI 结构\n    return (\n      \">\n        >Hello React!>\n        这是我的第一个 React 应用 \n  }\n\n  export default App;  // 导出组件，供入口文件引入\n  ```\n\n## 3.4 样式文件：index.css / App.css\n- `index.css`：全局样式，作用于整个应用（如重置样式、全局字体等）。\n- `App.css`：组件局部样式，仅作用于 App 组件（后续可通过 CSS Modules、Styled Components 等实现样式隔离）。\n\n## 3.5 配置文件\n- `package.json`：核心配置文件，包含项目名称、依赖包、脚本命令（如 `npm start` 对应 `react-scripts start`）。\n- `vite.config.js`（Vite 项目）：自定义 Vite 配置（如修改端口、配置代理、引入插件等）。\n\n# 4. 开发规范建议\n1. 新增组件：在 `src` 目录下创建 `components` 文件夹，按组件功能分类（如 `src/components/Button`、`src/components/Navbar`），每个组件单独创建文件夹（包含组件文件、样式文件）。\n2. 静态资源：图片、字体等资源建议放在 `src/assets` 文件夹（CRA/Vite 均支持），便于统一管理。\n3. 样式管理：小型项目可使用普通 CSS，中大型项目推荐使用 CSS Modules（样式隔离）、Tailwind CSS（原子化样式）或 Styled Components（CSS-in-JS）。\n","directory_id":"885129c3-bae4-445c-979c-09863b3895f8","is_published":true,"created_at":"2025-12-19 06:52:43.918673+00","updated_at":"2025-12-19 09:15:44.114234+00"},{"id":"43f6434a-7b32-4b2c-b70f-e6ad9edfd997","title":"非受控表单","content":"# 1. 非受控表单的核心概念\n**非受控表单**是指表单元素的值不由 React 状态控制，而是由 DOM 自身维护，组件通过 `ref` 直接访问 DOM 元素获取值。这种模式更接近原生 HTML 表单的行为，适用于简单表单场景，代码更简洁。\n\n## 核心特征\n- 表单元素的值由 DOM 自身管理，无需绑定 `state`；\n- 通过 `ref` 引用表单元素，在需要时（如提交表单）获取值；\n- 可通过 `defaultValue`/`defaultChecked` 设置默认值（仅初始化时生效）；\n- 无需 `onChange` 事件同步状态，减少代码量。\n\n# 2. 非受控表单的实现（useRef）\nReact 中通过 `useRef` Hook 创建 `ref` 对象，绑定到表单元素，再通过 `ref.current` 访问 DOM 元素及其 `value`/`checked` 属性。\n\n## 2.1 基础示例：文本输入框与密码框\n```javascript\nimport { useRef } from 'react';\n\nfunction UncontrolledBasicForm() {\n  // 创建 ref 引用表单元素\n  const usernameRef = useRef(null);\n  const passwordRef = useRef(null);\n\n  const handleSubmit = (e) => {\n    e.preventDefault(); // 阻止默认提交\n\n    // 通过 ref 获取表单值（需判断元素是否存在）\n    const username = usernameRef.current?.value || '';\n    const password = passwordRef.current?.value || '';\n\n    console.log('提交数据：', { username, password });\n\n    // 可选：提交后重置表单\n    usernameRef.current.value = '';\n    passwordRef.current.value = '';\n  };\n\n  return (\n    <form onSubmit={handleSubmit}>\n      <div>\n        <label>用户名：</label>\n        {/* ref 绑定到表单元素，defaultValue 设置默认值 */}\n        <input\n          type=\"text\"\n          ref={usernameRef}\n          defaultValue=\"\" // 仅初始化生效，后续修改需操作 DOM\n          placeholder=\"请输入用户名\"\n        />\n      </div>\n      <div>\n        <label>密码：</label>\n        <input\n          type=\"password\"\n          ref={passwordRef}\n          defaultValue=\"\"\n          placeholder=\"请输入密码\"\n        />\n      </div>\n      <button type=\"submit\">提交</button>\n    </form>\n  );\n}\n```\n\n## 2.2 单选按钮与复选框\n### 场景 1：单选按钮（defaultChecked 设置默认选中）\n```javascript\nfunction UncontrolledRadio() {\n  const genderRef = useRef(null); // 引用单选组中的第一个元素（或任意一个）\n\n  const handleSubmit = (e) => {\n    e.preventDefault();\n    // 获取选中的单选按钮值（通过 name 分组查询）\n    const selectedGender = document.querySelector('input[name=\"gender\"]:checked')?.value || '';\n    console.log('选择的性别：', selectedGender);\n  };\n\n  return (\n    <form onSubmit={handleSubmit}>\n      <div>\n        <label>性别：</label>\n        <input\n          type=\"radio\"\n          name=\"gender\"\n          value=\"male\"\n          defaultChecked // 默认选中\n          ref={genderRef}\n        />\n        <span>男</span>\n        <input\n          type=\"radio\"\n          name=\"gender\"\n          value=\"female\"\n        />\n        <span>女</span>\n      </div>\n      <button type=\"submit\">提交</button>\n    </form>\n  );\n}\n```\n\n### 场景 2：复选框（单个/多个）\n```javascript\nfunction UncontrolledCheckbox() {\n  // 单个复选框 ref\n  const agreeRef = useRef(null);\n  // 多个复选框（通过类名或 name 统一获取）\n\n  const handleSubmit = (e) => {\n    e.preventDefault();\n\n    // 单个复选框：获取 checked 属性\n    const isAgreed = agreeRef.current?.checked || false;\n\n    // 多个复选框：通过 name 查询所有选中的元素\n    const selectedHobbies = Array.from(\n      document.querySelectorAll('input[name=\"hobby\"]:checked')\n    ).map(input => input.value);\n\n    console.log('是否同意协议：', isAgreed);\n    console.log('选择的兴趣：', selectedHobbies);\n  };\n\n  return (\n    <form onSubmit={handleSubmit}>\n      <div>\n        <input\n          type=\"checkbox\"\n          id=\"agree\"\n          ref={agreeRef}\n          defaultChecked={false}\n        />\n        <label htmlFor=\"agree\">同意协议</label>\n      </div>\n      <div>\n        <label>兴趣爱好：</label>\n        <input type=\"checkbox\" name=\"hobby\" value=\"sports\" />\n        <span>运动</span>\n        <input type=\"checkbox\" name=\"hobby\" value=\"reading\" />\n        <span>阅读</span>\n        <input type=\"checkbox\" name=\"hobby\" value=\"coding\" />\n        <span>编程</span>\n      </div>\n      <button type=\"submit\">提交</button>\n    </form>\n  );\n}\n```\n\n## 2.3 下拉选择框（select）\n```javascript\nfunction UncontrolledSelect() {\n  const cityRef = useRef(null);\n\n  const handleSubmit = (e) => {\n    e.preventDefault();\n    // 获取选中值\n    const selectedCity = cityRef.current?.value || '';\n    console.log('选择的城市：', selectedCity);\n  };\n\n  return (\n    <form onSubmit={handleSubmit}>\n      <div>\n        <label>城市：</label>\n        <select ref={cityRef} defaultValue=\"beijing\">\n          <option value=\"beijing\">北京</option>\n          <option value=\"shanghai\">上海</option>\n          <option value=\"guangzhou\">广州</option>\n        </select>\n      </div>\n      <button type=\"submit\">提交</button>\n    </form>\n  );\n}\n```\n\n## 2.4 复杂非受控表单（多字段统一处理）\n通过多个 `ref` 引用不同字段，或通过 `form` 元素的 `elements` 属性批量获取字段值。\n\n```javascript\nimport { useRef } from 'react';\n\nfunction UncontrolledComplexForm() {\n  // 引用整个表单元素\n  const formRef = useRef(null);\n\n  const handleSubmit = (e) => {\n    e.preventDefault();\n    const form = formRef.current;\n\n    // 通过 form.elements 获取所有字段值（按 name 属性匹配）\n    const username = form.username.value;\n    const password = form.password.value;\n    const gender = form.gender.value;\n    const isAgreed = form.agree.checked;\n    const selectedHobbies = Array.from(form.hobby)\n      .filter(input => input.checked)\n      .map(input => input.value);\n    const city = form.city.value;\n    const intro = form.intro.value;\n\n    console.log('提交数据：', {\n      username,\n      password,\n      gender,\n      isAgreed,\n      selectedHobbies,\n      city,\n      intro\n    });\n\n    // 表单重置（原生 form 元素的 reset 方法）\n    form.reset();\n  };\n\n  return (\n    <form ref={formRef} onSubmit={handleSubmit} style={{ display: 'flex', flexDirection: 'column', gap: '10px' }}>\n      <div>\n        <label>用户名：</label>\n        <input type=\"text\" name=\"username\" defaultValue=\"\" placeholder=\"请输入用户名\" />\n      </div>\n      <div>\n        <label>密码：</label>\n        <input type=\"password\" name=\"password\" defaultValue=\"\" placeholder=\"请输入密码\" />\n      </div>\n      <div>\n        <label>性别：</label>\n        <input type=\"radio\" name=\"gender\" value=\"male\" defaultChecked /> 男\n        <input type=\"radio\" name=\"gender\" value=\"female\" /> 女\n      </div>\n      <div>\n        <input type=\"checkbox\" name=\"agree\" id=\"agree\" defaultChecked={false} />\n        <label htmlFor=\"agree\">同意协议</label>\n      </div>\n      <div>\n        <label>兴趣爱好：</label>\n        <input type=\"checkbox\" name=\"hobby\" value=\"sports\" /> 运动\n        <input type=\"checkbox\" name=\"hobby\" value=\"reading\" /> 阅读\n        <input type=\"checkbox\" name=\"hobby\" value=\"coding\" /> 编程\n      </div>\n      <div>\n        <label>城市：</label>\n        <select name=\"city\" defaultValue=\"beijing\">\n          <option value=\"beijing\">北京</option>\n          <option value=\"shanghai\">上海</option>\n        </select>\n      </div>\n      <div>\n        <label>个人简介：</label>\n        <textarea name=\"intro\" defaultValue=\"\" style={{ width: '300px', height: '100px' }} />\n      </div>\n      <button type=\"submit\">提交</button>\n    </form>\n  );\n}\n```\n\n# 3. 非受控表单的优势与适用场景\n## 3.1 优势\n- 代码简洁：无需维护 `state` 和 `onChange` 事件，减少模板代码；\n- 原生行为：更接近原生 HTML 表单，学习成本低；\n- 性能优化：避免因表单频繁变化导致的组件重渲染；\n- 批量处理：可通过 `form.elements` 批量获取字段值，简化提交逻辑。\n\n## 3.2 适用场景\n- 简单表单：如登录框、搜索框等字段较少的场景；\n- 原生交互：需要使用原生表单特性（如 `form.reset()`）的场景；\n- 性能敏感：表单字段极多，频繁重渲染会影响性能的场景；\n- 第三方集成：与非 React 表单库（如原生插件）集成的场景。\n\n# 4. 注意事项\n- 无法实时响应：若需实时验证、格式转换等功能，非受控表单需手动监听 `onChange` 事件，失去简洁性；\n- 默认值仅初始化：`defaultValue`/`defaultChecked` 仅在组件挂载时生效，后续修改需通过 DOM 操作；\n- 需处理 DOM 兼容性：直接操作 DOM 可能存在浏览器兼容性问题，需谨慎；\n- 无障碍适配：需手动设置 `name`、`id`、`label` 关联，确保无障碍访问；\n- 避免滥用：复杂表单场景（如多步骤表单、动态字段）建议使用受控表单，便于维护。\n","directory_id":"0e360aa6-df1e-4212-b06e-7ebc4541f5d5","is_published":true,"created_at":"2025-12-22 03:18:36.862956+00","updated_at":"2025-12-23 13:01:40.998356+00"},{"id":"4632631e-8b5a-4e18-a452-027fe9cf187c","title":"条件渲染与列表渲染","content":"在 React 开发中，**条件渲染**和**列表渲染**是构建动态 UI 的基础能力。条件渲染用于根据不同状态显示不同的 UI 内容，列表渲染用于批量展示结构化数据，而 `key` 属性则是列表渲染中保证性能和正确性的关键。\n\n# 1. 条件渲染\n条件渲染的核心思想是：**根据组件的 state 或 props 动态决定渲染的内容**。React 中的条件渲染和 JavaScript 中的条件判断逻辑完全一致，我们可以使用 `if-else`、三元运算符、逻辑与运算符等方式实现。\n\n## 方式1：if-else 条件判断\n适用于**复杂的多分支条件**场景，根据不同的条件返回不同的 React 元素。\n```jsx\nimport { useState } from 'react';\n\nfunction LoginStatus() {\n  const [isLogin, setIsLogin] = useState(false);\n\n  // 定义登录/未登录状态的渲染内容\n  if (isLogin) {\n    return <div>欢迎回来！<button onClick={() => setIsLogin(false)}>退出登录</button></div>;\n  } else {\n    return <div>请先登录！<button onClick={() => setIsLogin(true)}>登录</button></div>;\n  }\n}\n```\n这种方式逻辑清晰，适合条件分支较多的情况。\n\n## 方式2：三元运算符\n适用于**简单的二选一**场景，写法简洁，直接嵌入到 JSX 中。\n```jsx\nfunction LoginStatus() {\n  const [isLogin, setIsLogin] = useState(false);\n\n  return (\n    <div>\n      {isLogin ? (\n        <div>欢迎回来！<button onClick={() => setIsLogin(false)}>退出登录</button></div>\n      ) : (\n        <div>请先登录！<button onClick={() => setIsLogin(true)}>登录</button></div>\n      )}\n    </div>\n  );\n}\n```\n三元运算符可以嵌套使用，但嵌套过深会降低代码可读性，建议配合函数拆分复杂逻辑。\n\n## 方式3：逻辑与运算符（&&）\n适用于**条件为真时渲染内容，条件为假时不渲染**的场景。\n```jsx\nfunction Notification() {\n  const [hasMessage, setHasMessage] = useState(true);\n\n  return (\n    <div>\n      <h2>消息通知</h2>\n      {/* 当 hasMessage 为 true 时，渲染 <p> 标签；为 false 时，不渲染 */}\n      {hasMessage && <p>你有一条新消息！</p>}\n    </div>\n  );\n}\n```\n注意：如果左侧条件为**假值**（如 0、''、null、undefined），React 会渲染该假值，因此需要确保左侧条件是布尔值。例如，避免直接使用 `{count && <p>计数：{count}</p>}`，当 `count` 为 0 时会渲染 0，应该改为 `{count > 0 && <p>计数：{count}</p>}`。\n\n## 方式4：元素变量\n可以将 React 元素赋值给变量，根据条件修改变量的值，再渲染变量。\n```jsx\nfunction RoleView() {\n  const [role, setRole] = useState('user');\n  let content;\n\n  if (role === 'admin') {\n    content = <div>管理员：拥有所有权限</div>;\n  } else if (role === 'user') {\n    content = <div>普通用户：拥有查看权限</div>;\n  } else {\n    content = <div>游客：请登录</div>;\n  }\n\n  return (\n    <div>\n      {content}\n      <button onClick={() => setRole('admin')}>切换到管理员</button>\n    </div>\n  );\n}\n```\n\n## 条件渲染的注意事项\n1. **避免不必要的渲染**：可以通过 `React.memo` 包装组件，减少不必要的重渲染。\n2. **不要在渲染函数中使用 return 之外的条件判断**：确保所有条件分支都有明确的返回值，避免出现 `undefined`。\n3. **空渲染**：如果某个条件下不需要渲染任何内容，可以返回 `null`。\n    ```jsx\n    function EmptyComponent({ show }) {\n      if (!show) return null;\n      return <div>显示内容</div>;\n    }\n    ```\n\n# 2. 列表渲染\n当需要渲染一组相同结构的 UI 时，就需要用到列表渲染。React 中通常使用 `Array.prototype.map` 方法遍历数据数组，生成对应的 React 元素列表。\n\n## 2.1 基本用法\n`map` 方法会遍历数组中的每一项，返回一个新的 React 元素数组，然后将这个数组嵌入到 JSX 中渲染。\n```jsx\nimport { useState } from 'react';\n\nfunction FruitList() {\n  const [fruits] = useState(['苹果', '香蕉', '橙子', '葡萄']);\n\n  return (\n    <ul>\n      {fruits.map((fruit) => (\n        <li>{fruit}</li>\n      ))}\n    </ul>\n  );\n}\n```\n运行这段代码，控制台会出现一个警告：`Warning: Each child in a list should have a unique \"key\" prop`。这是因为 React 需要通过 `key` 属性来识别列表中的每一项，保证列表更新时的性能和正确性。\n\n# 3. key 的作用与原理\n## 3.1 为什么需要 key\n`key` 是 React 用于**标识列表项唯一性**的特殊属性，它的核心作用是帮助 React 的 Diff 算法快速识别列表中元素的**新增、删除、移动**操作，从而只更新变化的部分，提升渲染性能。\n\n如果不设置 `key`，React 会默认使用列表项的**索引**作为 `key`，这在列表项顺序不变的情况下可以正常工作，但当列表项顺序发生变化（如排序、删除中间项）时，会导致 React 错误地更新 DOM，引发性能问题或 UI 异常。\n\n## 3.2 key 的使用规则\n1. **唯一性**：同一个列表中的 `key` 必须是唯一的，不能重复。\n2. **稳定性**：`key` 应该是稳定不变的，不要使用随机数或索引作为 `key`（除非列表是静态的）。\n3. **与数据关联**：最好使用数据本身的唯一标识作为 `key`，如数据库中的 ID。\n\n示例：使用唯一 ID 作为 key\n```jsx\nfunction FruitList() {\n  const [fruits] = useState([\n    { id: 1, name: '苹果' },\n    { id: 2, name: '香蕉' },\n    { id: 3, name: '橙子' },\n    { id: 4, name: '葡萄' }\n  ]);\n\n  return (\n    <ul>\n      {fruits.map((fruit) => (\n        <li key={fruit.id}>{fruit.name}</li>\n      ))}\n    </ul>\n  );\n}\n```\n\n## 3.3 为什么不推荐使用索引作为 key\n当列表项的顺序发生变化时，使用索引作为 `key` 会导致 React 无法正确识别列表项的变化。\n\n示例：错误使用索引作为 key 的问题\n```jsx\nfunction TodoList() {\n  const [todos, setTodos] = useState([\n    { id: 1, text: '学习 React' },\n    { id: 2, text: '学习 Vue' }\n  ]);\n\n  // 删除第一项\n  const deleteFirst = () => {\n    setTodos(todos.slice(1));\n  };\n\n  return (\n    <div>\n      <button onClick={deleteFirst}>删除第一项</button>\n      <ul>\n        {todos.map((todo, index) => (\n          <li key={index}>{todo.text}</li>\n        ))}\n      </ul>\n    </div>\n  );\n}\n```\n初始状态下，两个列表项的 `key` 分别是 0 和 1。当删除第一项后，剩下的列表项的 `key` 变为 0，React 会认为原来的第二项变成了第一项，从而**复用原来的 DOM 节点**，这在复杂组件中可能导致状态错乱。\n\n如果使用 `todo.id` 作为 `key`，删除第一项后，剩下的列表项的 `key` 是 2，React 会正确识别到第一项被删除，直接移除对应的 DOM 节点。\n\n## 3.4 key 的原理：React Diff 算法对 key 的处理\nReact 的 Diff 算法在处理列表时，会遵循以下逻辑：\n1. **对比新旧列表的 key**：当列表更新时，React 会先对比新旧列表中具有相同 `key` 的元素。\n2. **复用相同 key 的元素**：如果新旧列表中存在相同 `key` 的元素，React 会认为这是同一个元素，只更新其属性和子元素，而不会重新创建 DOM 节点。\n3. **处理新增/删除的元素**：如果新列表中出现了旧列表没有的 `key`，React 会创建新的 DOM 节点；如果旧列表中的 `key` 在新列表中不存在，React 会删除对应的 DOM 节点。\n4. **处理元素移动**：如果元素的 `key` 不变但位置发生变化，React 会通过移动 DOM 节点来更新列表，而不是销毁和重建。\n\n# 4. 列表渲染的注意事项\n1. **key 只在列表内部有效**：`key` 是给 React 内部使用的，不会传递给组件，不能在子组件中通过 `props.key` 获取。\n2. **避免在 map 函数中定义组件**：在 `map` 函数中定义组件会导致每次渲染都创建新的组件，影响性能，应该将组件提取到外部。\n    ```jsx\n    // 推荐写法\n    const FruitItem = ({ fruit }) => <li>{fruit.name}</li>;\n\n    function FruitList() {\n      const [fruits] = useState([{ id: 1, name: '苹果' }]);\n      return (\n        <ul>\n          {fruits.map((fruit) => (\n            <FruitItem key={fruit.id} fruit={fruit} />\n          ))}\n        </ul>\n      );\n    }\n    ```\n3. **列表项的状态管理**：当列表项是受控组件时，确保每个列表项的状态独立，避免因 `key` 问题导致状态共享。\n\n# 5. 条件渲染与列表渲染的结合使用\n在实际开发中，我们经常需要结合条件渲染和列表渲染，例如：当列表为空时显示“暂无数据”，有数据时显示列表。\n```jsx\nfunction TodoList() {\n  const [todos, setTodos] = useState([]);\n\n  return (\n    <div>\n      {todos.length === 0 ? (\n        <p>暂无待办事项</p>\n      ) : (\n        <ul>\n          {todos.map((todo) => (\n            <li key={todo.id}>{todo.text}</li>\n          ))}\n        </ul>\n      )}\n    </div>\n  );\n}\n```\n","directory_id":"763e50ae-d5ad-4770-b985-cb78491214e1","is_published":true,"created_at":"2025-12-19 09:23:48.442953+00","updated_at":"2025-12-19 09:23:48.442953+00"},{"id":"482a9847-e6a4-4d3a-a1db-9ae9474249a4","title":"函数组件与类组件","content":"在 React 中，组件是构建 UI 的基本单元，根据定义方式的不同，主要分为**函数组件**和**类组件**两大类。二者在语法、特性、设计理念上存在显著差异，适用于不同的开发场景。\n\n# 1. 核心特性\n## 1.1 函数组件\n函数组件是基于 JavaScript 普通函数的 React 组件，是 React 16.8 推出 **Hooks** 之后的推荐写法。\n- **语法结构**：以函数形式定义，接收 `props` 作为参数，直接返回 JSX 结构。\n  ```jsx\n  function Greeting(props) {\n    return <h1>Hello, {props.name}</h1>;\n  }\n\n  // 箭头函数写法（更简洁）\n  const Greeting = (props) => <h1>Hello, {props.name}</h1>;\n  ```\n- **状态管理**：React 16.8 之前无内置状态管理能力，只能作为**无状态组件**使用；Hooks 推出后，可通过 `useState`、`useReducer` 实现状态管理。\n- **生命周期**：没有类组件的生命周期钩子，通过 `useEffect` 等 Hooks 处理副作用（如数据请求、DOM 操作、订阅监听）。\n- **this 指向**：不存在 `this` 关键字，无需考虑 `this` 绑定问题。\n\n## 1.2 类组件\n类组件是基于 ES6 Class 定义的 React 组件，是 Hooks 出现之前的主流写法。\n- **语法结构**：继承 `React.Component` 或 `React.PureComponent`，必须实现 `render()` 方法返回 JSX 结构。\n  ```jsx\n  class Greeting extends React.Component {\n    render() {\n      return <h1>Hello, {this.props.name}</h1>;\n    }\n  }\n  ```\n- **状态管理**：通过 `this.state` 定义组件内部状态，通过 `this.setState()` 方法更新状态（支持异步更新、批量更新）。\n- **生命周期**：拥有完整的生命周期钩子函数，如 `componentDidMount`、`componentDidUpdate`、`componentWillUnmount` 等，可在不同阶段执行逻辑。\n- **this 指向**：需要注意 `this` 绑定问题，事件处理函数通常需要通过 `bind` 或箭头函数绑定 `this`。\n\n# 2. 优缺点对比\n| 维度         | 函数组件                                  | 类组件                                      |\n|--------------|-------------------------------------------|---------------------------------------------|\n| **语法简洁性** | 代码量少，结构清晰，学习成本低            | 语法繁琐，需要继承、实现 render 方法，代码冗余 |\n| **状态管理** | 借助 Hooks 实现，逻辑分散且灵活            | 基于 state/setState，逻辑集中但写法固定      |\n| **生命周期** | 用 useEffect 统一处理副作用，逻辑更聚合    | 钩子函数多，易出现生命周期嵌套地狱            |\n| **性能优化** | 需手动使用 React.memo 优化，避免重复渲染   | 可继承 PureComponent 或实现 shouldComponentUpdate 进行浅比较优化 |\n| **this 问题** | 无 this，彻底规避 this 绑定陷阱            | 存在 this 指向问题，需额外处理              |\n| **逻辑复用** | 基于自定义 Hooks，复用逻辑更简洁、无嵌套   | 基于高阶组件（HOC）/Render Props，易产生嵌套地狱 |\n\n# 3. 使用场景\n## 3.1 函数组件（推荐优先使用）\n1. **简单 UI 组件**：如按钮、标签、卡片等无状态或状态简单的组件，代码简洁易维护。\n2. **复杂逻辑组件**：通过 Hooks 拆分和复用复杂业务逻辑（如数据请求、表单处理、状态管理），让组件逻辑更清晰。\n3. **React 新版本项目**：React 官方推荐写法，后续生态（如 React Server Components）会更倾向于函数组件。\n\n## 3.2 类组件（逐步淘汰，兼容老项目）\n1. **老项目维护**：早期 React 项目大量使用类组件，维护时需要兼容原有代码。\n2. **复杂生命周期场景**：在 Hooks 出现之前，类组件的生命周期钩子能更精细地控制组件不同阶段的行为（现在可通过 useEffect 替代）。\n3. **团队技术栈兼容**：部分团队尚未完全迁移到 Hooks，仍需使用类组件开发。","directory_id":"16d6f496-f7f3-422b-baf9-c5f027a71aaa","is_published":true,"created_at":"2025-12-19 09:39:37.572904+00","updated_at":"2025-12-19 09:39:37.572904+00"},{"id":"4d4cc26c-6ce0-4786-bc94-13fa3d342045","title":"useReducer：复杂状态逻辑","content":"`useReducer` 是 React 中用于管理**复杂状态逻辑**的 Hook，是 `useState` 的替代方案。当组件状态包含多个子值、状态更新逻辑复杂（如依赖多个前置状态）或需要集中管理状态变化时，`useReducer` 比 `useState` 更优雅、更易维护。其设计灵感来源于 Redux，核心思想是“状态与操作分离”，通过纯函数（reducer）处理状态更新逻辑。\n\n# 1. useReducer 核心概念与工作原理\n## 1.1 核心概念\n- **state**：组件的状态对象（与 `useState` 的 state 一致）。\n- **action**：描述状态变化的“指令”，通常是包含 `type` 字段的对象（如 `{ type: 'INCREMENT' }`），可携带额外数据（`payload`）。\n- **reducer**：纯函数，接收当前 `state` 和 `action`，返回新的 `state`（核心逻辑：根据 action 类型更新 state）。\n- **dispatch**：分发 action 的函数，调用 `dispatch(action)` 会触发 reducer 执行，更新 state 并重新渲染组件。\n\n## 1.2 工作流程\n1. 组件初始化时，`useReducer` 执行 reducer 并传入初始 state（或通过 `init` 函数生成初始 state）。\n2. 组件中调用 `dispatch(action)`，传递状态更新指令。\n3. React 调用 reducer 函数，传入当前 state 和 action，计算新的 state。\n4. React 用新的 state 重新渲染组件，并更新 UI。\n\n## 1.3 基本语法\n```jsx\nimport { useReducer } from 'react';\n\n// 1. 定义 reducer 纯函数\nfunction reducer(state, action) {\n  switch (action.type) {\n    case 'INCREMENT':\n      return { ...state, count: state.count + 1 };\n    case 'DECREMENT':\n      return { ...state, count: state.count - 1 };\n    case 'RESET':\n      return { ...state, count: action.payload };\n    default:\n      throw new Error(`未知 action 类型：${action.type}`);\n  }\n}\n\nfunction Counter() {\n  // 2. 初始化 useReducer：reducer 函数 + 初始 state\n  const [state, dispatch] = useReducer(reducer, { count: 0 });\n\n  return (\n    <div>\n      <p>计数：{state.count}</p>\n      {/* 3. 分发 action，触发状态更新 */}\n      <button onClick={() => dispatch({ type: 'INCREMENT' })}>+1</button>\n      <button onClick={() => dispatch({ type: 'DECREMENT' })}>-1</button>\n      <button onClick={() => dispatch({ type: 'RESET', payload: 0 })}>重置</button>\n    </div>\n  );\n}\n```\n\n# 2. useReducer 与 useState 的对比\n## 2.1 适用场景对比\n| 场景                     | 推荐使用        | 原因                                   |\n|--------------------------|-----------------|----------------------------------------|\n| 简单状态（单个值）| useState        | 语法简洁，无需额外定义 reducer          |\n| 复杂状态（多个子值）| useReducer      | 集中管理状态更新逻辑，代码更清晰        |\n| 状态更新依赖前置状态     | useReducer      | reducer 接收当前 state，避免批量更新问题 |\n| 组件内状态逻辑复用       | useReducer      | reducer 可抽离为独立函数，便于复用      |\n| 状态更新需要追踪（调试）| useReducer      | action 类型明确，便于定位状态变化原因   |\n\n## 2.2 代码复杂度对比\n### 示例：用 useState 管理复杂状态（待办事项）\n```jsx\n// 状态分散，更新逻辑零散，维护成本高\nfunction TodoList() {\n  const [todos, setTodos] = useState([]);\n  const [inputValue, setInputValue] = useState('');\n\n  const addTodo = () => {\n    setTodos(prev => [...prev, { id: Date.now(), text: inputValue, done: false }]);\n    setInputValue('');\n  };\n\n  const toggleTodo = (id) => {\n    setTodos(prev => prev.map(todo => \n      todo.id === id ? { ...todo, done: !todo.done } : todo\n    ));\n  };\n\n  const deleteTodo = (id) => {\n    setTodos(prev => prev.filter(todo => todo.id !== id));\n  };\n\n  // ... 更多更新逻辑\n}\n```\n\n### 示例：用 useReducer 管理复杂状态（待办事项）\n```jsx\n// 1. 抽离 reducer，集中管理所有状态更新逻辑\nfunction todoReducer(state, action) {\n  switch (action.type) {\n    case 'ADD_TODO':\n      return [...state, { id: Date.now(), text: action.payload, done: false }];\n    case 'TOGGLE_TODO':\n      return state.map(todo => \n        todo.id === action.payload ? { ...todo, done: !todo.done } : todo\n      );\n    case 'DELETE_TODO':\n      return state.filter(todo => todo.id !== action.payload);\n    default:\n      return state;\n  }\n}\n\nfunction TodoList() {\n  const [todos, dispatch] = useReducer(todoReducer, []);\n  const [inputValue, setInputValue] = useState('');\n\n  const addTodo = () => {\n    dispatch({ type: 'ADD_TODO', payload: inputValue });\n    setInputValue('');\n  };\n\n  return (\n    <div>\n      <input value={inputValue} onChange={(e) => setInputValue(e.target.value)} />\n      <button onClick={addTodo}>添加</button>\n      <ul>\n        {todos.map(todo => (\n          <li key={todo.id}>\n            <span style={{ textDecoration: todo.done ? 'line-through' : 'none' }}>\n              {todo.text}\n            </span>\n            <button onClick={() => dispatch({ type: 'TOGGLE_TODO', payload: todo.id })}>\n              切换\n            </button>\n            <button onClick={() => dispatch({ type: 'DELETE_TODO', payload: todo.id })}>\n              删除\n            </button>\n          </li>\n        ))}\n      </ul>\n    </div>\n  );\n}\n```\n\n# 3. 高级用法：初始化 state 与懒加载\n## 3.1 直接初始化 state\n最基础的方式：将初始 state 作为 `useReducer` 的第二个参数：\n```jsx\nconst [state, dispatch] = useReducer(reducer, { count: 0 });\n```\n\n## 3.2 懒加载初始化 state\n若初始 state 需要复杂计算（如从本地存储读取、根据 props 生成），可传递一个**初始化函数**作为第三个参数，`useReducer` 会在组件首次渲染时执行该函数生成初始 state：\n```jsx\n// 初始化函数：根据 props 生成初始 state\nfunction init(initialCount) {\n  return { count: initialCount, history: [initialCount] };\n}\n\nfunction Counter({ initialCount }) {\n  // 第三个参数为初始化函数，第二个参数为初始化函数的入参\n  const [state, dispatch] = useReducer(reducer, initialCount, init);\n\n  // ...\n}\n```\n\n## 3.3 重置 state 到初始值\n结合初始化函数，可实现“重置 state 到初始值”的功能：\n```jsx\nfunction reducer(state, action) {\n  switch (action.type) {\n    case 'RESET':\n      // 调用 init 函数，重置为初始 state\n      return init(action.payload);\n    // ... 其他 action\n  }\n}\n\n// 组件中调用\ndispatch({ type: 'RESET', payload: initialCount });\n```\n\n# 4. useReducer 与 Redux 的关系\n## 4.1 相似点\n- 核心思想一致：通过 reducer 纯函数处理状态更新，action 描述状态变化，dispatch 分发 action。\n- 状态不可变：reducer 必须返回新的 state，不能直接修改原 state。\n- 纯函数约束：reducer 不能包含副作用（如数据请求、DOM 操作）。\n\n## 4.2 区别\n| 特性         | useReducer                      | Redux                              |\n|--------------|---------------------------------|------------------------------------|\n| 作用域       | 组件内局部状态管理              | 全局状态管理（跨组件共享）|\n| 中间件支持   | 不支持                          | 支持（如 redux-thunk、redux-saga） |\n| 调试工具     | 无专用工具                      | 支持 Redux DevTools 调试           |\n| 额外依赖     | 无需额外安装（React 内置）| 需要安装 redux、react-redux 等     |\n| 适用场景     | 组件内复杂状态                  | 全局共享状态、大型应用             |\n\n## 4.3 useReducer 作为 Redux 极简版\n对于小型应用或组件内复杂状态，`useReducer` + `useContext` 可替代 Redux 实现全局状态管理：\n```jsx\n// 1. 创建 Context\nconst StoreContext = createContext();\n\n// 2. 创建 Provider 组件，封装 useReducer\nfunction StoreProvider({ children }) {\n  const [state, dispatch] = useReducer(rootReducer, initialState);\n  return (\n    <StoreContext.Provider value={{ state, dispatch }}>\n      {children}\n    </StoreContext.Provider>\n  );\n}\n\n// 3. 全局使用\nfunction App() {\n  return (\n    <StoreProvider>\n      <ComponentA />\n      <ComponentB />\n    </StoreProvider>\n  );\n}\n\n// 4. 子组件消费\nfunction ComponentA() {\n  const { state, dispatch } = useContext(StoreContext);\n  return (\n    <button onClick={() => dispatch({ type: 'INCREMENT' })}>\n      {state.count}\n    </button>\n  );\n}\n```\n\n# 5. useReducer 最佳实践\n## 5.1 抽离 reducer 为独立文件\n复杂应用中，将 reducer 抽离为独立文件，便于维护和复用：\n```jsx\n// src/reducers/todoReducer.js\nexport default function todoReducer(state, action) {\n  switch (action.type) {\n    case 'ADD_TODO':\n      return [...state, { id: Date.now(), text: action.payload, done: false }];\n    // ... 其他 action\n    default:\n      return state;\n  }\n}\n\n// 组件中导入\nimport todoReducer from '../reducers/todoReducer';\n```\n\n## 5.2 使用 action creator 统一创建 action\n避免在组件中直接编写 action 对象，抽离为 action creator 函数，减少重复代码：\n```jsx\n// src/actions/todoActions.js\nexport const addTodo = (text) => ({\n  type: 'ADD_TODO',\n  payload: text\n});\n\nexport const toggleTodo = (id) => ({\n  type: 'TOGGLE_TODO',\n  payload: id\n});\n\n// 组件中使用\nimport { addTodo, toggleTodo } from '../actions/todoActions';\n\n// 分发 action\ndispatch(addTodo(inputValue));\ndispatch(toggleTodo(todo.id));\n```\n\n## 5.3 合理拆分 reducer\n当全局状态复杂时，拆分多个子 reducer，通过 `combineReducers` 合并（类似 Redux）：\n```jsx\n// 子 reducer\nfunction todoReducer(state, action) { /* ... */ }\nfunction userReducer(state, action) { /* ... */ }\n\n// 合并 reducer\nfunction rootReducer(state, action) {\n  return {\n    todos: todoReducer(state.todos, action),\n    user: userReducer(state.user, action)\n  };\n}\n```\n\n# 6. 核心总结\n1. **核心作用**：管理复杂状态逻辑，替代 `useState` 处理多子值、多更新逻辑的状态。\n2. **核心流程**：`dispatch(action)` → `reducer(state, action)` → 返回新 state → 组件渲染。\n3. **适用场景**：\n   - 组件状态包含多个子值（如对象、数组）。\n   - 状态更新逻辑复杂（依赖前置状态、多条件更新）。\n   - 需要集中管理状态变化（便于调试和维护）。\n4. **高级特性**：\n   - 懒加载初始化 state（通过初始化函数）。\n   - 结合 `useContext` 实现全局状态管理（替代 Redux 极简版）。\n5. **最佳实践**：\n   - 抽离 reducer 和 action creator 为独立文件。\n   - 复杂状态拆分 reducer，保持单一职责。\n   - 遵循不可变原则，reducer 中返回新 state。...","directory_id":"aac29662-babe-4c96-8f61-0a16830155d4","is_published":true,"created_at":"2025-12-19 15:12:13.205458+00","updated_at":"2025-12-22 02:21:33.508503+00"},{"id":"4f7ca80c-d51b-4207-bb8c-b3ccf7d6dc26","title":"常用自定义 Hooks 实现","content":"以下是三个高频实用的自定义 Hooks 实现，包含完整代码、核心逻辑解析和使用示例：\n\n# 1. useRequest：通用网络请求 Hooks\n## 1.1 功能说明\n封装网络请求的核心逻辑（加载状态、数据、错误、重试），支持手动触发、自动请求、取消请求，适配 Promise 风格的请求函数（如 fetch、axios）。\n\n## 1.2 完整实现\n```jsx\nimport { useState, useCallback, useRef, useEffect } from 'react';\n\nfunction useRequest(requestFn, options = {}) {\n  const { autoRun = true, onSuccess, onError } = options;\n  const [data, setData] = useState(null);\n  const [loading, setLoading] = useState(false);\n  const [error, setError] = useState(null);\n  const abortControllerRef = useRef(null); // 用于取消请求\n\n  // 核心请求逻辑\n  const run = useCallback(async (...args) => {\n    // 取消上一次未完成的请求\n    if (abortControllerRef.current) {\n      abortControllerRef.current.abort();\n    }\n    abortControllerRef.current = new AbortController();\n    \n    setLoading(true);\n    setError(null);\n    try {\n      // 传入取消信号，支持请求取消\n      const result = await requestFn(...args, abortControllerRef.current.signal);\n      setData(result);\n      onSuccess?.(result); // 成功回调\n      return result;\n    } catch (err) {\n      if (err.name !== 'AbortError') { // 排除手动取消的错误\n        setError(err);\n        onError?.(err); // 失败回调\n      }\n      return null;\n    } finally {\n      setLoading(false);\n    }\n  }, [requestFn, onSuccess, onError]);\n\n  // 取消请求\n  const cancel = useCallback(() => {\n    if (abortControllerRef.current) {\n      abortControllerRef.current.abort();\n      abortControllerRef.current = null;\n    }\n  }, []);\n\n  // 自动执行请求\n  useEffect(() => {\n    if (autoRun) {\n      run();\n    }\n    // 组件卸载时取消请求\n    return () => cancel();\n  }, [autoRun, run, cancel]);\n\n  return { data, loading, error, run, cancel };\n}\n```\n\n## 1.3 使用示例\n```jsx\n// 定义请求函数\nconst fetchUser = async (id, signal) => {\n  const res = await fetch(`https://api.example.com/user/${id}`, { signal });\n  return res.json();\n};\n\nfunction UserComponent() {\n  const { data: user, loading, error, run } = useRequest(fetchUser, {\n    autoRun: false, // 关闭自动请求\n    onSuccess: (data) => console.log('请求成功：', data),\n    onError: (err) => console.error('请求失败：', err),\n  });\n\n  return (\n    <div>\n      <button onClick={() => run(123)} disabled={loading}>\n        加载用户信息\n      </button>\n      {loading && <p>加载中...</p>}\n      {error && <p>错误：{error.message}</p>}\n      {user && <p>用户名：{user.name}</p>}\n    </div>\n  );\n}\n```\n\n# 2. useLocalStorage：本地存储 Hooks\n## 2.1 功能说明\n封装 localStorage 的读写逻辑，实现“状态与本地存储同步”，支持初始值、数据序列化/反序列化，处理异常场景（如无存储权限）。\n\n## 2.2 完整实现\n```jsx\nimport { useState, useCallback } from 'react';\n\nfunction useLocalStorage(key, initialValue) {\n  // 初始化：优先从本地存储读取，失败则用初始值\n  const [storedValue, setStoredValue] = useState(() => {\n    try {\n      const item = window.localStorage.getItem(key);\n      // 反序列化：本地存储为字符串，转换为原始类型\n      return item ? JSON.parse(item) : initialValue;\n    } catch (error) {\n      console.error('读取localStorage失败：', error);\n      return initialValue;\n    }\n  });\n\n  // 写入本地存储并更新状态\n  const setValue = useCallback((value) => {\n    try {\n      // 支持函数式更新（与useState保持一致）\n      const valueToStore = value instanceof Function ? value(storedValue) : value;\n      setStoredValue(valueToStore);\n      // 序列化：将数据转为字符串存储\n      window.localStorage.setItem(key, JSON.stringify(valueToStore));\n    } catch (error) {\n      console.error('写入localStorage失败：', error);\n    }\n  }, [key, storedValue]);\n\n  // 移除本地存储项\n  const removeValue = useCallback(() => {\n    try {\n      window.localStorage.removeItem(key);\n      setStoredValue(initialValue);\n    } catch (error) {\n      console.error('移除localStorage项失败：', error);\n    }\n  }, [key, initialValue]);\n\n  return [storedValue, setValue, removeValue];\n}\n```\n\n## 2.3 使用示例\n```jsx\nfunction ThemeSwitch() {\n  // 初始化：从localStorage读取theme，无则默认light\n  const [theme, setTheme, removeTheme] = useLocalStorage('app-theme', 'light');\n\n  const toggleTheme = () => {\n    setTheme(prev => prev === 'light' ? 'dark' : 'light');\n  };\n\n  return (\n    <div className={`theme-${theme}`}>\n      <p>当前主题：{theme}</p>\n      <button onClick={toggleTheme}>切换主题</button>\n      <button onClick={removeTheme}>重置主题</button>\n    </div>\n  );\n}\n```\n\n# 3. useDebounce：防抖 Hooks\n## 3.1 功能说明\n实现值的防抖处理，延迟更新值（如搜索框输入、窗口尺寸变化），避免高频触发逻辑（如请求、渲染），支持自定义延迟时间、立即执行。\n\n## 3.2 完整实现\n```jsx\nimport { useState, useEffect, useCallback } from 'react';\n\nfunction useDebounce(value, delay = 500, options = { leading: false }) {\n  const { leading } = options;\n  const [debouncedValue, setDebouncedValue] = useState(value);\n  const timerRef = useRef(null);\n\n  // 防抖核心逻辑\n  useEffect(() => {\n    // 立即执行：首次触发时同步更新值（leading = true）\n    if (leading && timerRef.current === null) {\n      setDebouncedValue(value);\n    } else {\n      // 清除上一次定时器\n      if (timerRef.current) {\n        clearTimeout(timerRef.current);\n      }\n      // 延迟更新值\n      timerRef.current = setTimeout(() => {\n        setDebouncedValue(value);\n        timerRef.current = null;\n      }, delay);\n    }\n\n    // 组件卸载/依赖变化时清除定时器\n    return () => {\n      if (timerRef.current) {\n        clearTimeout(timerRef.current);\n      }\n    };\n  }, [value, delay, leading]);\n\n  // 手动触发更新防抖值\n  const flush = useCallback(() => {\n    if (timerRef.current) {\n      clearTimeout(timerRef.current);\n      timerRef.current = null;\n      setDebouncedValue(value);\n    }\n  }, [value]);\n\n  return [debouncedValue, flush];\n}\n```\n\n## 3.3 使用示例\n```jsx\nfunction SearchBox() {\n  const [inputValue, setInputValue] = useState('');\n  // 防抖处理：输入停止500ms后更新debouncedValue\n  const [debouncedValue, flushDebounce] = useDebounce(inputValue, 500);\n\n  // 防抖值变化时触发搜索\n  useEffect(() => {\n    if (debouncedValue) {\n      console.log('搜索：', debouncedValue);\n      // 执行搜索请求逻辑\n    }\n  }, [debouncedValue]);\n\n  return (\n    <div>\n      <input\n        type=\"text\"\n        value={inputValue}\n        onChange={(e) => setInputValue(e.target.value)}\n        placeholder=\"输入搜索内容...\"\n      />\n      <button onClick={flushDebounce}>立即搜索</button>\n      <p>防抖后的值：{debouncedValue}</p>\n    </div>\n  );\n}\n```","directory_id":"9e07a04e-b6bb-488a-9725-08821605cfbc","is_published":true,"created_at":"2025-12-22 02:22:34.493316+00","updated_at":"2025-12-22 02:50:00.172823+00"},{"id":"53467990-3a1c-48c8-ae2b-5d3bb36bbecb","title":"表单验证","content":"表单验证是确保用户输入数据合法的关键步骤，常见验证场景包括：必填项校验、格式校验（如手机号、邮箱）、长度校验、数值范围校验等。React 中表单验证可分为**手动验证**（自定义逻辑）和**正则表达式校验**（高效匹配格式），可结合受控/非受控表单实现。\n\n# 1. 验证时机\n根据用户体验需求，可选择不同的验证时机：\n- 即时验证：用户输入过程中（`onChange`）实时校验，即时反馈错误；\n- 失焦验证：用户离开表单字段时（`onBlur`）校验，避免频繁干扰；\n- 提交验证：表单提交时（`onSubmit`）校验，阻止非法数据提交；\n- 组合验证：如“失焦验证 + 提交验证”，兼顾体验和准确性。\n\n# 2. 手动验证（自定义逻辑）\n手动验证通过编写条件判断逻辑，检查表单字段是否符合要求，适用于简单的校验规则（如必填、长度限制、数值范围）。\n\n## 2.1 受控表单 + 提交验证（基础示例）\n```javascript\nimport { useState } from 'react';\n\nfunction ManualValidationForm() {\n  const [formData, setFormData] = useState({\n    username: '',\n    password: '',\n    age: ''\n  });\n\n  // 存储错误信息（key 对应字段名，value 为错误提示）\n  const [errors, setErrors] = useState({});\n\n  // 更新表单数据\n  const handleChange = (e) => {\n    const { name, value } = e.target;\n    setFormData(prev => ({ ...prev, [name]: value }));\n    // 输入时清除对应字段的错误提示（可选）\n    if (errors[name]) {\n      setErrors(prev => ({ ...prev, [name]: '' }));\n    }\n  };\n\n  // 表单验证逻辑（返回是否通过验证，同时更新错误信息）\n  const validateForm = () => {\n    const newErrors = {};\n\n    // 用户名校验：必填 + 长度 3-10 位\n    if (!formData.username.trim()) {\n      newErrors.username = '用户名不能为空';\n    } else if (formData.username.length < 3 || formData.username.length > 10) {\n      newErrors.username = '用户名长度需在 3-10 位之间';\n    }\n\n    // 密码校验：必填 + 长度 >=6 位\n    if (!formData.password.trim()) {\n      newErrors.password = '密码不能为空';\n    } else if (formData.password.length < 6) {\n      newErrors.password = '密码长度不能少于 6 位';\n    }\n\n    // 年龄校验：必填 + 数字 + 18-60 岁\n    if (!formData.age.trim()) {\n      newErrors.age = '年龄不能为空';\n    } else {\n      const age = Number(formData.age);\n      if (isNaN(age)) {\n        newErrors.age = '年龄必须是数字';\n      } else if (age < 18 || age > 60) {\n        newErrors.age = '年龄需在 18-60 岁之间';\n      }\n    }\n\n    // 更新错误信息\n    setErrors(newErrors);\n    // 无错误则返回 true（验证通过）\n    return Object.keys(newErrors).length === 0;\n  };\n\n  const handleSubmit = (e) => {\n    e.preventDefault();\n    // 提交前执行验证\n    const isVaild = validateForm();\n    if (isVaild) {\n      console.log('表单验证通过，提交数据：', formData);\n      // 后续：接口请求等逻辑\n    }\n  };\n\n  return (\n    <form onSubmit={handleSubmit} style={{ display: 'flex', flexDirection: 'column', gap: '10px' }}>\n      <div>\n        <label>用户名：</label>\n        <input\n          type=\"text\"\n          name=\"username\"\n          value={formData.username}\n          onChange={handleChange}\n          placeholder=\"请输入用户名\"\n        />\n        {/* 显示错误提示 */}\n        {errors.username && <span style={{ color: 'red', fontSize: '12px' }}>{errors.username}</span>}\n      </div>\n\n      <div>\n        <label>密码：</label>\n        <input\n          type=\"password\"\n          name=\"password\"\n          value={formData.password}\n          onChange={handleChange}\n          placeholder=\"请输入密码\"\n        />\n        {errors.password && <span style={{ color: 'red', fontSize: '12px' }}>{errors.password}</span>}\n      </div>\n\n      <div>\n        <label>年龄：</label>\n        <input\n          type=\"text\"\n          name=\"age\"\n          value={formData.age}\n          onChange={handleChange}\n          placeholder=\"请输入年龄\"\n        />\n        {errors.age && <span style={{ color: 'red', fontSize: '12px' }}>{errors.age}</span>}\n      </div>\n\n      <button type=\"submit\">提交</button>\n    </form>\n  );\n}\n```\n\n## 2.2 受控表单 + 即时验证（onChange）\n即时验证在用户输入时实时反馈错误，提升用户体验，但需注意避免频繁重渲染。\n\n```javascript\nimport { useState } from 'react';\n\nfunction InstantValidationForm() {\n  const [formData, setFormData] = useState({\n    email: '',\n    phone: ''\n  });\n  const [errors, setErrors] = useState({});\n\n  // 单个字段的验证逻辑\n  const validateField = (name, value) => {\n    let error = '';\n    switch (name) {\n      case 'email':\n        if (!value.trim()) {\n          error = '邮箱不能为空';\n        } else if (!/^[\\w.-]+@[a-zA-Z0-9-]+\\.[a-zA-Z]{2,}$/.test(value)) {\n          error = '邮箱格式不正确（如：xxx@xxx.com）';\n        }\n        break;\n      case 'phone':\n        if (!value.trim()) {\n          error = '手机号不能为空';\n        } else if (!/^1[3-9]\\d{9}$/.test(value)) {\n          error = '手机号格式不正确（11位数字）';\n        }\n        break;\n      default:\n        break;\n    }\n    return error;\n  };\n\n  // 输入时实时验证\n  const handleChange = (e) => {\n    const { name, value } = e.target;\n    setFormData(prev => ({ ...prev, [name]: value }));\n    // 验证当前字段并更新错误信息\n    const error = validateField(name, value);\n    setErrors(prev => ({ ...prev, [name]: error }));\n  };\n\n  // 提交时最终验证（防止用户绕过输入验证）\n  const handleSubmit = (e) => {\n    e.preventDefault();\n    const newErrors = {\n      email: validateField('email', formData.email),\n      phone: validateField('phone', formData.phone)\n    };\n    setErrors(newErrors);\n    if (Object.keys(newErrors).every(key => !newErrors[key])) {\n      console.log('验证通过，提交数据：', formData);\n    }\n  };\n\n  return (\n    <form onSubmit={handleSubmit} style={{ display: 'flex', flexDirection: 'column', gap: '10px' }}>\n      <div>\n        <label>邮箱：</label>\n        <input\n          type=\"email\"\n          name=\"email\"\n          value={formData.email}\n          onChange={handleChange}\n          placeholder=\"请输入邮箱\"\n        />\n        {errors.email && <span style={{ color: 'red', fontSize: '12px' }}>{errors.email}</span>}\n      </div>\n\n      <div>\n        <label>手机号：</label>\n        <input\n          type=\"text\"\n          name=\"phone\"\n          value={formData.phone}\n          onChange={handleChange}\n          placeholder=\"请输入手机号\"\n        />\n        {errors.phone && <span style={{ color: 'red', fontSize: '12px' }}>{errors.phone}</span>}\n      </div>\n\n      <button type=\"submit\">提交</button>\n    </form>\n  );\n}\n```\n\n## 2.3 非受控表单 + 提交验证\n非受控表单通过 `ref` 获取字段值后，执行验证逻辑。\n\n```javascript\nimport { useRef, useState } from 'react';\n\nfunction UncontrolledValidationForm() {\n  const formRef = useRef(null);\n  const [errors, setErrors] = useState({});\n\n  const validateForm = () => {\n    const form = formRef.current;\n    const newErrors = {};\n\n    // 用户名校验\n    const username = form.username.value.trim();\n    if (!username) {\n      newErrors.username = '用户名不能为空';\n    } else if (username.length < 3) {\n      newErrors.username = '用户名长度不能少于 3 位';\n    }\n\n    // 密码校验\n    const password = form.password.value.trim();\n    if (!password) {\n      newErrors.password = '密码不能为空';\n    } else if (password.length < 6) {\n      newErrors.password = '密码长度不能少于 6 位';\n    }\n\n    setErrors(newErrors);\n    return Object.keys(newErrors).length === 0;\n  };\n\n  const handleSubmit = (e) => {\n    e.preventDefault();\n    const isVaild = validateForm();\n    if (isVaild) {\n      const form = formRef.current;\n      console.log('提交数据：', {\n        username: form.username.value,\n        password: form.password.value\n      });\n      form.reset();\n    }\n  };\n\n  return (\n    <form ref={formRef} onSubmit={handleSubmit} style={{ display: 'flex', flexDirection: 'column', gap: '10px' }}>\n      <div>\n        <label>用户名：</label>\n        <input type=\"text\" name=\"username\" placeholder=\"请输入用户名\" />\n        {errors.username && <span style={{ color: 'red', fontSize: '12px' }}>{errors.username}</span>}\n      </div>\n      <div>\n        <label>密码：</label>\n        <input type=\"password\" name=\"password\" placeholder=\"请输入密码\" />\n        {errors.password && <span style={{ color: 'red', fontSize: '12px' }}>{errors.password}</span>}\n      </div>\n      <button type=\"submit\">提交</button>\n    </form>\n  );\n}\n```\n\n# 3. 正则表达式校验（常用格式匹配）\n正则表达式是高效的字符串格式匹配工具，适用于邮箱、手机号、身份证号、密码强度等复杂格式校验。以下是常见场景的正则表达式及使用示例。\n\n## 3.1 常用正则表达式汇总\n| 校验场景       | 正则表达式                                  | 说明                                  |\n|----------------|---------------------------------------------|---------------------------------------|\n| 邮箱           | `^[\\w.-]+@[a-zA-Z0-9-]+\\.[a-zA-Z]{2,}$`     | 支持字母、数字、下划线、点、短横线    |\n| 手机号         | `^1[3-9]\\d{9}$`                             | 中国大陆手机号（11位，以13-19开头）   |\n| 身份证号（18位）| `^[1-9]\\d{5}(18|19|20)\\d{2}((0[1-9])|(1[0-2]))(([0-2][1-9])|10|20|30|31)\\d{3}[0-9Xx]$` | 支持最后一位为X/x                      |\n| 用户名         | `^[a-zA-Z0-9_]{3,16}$`                      | 字母、数字、下划线，3-16位             |\n| 密码（强）     | `^(?=.*[a-z])(?=.*[A-Z])(?=.*\\d)(?=.*[!@#$%^&*])[A-Za-z\\d!@#$%^&*]{8,}$` | 包含大小写字母、数字、特殊字符，8位以上 |\n| 中文姓名       | `^[\\u4e00-\\u9fa5]{2,6}$`                    | 2-6位中文汉字                          |\n| 邮政编码       | `^[1-9]\\d{5}$`                              | 中国大陆邮政编码（6位数字）            |\n| URL            | `^https?:\\/\\/([\\w.-]+)\\.([a-zA-Z]{2,})(\\/.*)?$` | 支持 http/https 协议                  |\n\n## 3.2 正则表达式校验示例（密码强度 + 邮箱 + 手机号）\n```javascript\nimport { useState } from 'react';\n\nfunction RegexValidationForm() {\n  const [formData, setFormData] = useState({\n    email: '',\n    phone: '',\n    password: ''\n  });\n  const [errors, setErrors] = useState({});\n  // 密码强度提示（可选）\n  const [passwordStrength, setPasswordStrength] = useState('');\n\n  // 正则表达式定义\n  const regexRules = {\n    email: /^[\\w.-]+@[a-zA-Z0-9-]+\\.[a-zA-Z]{2,}$/,\n    phone: /^1[3-9]\\d{9}$/,\n    password: /^(?=.*[a-z])(?=.*[A-Z])(?=.*\\d)(?=.*[!@#$%^&*])[A-Za-z\\d!@#$%^&*]{8,}$/\n  };\n\n  // 密码强度检测（可选增强功能）\n  const checkPasswordStrength = (password) => {\n    if (password.length < 6) return '弱';\n    if (password.length < 8 && /^[a-zA-Z0-9]+$/.test(password)) return '中';\n    if (regexRules.password.test(password)) return '强';\n    return '中';\n  };\n\n  const handleChange = (e) => {\n    const { name, value } = e.target;\n    setFormData(prev => ({ ...prev, [name]: value }));\n\n    // 字段验证\n    let error = '';\n    if (!value.trim()) {\n      error = `${name === 'email' ? '邮箱' : name === 'phone' ? '手机号' : '密码'}不能为空`;\n    } else if (!regexRules[name].test(value)) {\n      error = {\n        email: '邮箱格式不正确（如：xxx@xxx.com）',\n        phone: '手机号格式不正确（11位数字）',\n        password: '密码需包含大小写字母、数字、特殊字符，且长度≥8位'\n      }[name];\n    }\n    setErrors(prev => ({ ...prev, [name]: error }));\n\n    // 密码强度检测\n    if (name === 'password') {\n      setPasswordStrength(checkPasswordStrength(value));\n    }\n  };\n\n  const handleSubmit = (e) => {\n    e.preventDefault();\n    const newErrors = {};\n\n    // 提交时最终验证\n    Object.keys(regexRules).forEach(key => {\n      const value = formData[key].trim();\n      if (!value) {\n        newErrors[key] = `${key === 'email' ? '邮箱' : key === 'phone' ? '手机号' : '密码'}不能为空`;\n      } else if (!regexRules[key].test(value)) {\n        newErrors[key] = {\n          email: '邮箱格式不正确',\n     ...","directory_id":"0e360aa6-df1e-4212-b06e-7ebc4541f5d5","is_published":true,"created_at":"2025-12-22 03:18:47.534454+00","updated_at":"2025-12-23 13:02:59.948529+00"},{"id":"544a877d-ac3d-4150-88d5-30852804b215","title":"轻量状态管理方案","content":"除了 Zustand，React 生态中还有两款聚焦“原子化状态管理”的轻量方案——Recoil（Facebook 出品）和 Jotai（基于 Recoil 理念优化），核心特点是**将状态拆分为细粒度的原子（Atom），组件按需订阅原子，实现精准更新**，弥补了 Context 全局重渲染的缺陷，同时保持极简的 API 设计。\n\n# 1. Recoil（原子化状态管理先驱）\n## 1.1 核心概念\n- **Atom（原子）**：最小粒度的状态单元，可被组件订阅，更新时仅触发订阅该原子的组件重渲染；\n- **Selector（选择器）**：派生状态，基于 Atom 或其他 Selector 计算得到（支持同步/异步）；\n- **RecoilRoot**：全局 Provider，需包裹应用根组件，提供原子状态上下文。\n\n## 1.2 核心特性\n- 原子化状态：状态拆分为独立原子，组件按需订阅，避免全局重渲染；\n- 派生状态：Selector 支持同步/异步计算（如基于用户 ID 异步获取用户信息）；\n- 兼容 React 并发模式：设计时考虑了 React 新特性，支持 Suspense 处理异步状态；\n- 轻量简洁：API 简单，学习成本低于 Redux，高于 Context；\n- TypeScript 友好：天然支持类型推断。\n\n## 1.3 快速上手\n### 1.3.1 安装\n```bash\nnpm install recoil\n\nyarn add recoil\n```\n\n### 1.3.2 基本使用（计数器示例）\n```javascript\nimport { RecoilRoot, atom, useRecoilState, selector, useRecoilValue } from 'recoil';\n\n// 1. 定义原子状态\nconst countAtom = atom({\n  key: 'count', // 全局唯一标识（必须）\n  default: 0 // 初始值\n});\n\n// 2. 定义派生状态（Selector）\nconst doubleCountSelector = selector({\n  key: 'doubleCount',\n  get: ({ get }) => {\n    // 基于 countAtom 计算派生值\n    const count = get(countAtom);\n    return count * 2;\n  }\n});\n\n// 3. 消费原子的组件\nfunction Counter() {\n  // 订阅并修改 countAtom\n  const [count, setCount] = useRecoilState(countAtom);\n  return (\n    <div>\n      <p>Count: {count}</p>\n      <button onClick={() => setCount(count + 1)}>加 1</button>\n    </div>\n  );\n}\n\n// 4. 消费派生状态的组件\nfunction DoubleCounter() {\n  // 仅订阅派生状态，不修改\n  const doubleCount = useRecoilValue(doubleCountSelector);\n  return <p>Double Count: {doubleCount}</p>;\n}\n\n// 5. 根组件包裹 RecoilRoot\nfunction App() {\n  return (\n    <RecoilRoot>\n      <Counter />\n      <DoubleCounter />\n    </RecoilRoot>\n  );\n}\n```\n\n### 1.3.3 异步 Selector（获取用户信息）\n```javascript\nconst userIdAtom = atom({\n  key: 'userId',\n  default: 1\n});\n\nconst userInfoSelector = selector({\n  key: 'userInfo',\n  get: async ({ get }) => {\n    const userId = get(userIdAtom);\n    const res = await fetch(`https://jsonplaceholder.typicode.com/users/${userId}`);\n    return res.json();\n  }\n});\n\n// 组件中使用（结合 Suspense 处理加载状态）\nfunction UserInfo() {\n  const userInfo = useRecoilValue(userInfoSelector);\n  return (\n    <div>\n      <h3>{userInfo.name}</h3>\n      <p>{userInfo.email}</p>\n    </div>\n  );\n}\n\nfunction App() {\n  return (\n    <RecoilRoot>\n      <Suspense fallback={<div>加载中...</div>}>\n        <UserInfo />\n      </Suspense>\n    </RecoilRoot>\n  );\n}\n```\n\n## 1.4 优缺点与适用场景\n| 优点 | 缺点 |\n|------|------|\n| 原子化状态，精准更新（仅订阅组件重渲染） | 需包裹 RecoilRoot，增加组件层级 |\n| 强大的派生状态能力（支持异步） | 生态不如 Zustand/Redux 丰富 |\n| 兼容 React 并发模式/Suspense | 部分场景下（如原子依赖过多）Selector 计算复杂 |\n| API 简洁，学习成本低 | 暂未正式发布 1.0 版本（存在少量不稳定 API） |\n\n**适用场景**：\n- 需细粒度状态共享的 React 项目；\n- 依赖派生状态（如计算属性、异步数据）的场景；\n- 追求 React 新特性（并发模式、Suspense）兼容的项目；\n- 中小型应用，不想引入 Redux 但需要比 Context 更优的性能。\n\n# 2. Jotai（Recoil 轻量化替代）\nJotai 由 React 核心团队成员开发，基于 Recoil 的原子化理念，简化了 API 设计，移除了 RecoilRoot 的强制要求（可选），体积更小（~2KB gzip），性能更优，成为近年来备受推崇的轻量状态管理方案。\n\n## 2.1 核心概念\n- **Atom**：与 Recoil 一致，最小粒度的状态单元，支持默认值、只读/可写；\n- **Selector**：派生状态，支持同步/异步，API 比 Recoil 更简洁；\n- **Provider（可选）**：默认无需 Provider，复杂场景（如多实例、持久化）可使用 Provider。\n\n## 2.2 核心特性\n- 无强制 Provider：默认全局共享原子，简化组件层级；\n- 极简 API：原子创建、订阅、修改的语法比 Recoil 更简洁；\n- 更小体积：~2KB gzip，比 Recoil 更轻量；\n- 支持 Suspense/并发模式：与 Recoil 一致；\n- 丰富的扩展：支持持久化、原子联动、批量更新等；\n- TypeScript 友好：完全类型安全。\n\n## 2.3 快速上手\n### 2.3.1 安装\n```bash\nnpm install jotai\n\nyarn add jotai\n```\n\n### 2.3.2 基本使用（计数器示例）\n```javascript\nimport { atom, useAtom, useAtomValue } from 'jotai';\n\n// 1. 定义原子状态\nconst countAtom = atom(0); // 直接传入初始值，无需 key（可选 key 用于调试）\n\n// 2. 定义派生状态（Selector）\nconst doubleCountAtom = atom((get) => {\n  const count = get(countAtom);\n  return count * 2;\n});\n\n// 3. 消费原子的组件\nfunction Counter() {\n  const [count, setCount] = useAtom(countAtom);\n  return (\n    <div>\n      <p>Count: {count}</p>\n      <button onClick={() => setCount(count + 1)}>加 1</button>\n      <button onClick={() => setCount((prev) => prev - 1)}>减 1</button>\n    </div>\n  );\n}\n\n// 4. 消费派生状态的组件\nfunction DoubleCounter() {\n  const doubleCount = useAtomValue(doubleCountAtom);\n  return <p>Double Count: {doubleCount}</p>;\n}\n\n// 5. 根组件无需 Provider\nfunction App() {\n  return (\n    <div>\n      <Counter />\n      <DoubleCounter />\n    </div>\n  );\n}\n```\n\n### 2.3.3 异步 Atom（获取用户信息）\n```javascript\nimport { atom, useAtomValue } from 'jotai';\nimport { Suspense } from 'react';\n\n// 定义异步原子\nconst userIdAtom = atom(1);\nconst userInfoAtom = atom(async (get) => {\n  const userId = get(userIdAtom);\n  const res = await fetch(`https://jsonplaceholder.typicode.com/users/${userId}`);\n  return res.json();\n});\n\n// 组件中使用\nfunction UserInfo() {\n  const userInfo = useAtomValue(userInfoAtom);\n  return (\n    <div>\n      <h3>{userInfo.name}</h3>\n      <p>{userInfo.email}</p>\n    </div>\n  );\n}\n\nfunction App() {\n  return (\n    <Suspense fallback={<div>加载中...</div>}>\n      <UserInfo />\n    </Suspense>\n  );\n}\n```\n\n### 2.3.4 持久化扩展（jotai-persist）\n```javascript\nimport { atom, useAtom } from 'jotai';\nimport { persistAtom } from 'jotai/utils';\n\n// 定义持久化原子\nconst themeAtom = atom('light');\n// 添加持久化中间件\nconst persistedThemeAtom = atom(\n  (get) => get(themeAtom),\n  (get, set, update) => {\n    set(themeAtom, update);\n  }\n);\npersistedThemeAtom.onMount = (setAtom) => {\n  const saved = localStorage.getItem('theme');\n  if (saved) setAtom(saved);\n};\n\nfunction ThemeToggle() {\n  const [theme, setTheme] = useAtom(persistedThemeAtom);\n  const toggleTheme = () => setTheme(prev => prev === 'light' ? 'dark' : 'light');\n  return <button onClick={toggleTheme}>当前主题：{theme}</button>;\n}\n```\n\n## 2.4 优缺点与适用场景\n| 优点 | 缺点 |\n|------|------|\n| 无强制 Provider，组件层级更简洁 | 生态不如 Redux 丰富 |\n| 体积极小，性能优异 | 仅支持 React 生态（无跨框架能力） |\n| API 极简，学习成本低于 Recoil/Redux | 大型项目中原子管理需手动规范 |\n| 支持 Suspense/并发模式 | 调试工具功能较基础 |\n| 丰富的内置扩展（持久化、批量更新等） | 复杂异步流程处理能力弱于 Redux-Saga |\n\n**适用场景**：\n- 中小型 React 项目，追求极致简洁的状态管理；\n- 需细粒度状态更新，避免 Context 全局重渲染；\n- 依赖异步派生状态的场景（如 API 数据获取）；\n- 对打包体积敏感的项目（如移动端、小程序）；\n- 喜欢 Recoil 理念但想简化 API 的开发者。\n\n# 3. Recoil vs Jotai 核心差异\n| 维度                | Recoil                    | Jotai                     |\n|---------------------|---------------------------|---------------------------|\n| 强制 Provider       | 是（RecoilRoot）| 否（可选）|\n| 体积                | ~4KB gzip                 | ~2KB gzip                 |\n| API 简洁度          | 中等                      | 极高                      |\n| 原子 key            | 必须                      | 可选                      |\n| 扩展能力            | 中等                      | 丰富（内置 utils）|\n| 生态成熟度          | 较高（Facebook 出品）| 快速增长                  |\n| 兼容性              | 兼容 React 16.8+          | 兼容 React 16.8+          |\n\n# 4. 轻量状态管理方案选择建议\n1. **选 Recoil**：\n   - 项目已深度使用 Recoil 生态；\n   - 依赖 Recoil 特有功能（如原子家族、持久化快照）；\n   - 团队更信任 Facebook 官方维护的库。\n\n2. **选 Jotai**：\n   - 追求极简 API 和更小体积；\n   - 不想引入 Provider 层级；\n   - 需丰富的内置扩展（持久化、批量更新等）；\n   - 中小型 React 项目，优先轻量高效。\n\n3. **选 Zustand**：\n   - 需集中式 store 管理（而非原子化）；\n   - 无需兼容 Suspense/并发模式；\n   - 追求跨组件状态共享的极致简洁。\n","directory_id":"7a39499e-a54e-4dd5-89ed-f24202ec0992","is_published":true,"created_at":"2025-12-22 03:14:11.255705+00","updated_at":"2025-12-23 09:09:27.870864+00"},{"id":"5981c8dd-28c7-4598-b29b-aff7d40e34c1","title":"React 项目部署","content":"# 1. 部署前准备\n## 1.1 生产环境打包\n```bash\nnpm run build\n```\n打包完成后生成 `build`（CRA）/ `dist`（Vite/Webpack）目录，包含静态资源（HTML/CSS/JS/图片）。\n\n## 1.2 打包产物检查\n- 确认 `index.html` 为入口文件；\n- 检查静态资源路径（相对路径/绝对路径）：\n  - 相对路径：适合部署在子路径（如 `https://example.com/app/`）；\n  - 绝对路径：适合部署在根路径（如 `https://example.com/`）；\n- 配置基础路径（Base URL）：\n  - CRA：修改 `package.json` 中的 `homepage`：\n    ```json\n    { \"homepage\": \"https://example.com/app/\" }\n    ```\n  - Vite：修改 `vite.config.js` 中的 `base`：\n    ```javascript\n    export default defineConfig({ base: '/app/' });\n    ```\n  - Webpack：修改 `webpack.config.js` 中的 `output.publicPath`：\n    ```javascript\n    output: { publicPath: '/app/' }\n    ```\n\n# 2. Nginx 部署（本地/服务器）\n## 2.1 Nginx 安装\n- **Windows**：下载 Nginx 压缩包，解压后运行 `nginx.exe`；\n- **Linux**：`sudo apt install nginx`（Ubuntu/Debian）或 `sudo yum install nginx`（CentOS）；\n- **Mac**：`brew install nginx`。\n\n## 2.2 配置 Nginx\n1. 复制打包产物到 Nginx 静态目录（默认 `/usr/share/nginx/html`，Windows 为 `nginx-xxx/html`）；\n2. 修改 Nginx 配置文件（默认 `/etc/nginx/nginx.conf` 或 `nginx-xxx/conf/nginx.conf`）：\n   ```nginx\n   server {\n     listen 80; # 监听端口\n     server_name localhost; # 域名（生产环境改为实际域名）\n\n     # 静态资源根目录\n     root /usr/share/nginx/html;\n     index index.html;\n\n     # 支持 React Router 路由（刷新 404 问题）\n     location / {\n       try_files $uri $uri/ /index.html; # 找不到文件时返回 index.html\n     }\n\n     # 静态资源缓存策略\n     location ~* \\.(js|css|png|jpg|jpeg|gif|svg)$ {\n       expires 30d; # 30 天缓存\n       add_header Cache-Control \"public, max-age=2592000\";\n     }\n\n     # gzip 压缩（提升加载速度）\n     gzip on;\n     gzip_types text/plain text/css application/json application/javascript text/xml application/xml application/xml+rss text/javascript;\n   }\n   ```\n\n## 2.3 启动/重启 Nginx\n```bash\nsudo nginx # 启动（Linux/Mac）\n\nsudo nginx -s reload  # 重启（修改配置后）\n\nsudo nginx -s stop # 停止\n\nnginx.exe -s reload # Windows\n```\n\n## 2.4 访问项目\n打开浏览器访问 `http://localhost`（或服务器 IP/域名），确认项目正常运行。\n\n## 2.5 生产环境优化（Nginx）\n1. **HTTPS 配置**（Let's Encrypt 免费证书）：\n   ```bash\n   # 安装 certbot\n   sudo apt install certbot python3-certbot-nginx\n   # 获取证书并配置 Nginx\n   sudo certbot --nginx -d example.com\n   ```\n2. **开启 gzip 压缩**（已在配置中示例）；\n3. **限制请求速率**（防止攻击）：\n   ```nginx\n   limit_req_zone $binary_remote_addr zone=one:10m rate=10r/s;\n   location / {\n     limit_req zone=one burst=20 nodelay;\n   }\n   ```\n\n# 3. Vercel 部署（前端无服务部署）\nVercel 是 Vite 官方推荐的部署平台，支持一键部署、自动构建、免费 HTTPS、全球 CDN。\n\n## 3.1 部署步骤\n1. 注册 Vercel 账号（关联 GitHub/GitLab/Bitbucket）；\n2. 安装 Vercel CLI（可选）：\n   ```bash\n   npm install -g vercel\n   ```\n3. 方式一：GitHub 仓库关联部署\n   - 将项目推送到 GitHub 仓库；\n   - 登录 Vercel → New Project → 导入仓库 → 配置构建命令：\n     - Framework Preset：React / Vite（自动识别）；\n     - Build Command：`npm run build`；\n     - Output Directory：`build`（CRA）/ `dist`（Vite/Webpack）；\n   - 点击 Deploy，等待部署完成。\n4. 方式二：CLI 部署（本地直接部署）\n   ```bash\n   cd 项目根目录\n   vercel （首次部署需登录，按提示操作）\n   vercel --prod （部署到生产环境）\n   ```\n\n## 3.2 关键配置\n1. **Vercel.json**（项目根目录）：\n   ```json\n   {\n     \"rewrites\": [{ \"source\": \"/(.*)\", \"destination\": \"/index.html\" }], // 支持 React Router\n     \"build\": {\n       \"env\": {\n         \"NODE_ENV\": \"production\"\n       }\n     }\n   }\n   ```\n2. **环境变量配置**：Vercel 控制台 → Project → Settings → Environment Variables，添加生产环境变量（如 API 地址）。\n\n## 3.3 优势\n- 免费额度充足（个人版）；\n- 自动 HTTPS + 全球 CDN；\n- 支持预览部署（PR 自动生成预览链接）；\n- 零配置部署（自动识别框架）。\n\n# 4. Netlify 部署（替代 Vercel）\nNetlify 与 Vercel 功能类似，支持静态站点和 Serverless 部署。\n\n## 4.1 部署步骤\n1. 注册 Netlify 账号（关联 GitHub/GitLab/Bitbucket）；\n2. 方式一：仓库关联部署\n   - Netlify → Add new site → Import an existing project → 选择 GitHub 仓库；\n   - 配置构建参数：\n     - Build command：`npm run build`；\n     - Publish directory：`build`/`dist`；\n   - 点击 Deploy site。\n3. 方式二：手动上传部署\n   - Netlify → Add new site → Deploy manually → 拖放 `build`/`dist` 目录 → 部署。\n\n## 4.2 关键配置\n1. **Netlify.toml**（项目根目录）：\n   ```toml\n   [build]\n     command = \"npm run build\"\n     publish = \"dist\"\n   [[redirects]]\n     from = \"/*\"\n     to = \"/index.html\"\n     status = 200 # 支持 React Router 路由\n   ```\n2. **环境变量**：Netlify 控制台 → Site settings → Build & deploy → Environment → Environment variables。\n\n# 5. 部署常见问题解决\n## 5.1 路由刷新 404\n- 原因：React Router 是客户端路由，刷新时服务器找不到对应路径的文件；\n- 解决：\n  - Nginx：配置 `try_files $uri $uri/ /index.html`；\n  - Vercel/Netlify：配置重写规则（rewrites/redirects）指向 `index.html`。\n\n## 5.2 静态资源加载失败\n- 检查 `publicPath`/`base` 配置是否正确；\n- 确认静态资源路径为相对路径（如 `./static/js/main.js`）或绝对路径（如 `/static/js/main.js`）；\n- 检查 CDN 引入的依赖是否加载成功（控制台 Network 面板）。\n\n## 5.3 环境变量未生效\n- 生产环境环境变量需在部署平台（Vercel/Netlify/Nginx）配置；\n- React 项目中环境变量需以 `REACT_APP_`（CRA）/ `VITE_`（Vite）开头；\n- 打包前重启构建命令，确保环境变量注入。\n\n## 5.4 跨域问题\n- 开发环境：使用代理（Vite `server.proxy` / Webpack `devServer.proxy`）；\n- 生产环境：\n  - 后端配置 CORS（允许前端域名）；\n  - Nginx 反向代理（将前端 API 请求转发到后端）：\n    ```nginx\n    location /api/ {\n      proxy_pass http://backend-server:8080/; # 后端接口地址\n      proxy_set_header Host $host;\n      proxy_set_header X-Real-IP $remote_addr;\n    }\n    ```\n\n# 6. 部署后监控与维护\n1. **访问统计**：集成 Google Analytics 或百度统计；\n2. **错误监控**：使用 Sentry 捕获前端错误；\n3. **CI/CD 自动化部署**：\n   - GitHub Actions：配置推送代码自动部署到 Vercel/Netlify；\n   - 示例（GitHub Actions 部署到 Vercel）：\n     ```yaml\n     # .github/workflows/vercel.yml\n     name: Deploy to Vercel\n     on:\n       push:\n         branches: [main]\n     jobs:\n       deploy:\n         runs-on: ubuntu-latest\n         steps:\n           - uses: actions/checkout@v3\n           - uses: actions/setup-node@v3\n             with: { node-version: 18 }\n           - run: npm install\n           - run: npm run build\n           - uses: amondnet/vercel-action@v20\n             with:\n               vercel-token: ${{ secrets.VERCEL_TOKEN }}\n               vercel-org-id: ${{ secrets.VERCEL_ORG_ID }}\n               vercel-project-id: ${{ secrets.VERCEL_PROJECT_ID }}\n               vercel-args: '--prod'\n     ```\n\n# 7. 部署方案对比\n| 部署方案 | 优点 | 缺点 | 适用场景 |\n|----------|------|------|----------|\n| Nginx | 完全可控、自定义配置、高性能 | 需服务器、维护成本高 | 企业级项目、需自定义服务器配置 |\n| Vercel | 零配置、自动部署、全球 CDN、免费 | 高级功能付费、依赖第三方平台 | 个人项目、中小型前端项目 |\n| Netlify | 功能全面、免费额度高、支持 Serverless | 国内访问速度一般 | 个人项目、静态站点 |","directory_id":"4e45758d-1053-4937-b961-5a3cef9e566a","is_published":true,"created_at":"2025-12-22 03:21:02.868678+00","updated_at":"2025-12-23 14:04:30.046185+00"},{"id":"5c2e2d6e-eb44-48d2-9743-b6b80f96be35","title":"懒加载与代码分割","content":"# 1. 为什么需要代码分割\nReact 项目默认使用打包工具（Webpack/Rollup）将所有代码打包为一个或少数几个文件，存在以下问题：\n- **首屏加载慢**：打包文件体积过大，导致页面首次加载时间长（白屏）；\n- **资源浪费**：用户可能只访问部分功能（如首页、详情页），但加载了所有功能的代码；\n- **性能瓶颈**：大体积 JS 文件解析/执行耗时，阻塞页面渲染。\n\n## 1.1 代码分割的核心思想\n将应用代码按功能/路由拆分为多个小块（chunk），**按需加载**（仅当用户访问对应功能时才加载相关代码），实现：\n- 减小首屏加载体积，提升加载速度；\n- 避免加载未使用的代码，节省带宽；\n- 并行加载多个小块，提升整体性能。\n\n# 2. React.lazy：组件级懒加载\nReact.lazy 是 React 内置的懒加载 API，用于动态导入组件（仅在组件需要渲染时才加载对应的代码块），配合 `import()` 语法实现代码分割。\n\n## 2.1 基本用法\n```javascript\n// 传统导入（同步加载，打包到主文件）\nimport Home from './pages/Home';\n\n// 懒加载导入（异步加载，单独打包为 chunk）\nconst About = React.lazy(() => import('./pages/About'));\nconst Contact = React.lazy(() => import('./pages/Contact'));\n\nfunction App() {\n  return (\n    <Router>\n      <Routes>\n        <Route path=\"/\" element={<Home />} />\n        {/* 懒加载组件需包裹在 Suspense 中 */}\n        <Route path=\"/about\" element={\n          <Suspense fallback={<div>Loading...</div>}>\n            <About />\n          </Suspense>\n        } />\n        <Route path=\"/contact\" element={\n          <Suspense fallback={<div>Loading...</div>}>\n            <Contact />\n          </Suspense>\n        } />\n      </Routes>\n    </Router>\n  );\n}\n```\n\n## 2.2 核心细节\n1. **React.lazy 参数**：必须是返回 Promise 的函数，且 Promise 需解析为默认导出的 React 组件；\n2. **Suspense 依赖**：懒加载组件渲染时，代码块可能尚未加载完成，需用 `Suspense` 包裹，通过 `fallback` 属性显示加载占位符（如骨架屏、加载动画）；\n3. **错误处理**：若代码块加载失败（如网络错误），需用错误边界（Error Boundary）捕获异常；\n4. **打包行为**：Webpack 等工具会自动将 `import()` 导入的模块拆分为独立 chunk，文件名默认包含哈希（如 `about.123abc.js`）。\n\n## 2.3 高级用法：命名导出组件\nReact.lazy 默认只支持默认导出（default export），若组件是命名导出，需手动包装：\n```javascript\n// 组件文件（pages/Product.js）\nexport const ProductList = () => <div>Product List</div>;\nexport const ProductDetail = () => <div>Product Detail</div>;\n\n// 懒加载命名导出组件\nconst ProductList = React.lazy(() => \n  import('./pages/Product').then(module => ({\n    default: module.ProductList // 映射为默认导出\n  }))\n);\n```\n\n# 3. Suspense：加载状态管理\nSuspense 是 React 提供的加载状态管理组件，核心功能是：**在组件加载完成前显示 fallback 占位符**，支持以下场景：\n1. 配合 React.lazy 实现组件懒加载；\n2. 配合 Suspense 兼容的数据源（如 React Query、Relay）实现数据懒加载；\n3. 嵌套使用，实现多级加载占位符。\n\n## 3.1 核心特性\n1. **fallback 属性**：必填，接收 React 元素（如加载动画、骨架屏），在组件加载完成前显示；\n2. **嵌套 Suspense**：内层 Suspense 的 fallback 优先级高于外层，实现精细化加载状态控制；\n   ```jsx\n   <Suspense fallback={<div>Page Loading...</div>}>\n     <About />\n     <Suspense fallback={<div>Comments Loading...</div>}>\n       <Comments /> {/* 独立懒加载的子组件 */}\n     </Suspense>\n   </Suspense>\n   ```\n3. **并发模式支持**：在 React 18 并发模式下，Suspense 可实现“流式渲染”（先渲染已加载的内容，再逐步渲染未加载的内容）。\n\n# 4. 路由级代码分割（最佳实践）\n最常用的代码分割策略是按路由拆分，因为路由切换是天然的“按需加载”触发点，实现步骤：\n1. 使用 React.lazy 懒加载路由组件；\n2. 用 Suspense 包裹路由组件，设置全局加载占位符；\n3. （可选）添加错误边界处理加载失败；\n\n## 4.1 完整示例\n```javascript\nimport { BrowserRouter as Router, Routes, Route } from 'react-router-dom';\nimport { Suspense, lazy } from 'react';\nimport ErrorBoundary from './components/ErrorBoundary';\nimport Loading from './components/Loading'; // 自定义加载组件\n\n// 同步加载核心组件\nimport Header from './components/Header';\nimport Footer from './components/Footer';\n\n// 懒加载路由组件\nconst Home = lazy(() => import('./pages/Home'));\nconst About = lazy(() => import('./pages/About'));\nconst Products = lazy(() => import('./pages/Products'));\nconst NotFound = lazy(() => import('./pages/NotFound'));\n\nfunction App() {\n  return (\n    <Router>\n      <Header />\n      {/* 全局 Suspense：所有懒加载路由共用一个加载占位符 */}\n      <ErrorBoundary fallback={<div>Oops! Something went wrong.</div>}>\n        <Suspense fallback={<Loading />}>\n          <Routes>\n            <Route path=\"/\" element={<Home />} />\n            <Route path=\"/about\" element={<About />} />\n            <Route path=\"/products/*\" element={<Products />} />\n            <Route path=\"*\" element={<NotFound />} />\n          </Routes>\n        </Suspense>\n      </ErrorBoundary>\n      <Footer />\n    </Router>\n  );\n}\n```\n\n# 5. 代码分割的进阶优化\n## 5.1 预加载（Preloading）\n在用户可能访问的路由（如 hover 导航链接时）提前加载代码块，提升用户体验：\n```javascript\nconst About = React.lazy(() => import('./pages/About'));\n\nfunction NavLink() {\n  const handleHover = () => {\n    // 预加载 About 组件代码块\n    import('./pages/About');\n  };\n\n  return (\n    <a href=\"/about\" onMouseEnter={handleHover}>\n      About\n    </a>\n  );\n}\n```\n\n## 5.2 公共代码提取\n通过打包工具（Webpack）提取多个 chunk 共享的代码（如 React、React DOM）为公共 chunk，避免重复加载：\n```javascript\n// webpack.config.js\nmodule.exports = {\n  optimization: {\n    splitChunks: {\n      chunks: 'all', // 提取所有 chunk 的公共代码\n      cacheGroups: {\n        vendor: {\n          test: /[\\\\/]node_modules[\\\\/]/, // 匹配 node_modules 中的依赖\n          name: 'vendors', // 公共 chunk 名称\n          priority: -10 // 优先级\n        }\n      }\n    }\n  }\n};\n```\n\n## 5.3 动态导入的魔法注释（Webpack 专属）\n通过魔法注释自定义 chunk 名称、设置预加载等：\n```javascript\nconst About = React.lazy(() => \n  import(/* webpackChunkName: \"about-page\" */ './pages/About')\n);\n\n// 预加载 chunk（webpackPrefetch: true）\nconst Products = React.lazy(() => \n  import(/* webpackChunkName: \"products-page\", webpackPrefetch: true */ './pages/Products')\n);\n```\n- `webpackChunkName`：自定义 chunk 名称（便于调试）；\n- `webpackPrefetch`：在浏览器空闲时预加载 chunk；\n- `webpackPreload`：与当前 chunk 并行加载（适用于立即需要的 chunk）。\n\n# 6. 注意事项\n1. **不要过度分割**：过小的 chunk 会增加 HTTP 请求数量（HTTP/1.1 下），建议按路由/大型功能模块分割；\n2. **HTTP/2 支持**：HTTP/2 支持多路复用，可优化多 chunk 加载性能，建议配合使用；\n3. **服务端渲染（SSR）**：React.lazy 不支持 SSR，需使用 `loadable-components` 替代；\n4. **加载状态设计**：fallback 占位符应简洁（如骨架屏），避免加载过程中出现布局偏移（CLS）。\n\n# 7. 替代方案：loadable-components\n若项目需要 SSR 支持或更灵活的懒加载控制，可使用第三方库 `@loadable/component`：\n```bash\nnpm install @loadable/component\n```\n\n```javascript\nimport loadable from '@loadable/component';\nimport Loading from './components/Loading';\n\n// 懒加载组件（支持 SSR）\nconst About = loadable(() => import('./pages/About'), {\n  fallback: <Loading />\n});\n```","directory_id":"46554425-2ee6-405b-b46c-7720d50c48ec","is_published":true,"created_at":"2025-12-22 03:15:15.281929+00","updated_at":"2025-12-23 09:34:05.084227+00"},{"id":"602ea56d-4786-4a58-bb2a-cb6eb7f1d9c9","title":"受控表单","content":"# 1. 受控表单的核心概念\nReact 中的**受控表单**是指表单元素的值由 React 组件状态（`state`）完全控制，表单元素的更新（如输入、选择）会同步修改状态，状态变化后又会反向更新表单元素的显示值。这种“状态-视图”双向绑定的模式，让表单数据的管理更可控、可预测，是 React 表单处理的推荐方式。\n\n## 核心特征\n- 表单元素的值绑定到组件 `state`；\n- 通过 `onChange` 事件监听表单元素的变化，同步更新 `state`；\n- 表单元素的显示值始终与 `state` 保持一致；\n- 可直接通过修改 `state` 控制表单元素（如重置、预填）。\n\n# 2. 常见表单元素的受控实现\n## 2.1 文本输入框（input[type=\"text\"]）\n最基础的受控表单元素，通过 `value` 绑定状态，`onChange` 同步输入内容。\n\n```javascript\nimport { useState } from 'react';\n\nfunction TextInput() {\n  // 初始化状态，绑定输入框值\n  const [username, setUsername] = useState('');\n\n  // 监听输入变化，同步更新状态\n  const handleUsernameChange = (e) => {\n    setUsername(e.target.value);\n  };\n\n  // 表单提交处理\n  const handleSubmit = (e) => {\n    e.preventDefault(); // 阻止默认表单提交行为\n    console.log('提交的用户名：', username);\n    // 后续逻辑：接口请求、数据处理等\n  };\n\n  return (\n    <form onSubmit={handleSubmit}>\n      <div>\n        <label>用户名：</label>\n        {/* value 绑定 state，onChange 绑定事件 */}\n        <input\n          type=\"text\"\n          value={username}\n          onChange={handleUsernameChange}\n          placeholder=\"请输入用户名\"\n        />\n      </div>\n      <button type=\"submit\">提交</button>\n    </form>\n  );\n}\n```\n\n## 2.2 密码框（input[type=\"password\"]）\n与文本输入框逻辑一致，仅 `type` 属性不同。\n\n```javascript\nfunction PasswordInput() {\n  const [password, setPassword] = useState('');\n\n  const handlePasswordChange = (e) => {\n    setPassword(e.target.value);\n  };\n\n  const handleSubmit = (e) => {\n    e.preventDefault();\n    console.log('提交的密码：', password);\n  };\n\n  return (\n    <form onSubmit={handleSubmit}>\n      <div>\n        <label>密码：</label>\n        <input\n          type=\"password\"\n          value={password}\n          onChange={handlePasswordChange}\n          placeholder=\"请输入密码\"\n        />\n      </div>\n      <button type=\"submit\">提交</button>\n    </form>\n  );\n}\n```\n\n## 2.3 单选按钮（input[type=\"radio\"]）\n多个单选按钮需绑定同一个状态，通过 `name` 属性分组，`value` 属性区分选项，选中时同步状态为对应 `value`。\n\n```javascript\nfunction RadioGroup() {\n  // 初始化状态（默认选中“male”）\n  const [gender, setGender] = useState('male');\n\n  const handleGenderChange = (e) => {\n    setGender(e.target.value);\n  };\n\n  const handleSubmit = (e) => {\n    e.preventDefault();\n    console.log('选择的性别：', gender);\n  };\n\n  return (\n    <form onSubmit={handleSubmit}>\n      <div>\n        <label>性别：</label>\n        <input\n          type=\"radio\"\n          name=\"gender\" // 同一组单选按钮 name 必须一致\n          value=\"male\"\n          checked={gender === 'male'} // 绑定选中状态\n          onChange={handleGenderChange}\n        />\n        <span>男</span>\n        <input\n          type=\"radio\"\n          name=\"gender\"\n          value=\"female\"\n          checked={gender === 'female'}\n          onChange={handleGenderChange}\n        />\n        <span>女</span>\n      </div>\n      <button type=\"submit\">提交</button>\n    </form>\n  );\n}\n```\n\n## 2.4 复选框（input[type=\"checkbox\"]）\n复选框分两种场景：单个复选框（布尔值）、多个复选框（数组存储选中值）。\n\n### 场景 1：单个复选框（如“同意协议”）\n```javascript\nfunction SingleCheckbox() {\n  const [agreed, setAgreed] = useState(false); // 布尔值状态\n\n  const handleAgreeChange = (e) => {\n    setAgreed(e.target.checked); // 绑定 checked 属性\n  };\n\n  const handleSubmit = (e) => {\n    e.preventDefault();\n    console.log('是否同意协议：', agreed);\n  };\n\n  return (\n    <form onSubmit={handleSubmit}>\n      <div>\n        <input\n          type=\"checkbox\"\n          id=\"agree\"\n          checked={agreed}\n          onChange={handleAgreeChange}\n        />\n        <label htmlFor=\"agree\">我已阅读并同意用户协议</label>\n      </div>\n      {/* 未同意时禁用提交按钮 */}\n      <button type=\"submit\" disabled={!agreed}>提交</button>\n    </form>\n  );\n}\n```\n\n### 场景 2：多个复选框（如“兴趣爱好”）\n```javascript\nfunction MultiCheckbox() {\n  // 兴趣选项数据\n  const hobbies = [\n    { id: 'sports', name: '运动' },\n    { id: 'reading', name: '阅读' },\n    { id: 'coding', name: '编程' },\n    { id: 'music', name: '音乐' }\n  ];\n  // 数组状态存储选中的兴趣 ID\n  const [selectedHobbies, setSelectedHobbies] = useState([]);\n\n  const handleHobbyChange = (e) => {\n    const hobbyId = e.target.value;\n    // 判断当前选项是否已选中，更新数组\n    if (selectedHobbies.includes(hobbyId)) {\n      // 已选中：从数组中移除\n      setSelectedHobbies(selectedHobbies.filter(id => id !== hobbyId));\n    } else {\n      // 未选中：添加到数组\n      setSelectedHobbies([...selectedHobbies, hobbyId]);\n    }\n  };\n\n  const handleSubmit = (e) => {\n    e.preventDefault();\n    console.log('选择的兴趣：', selectedHobbies);\n    // 映射为中文名称（可选）\n    const selectedNames = hobbies\n      .filter(hobby => selectedHobbies.includes(hobby.id))\n      .map(hobby => hobby.name);\n    console.log('兴趣名称：', selectedNames);\n  };\n\n  return (\n    <form onSubmit={handleSubmit}>\n      <div>\n        <label>兴趣爱好：</label>\n        {hobbies.map((hobby) => (\n          <div key={hobby.id}>\n            <input\n              type=\"checkbox\"\n              id={hobby.id}\n              value={hobby.id}\n              // 判断是否选中\n              checked={selectedHobbies.includes(hobby.id)}\n              onChange={handleHobbyChange}\n            />\n            <label htmlFor={hobby.id}>{hobby.name}</label>\n          </div>\n        ))}\n      </div>\n      <button type=\"submit\">提交</button>\n    </form>\n  );\n}\n```\n\n## 2.5 下拉选择框（select）\n分为单选下拉框和多选下拉框，通过 `value` 绑定状态，`onChange` 同步选中值。\n\n### 场景 1：单选下拉框\n```javascript\nfunction SingleSelect() {\n  // 选项数据\n  const cities = [\n    { id: 'beijing', name: '北京' },\n    { id: 'shanghai', name: '上海' },\n    { id: 'guangzhou', name: '广州' },\n    { id: 'shenzhen', name: '深圳' }\n  ];\n  // 初始化状态（默认选中“beijing”）\n  const [selectedCity, setSelectedCity] = useState('beijing');\n\n  const handleCityChange = (e) => {\n    setSelectedCity(e.target.value);\n  };\n\n  const handleSubmit = (e) => {\n    e.preventDefault();\n    console.log('选择的城市：', selectedCity);\n  };\n\n  return (\n    <form onSubmit={handleSubmit}>\n      <div>\n        <label>城市：</label>\n        <select value={selectedCity} onChange={handleCityChange}>\n          {cities.map((city) => (\n            <option key={city.id} value={city.id}>\n              {city.name}\n            </option>\n          ))}\n        </select>\n      </div>\n      <button type=\"submit\">提交</button>\n    </form>\n  );\n}\n```\n\n### 场景 2：多选下拉框（multiple）\n需给 `select` 添加 `multiple` 属性，状态为数组类型。\n\n```javascript\nfunction MultiSelect() {\n  const fruits = [\n    { id: 'apple', name: '苹果' },\n    { id: 'banana', name: '香蕉' },\n    { id: 'orange', name: '橙子' },\n    { id: 'grape', name: '葡萄' }\n  ];\n  // 数组状态存储选中的水果 ID\n  const [selectedFruits, setSelectedFruits] = useState([]);\n\n  const handleFruitChange = (e) => {\n    // 多选下拉框的选中值需通过 e.target.selectedOptions 获取\n    const selectedOptions = Array.from(e.target.selectedOptions);\n    const selectedIds = selectedOptions.map(option => option.value);\n    setSelectedFruits(selectedIds);\n  };\n\n  const handleSubmit = (e) => {\n    e.preventDefault();\n    console.log('选择的水果：', selectedFruits);\n  };\n\n  return (\n    <form onSubmit={handleSubmit}>\n      <div>\n        <label>水果（按住 Ctrl 多选）：</label>\n        <select\n          multiple\n          value={selectedFruits}\n          onChange={handleFruitChange}\n          style={{ height: '100px' }} // 调整高度，方便多选\n        >\n          {fruits.map((fruit) => (\n            <option key={fruit.id} value={fruit.id}>\n              {fruit.name}\n            </option>\n          ))}\n        </select>\n      </div>\n      <button type=\"submit\">提交</button>\n    </form>\n  );\n}\n```\n\n## 2.6 文本域（textarea）\n与文本输入框逻辑一致，`value` 绑定状态，`onChange` 同步输入内容（无需手动设置 `rows`/`cols`，可通过 CSS 控制样式）。\n\n```javascript\nfunction TextArea() {\n  const [intro, setIntro] = useState(''); // 初始化为空字符串\n\n  const handleIntroChange = (e) => {\n    setIntro(e.target.value);\n  };\n\n  const handleSubmit = (e) => {\n    e.preventDefault();\n    console.log('个人简介：', intro);\n  };\n\n  return (\n    <form onSubmit={handleSubmit}>\n      <div>\n        <label>个人简介：</label>\n        <textarea\n          value={intro}\n          onChange={handleIntroChange}\n          placeholder=\"请输入个人简介\"\n          style={{ width: '300px', height: '150px' }}\n        />\n      </div>\n      <button type=\"submit\">提交</button>\n    </form>\n  );\n}\n```\n\n# 3. 复杂表单：多字段统一管理\n实际开发中表单通常包含多个字段，可将所有字段状态整合到一个对象中，通过统一的事件处理函数同步更新，简化代码。\n\n```javascript\nimport { useState } from 'react';\n\nfunction ComplexForm() {\n  // 整合所有字段状态到一个对象\n  const [formData, setFormData] = useState({\n    username: '',\n    password: '',\n    gender: 'male',\n    hobbies: [],\n    city: 'beijing',\n    intro: ''\n  });\n\n  // 统一的字段更新函数（通过 name 属性匹配字段）\n  const handleInputChange = (e) => {\n    const { name, value, type, checked } = e.target;\n    // 根据表单元素类型处理值（复选框特殊处理）\n    setFormData(prev => ({\n      ...prev,\n      [name]: type === 'checkbox' ? checked : value\n    }));\n  };\n\n  // 单独处理多复选框（兴趣爱好）\n  const handleHobbyChange = (e) => {\n    const hobbyId = e.target.value;\n    setFormData(prev => ({\n      ...prev,\n      hobbies: prev.hobbies.includes(hobbyId)\n        ? prev.hobbies.filter(id => id !== hobbyId)\n        : [...prev.hobbies, hobbyId]\n    }));\n  };\n\n  const handleSubmit = (e) => {\n    e.preventDefault();\n    console.log('表单提交数据：', formData);\n    // 后续：接口请求、表单重置等\n  };\n\n  // 表单重置（直接修改 state 即可）\n  const handleReset = () => {\n    setFormData({\n      username: '',\n      password: '',\n      gender: 'male',\n      hobbies: [],\n      city: 'beijing',\n      intro: ''\n    });\n  };\n\n  return (\n    <form onSubmit={handleSubmit} style={{ display: 'flex', flexDirection: 'column', gap: '10px' }}>\n      {/* 用户名 */}\n      <div>\n        <label>用户名：</label>\n        <input\n          type=\"text\"\n          name=\"username\" // name 需与 state 字段名一致\n          value={formData.username}\n          onChange={handleInputChange}\n          placeholder=\"请输入用户名\"\n        />\n      </div>\n\n      {/* 密码 */}\n      <div>\n        <label>密码：</label>\n        <input\n          type=\"password\"\n          name=\"password\"\n          value={formData.password}\n          onChange={handleInputChange}\n          placeholder=\"请输入密码\"\n        />\n      </div>\n\n      {/* 性别（单选） */}\n      <div>\n        <label>性别：</label>\n        <input\n          type=\"radio\"\n          name=\"gender\"\n          value=\"male\"\n          checked={formData.gender === 'male'}\n          onChange={handleInputChange}\n        />\n        <span>男</span>\n        <input\n          type=\"radio\"\n          name=\"gender\"\n          value=\"female\"\n          checked={formData.gender === 'female'}\n          onChange={handleInputChange}\n        />\n        <span>女</span>\n      </div>\n\n      {/...","directory_id":"0e360aa6-df1e-4212-b06e-7ebc4541f5d5","is_published":true,"created_at":"2025-12-22 03:18:25.47063+00","updated_at":"2025-12-23 12:59:46.897083+00"},{"id":"60790d46-4f56-4f12-87de-9e4098ed8496","title":"Zustand 入门","content":"Zustand 是一款轻量级 React 状态管理库，以“简洁 API、无 Provider 嵌套、高性能”为核心优势，相比 Redux 更易上手，相比 Context API 更高效，适合中小型项目及需要灵活状态管理的场景。本文将从基础入门，带你掌握 Zustand 的核心使用流程。\n\n# 1. 环境准备：安装 Zustand\n## 1.1 基本安装\n通过 npm/yarn/pnpm 安装核心依赖（支持 React 16.8+）：\n```bash\nnpm\nnpm install zustand\n\nyarn\nyarn add zustand\n\npnpm\npnpm add zustand\n```\n\n## 1.2 可选依赖（按需安装）\n- 类型提示：Zustand 原生支持 TypeScript，无需额外依赖；\n- 持久化：需安装 `zustand/middleware`（内置持久化中间件）；\n- 开发工具：需安装 Redux DevTools 扩展（支持 Zustand 状态调试）。\n\n# 2. 核心概念：Store\nStore 是 Zustand 中存储状态的容器，本质是一个包含“状态数据”和“修改状态的方法”的对象。通过 `create` 函数创建 Store，整个应用可创建多个独立 Store（无需全局统一管理）。\n\n## 2.1 创建第一个 Store\n新建 `stores/counterStore.js`（或 `.ts`）文件，通过 `create` 函数定义 Store：\n```jsx\n// stores/counterStore.js\nimport { create } from 'zustand';\n\n// 创建 Store：参数为一个函数，返回 { 状态, 状态修改方法 }\nconst useCounterStore = create((set) => ({\n  // 1. 定义状态\n  count: 0,\n  username: 'Zustand 新手',\n\n  // 2. 定义修改状态的方法（通过 set 函数更新状态）\n  increment: () => set((state) => ({ count: state.count + 1 })), // 函数式更新（依赖旧状态）\n  decrement: () => set((state) => ({ count: state.count - 1 })),\n  setUsername: (newName) => set({ username: newName }), // 直接更新（不依赖旧状态）\n  reset: () => set({ count: 0, username: 'Zustand 新手' }), // 批量更新多个状态\n}));\n\nexport default useCounterStore;\n```\n\n### 2.2 关键说明\n- `create` 函数：接收一个“初始化函数”，返回一个自定义 Hook（如 `useCounterStore`），组件通过该 Hook 访问 Store；\n- `set` 函数：用于修改状态，支持两种写法：\n  - 直接传递新状态对象：`set({ key: newValue })`（适用于不依赖旧状态的场景）；\n  - 传递函数：`set((state) => ({ key: state.key + 1 }))`（适用于依赖旧状态的场景，避免竞态问题）；\n- Store 独立隔离：每个 `create` 调用创建一个独立 Store，互不影响（支持按业务模块拆分 Store）。\n\n## 2.2 组件中使用 Store：useStore 用法\n组件通过自定义 Hook（如 `useCounterStore`）访问 Store，支持“获取单个状态”“获取多个状态”“调用状态修改方法”三种核心场景。\n\n### 场景 1：获取单个状态（推荐，性能最优）\n通过 `useStore((state) => state.xxx)` 精准获取单个状态，Zustand 会自动优化重渲染（仅当该状态变化时，组件才重渲染）：\n```jsx\n// components/Counter.jsx\nimport useCounterStore from '../stores/counterStore';\n\nexport default function Counter() {\n  // 获取单个状态：仅当 count 变化时，组件重渲染\n  const count = useCounterStore((state) => state.count);\n  const username = useCounterStore((state) => state.username);\n\n  return (\n    <div>\n      <h2>用户名：{username}</h2>\n      <p>当前计数：{count}</p>\n    </div>\n  );\n}\n```\n\n### 场景 2：获取多个状态（避免多次调用 useStore）\n若需获取多个状态，可通过“选择器函数返回对象”的方式，但需配合 `shallow` 比较（否则组件会因对象引用变化而频繁重渲染）：\n```jsx\nimport { shallow } from 'zustand/shallow';\nimport useCounterStore from '../stores/counterStore';\n\nexport default function Counter() {\n  // 方式 1：使用 shallow 比较（推荐）\n  const { count, username } = useCounterStore(\n    (state) => ({ count: state.count, username: state.username }),\n    shallow // 浅层比较：仅当 count 或 username 实际变化时重渲染\n  );\n\n  // 方式 2：分多次调用 useStore（性能等价，写法更简洁）\n  // const count = useCounterStore((state) => state.count);\n  // const username = useCounterStore((state) => state.username);\n\n  return (\n    <div>\n      <h2>用户名：{username}</h2>\n      <p>当前计数：{count}</p>\n    </div>\n  );\n}\n```\n\n### 场景 3：调用 Store 中的方法（修改状态）\n直接通过 `useStore` 获取 Store 中的方法，调用后自动更新状态并触发依赖组件重渲染：\n```jsx\nimport useCounterStore from '../stores/counterStore';\n\nexport default function Counter() {\n  const count = useCounterStore((state) => state.count);\n  // 获取状态修改方法\n  const increment = useCounterStore((state) => state.increment);\n  const decrement = useCounterStore((state) => state.decrement);\n  const setUsername = useCounterStore((state) => state.setUsername);\n  const reset = useCounterStore((state) => state.reset);\n\n  return (\n    <div>\n      <h2>用户名：{useCounterStore((state) => state.username)}</h2>\n      <p>当前计数：{count}</p>\n      <button onClick={increment}>+1</button>\n      <button onClick={decrement}>-1</button>\n      <button onClick={() => setUsername('Zustand 高手')}>修改用户名</button>\n      <button onClick={reset}>重置</button>\n    </div>\n  );\n}\n```\n\n### 场景 4：获取整个 Store（不推荐，性能较差）\n直接调用 `useStore()` 可获取整个 Store 对象，但组件会因 Store 中任意状态变化而重渲染，仅适用于调试或简单场景：\n```jsx\nconst store = useCounterStore();\nconsole.log(store.count); // 访问状态\nstore.increment(); // 调用方法\n```\n\n# 3. 入门关键注意事项\n1. **无需 Provider 包裹**：Zustand 不依赖 React Context，创建 Store 后可直接在任意组件中使用，无需像 Redux/Context 那样包裹顶层 Provider；\n2. **重渲染优化**：获取状态时尽量“精准选择单个状态”或使用 `shallow` 比较，避免因无关状态变化导致组件不必要重渲染；\n3. **状态修改的不可变性**：`set` 函数内部会自动处理状态的不可变性（无需手动深拷贝），直接返回新状态即可；\n4. **组件卸载后的状态安全**：若组件卸载后仍有异步操作尝试修改状态，Zustand 会自动忽略，无需手动清理订阅；\n5. **调试支持**：默认支持 Redux DevTools，安装扩展后可直接查看状态变化记录（下文核心特性会详细说明）。\n\n# 4. 入门示例完整代码\n## 4.1 Store 定义（stores/counterStore.js）\n```jsx\nimport { create } from 'zustand';\n\nconst useCounterStore = create((set) => ({\n  count: 0,\n  username: 'Zustand 新手',\n  increment: () => set((state) => ({ count: state.count + 1 })),\n  decrement: () => set((state) => ({ count: state.count - 1 })),\n  setUsername: (newName) => set({ username: newName }),\n  reset: () => set({ count: 0, username: 'Zustand 新手' }),\n}));\n\nexport default useCounterStore;\n```\n\n## 4.2 组件使用（components/Counter.jsx）\n```jsx\nimport { shallow } from 'zustand/shallow';\nimport useCounterStore from '../stores/counterStore';\n\nexport default function Counter() {\n  // 获取状态（浅层比较多个状态）\n  const { count, username } = useCounterStore(\n    (state) => ({ count: state.count, username: state.username }),\n    shallow\n  );\n\n  // 获取方法\n  const { increment, decrement, setUsername, reset } = useCounterStore(\n    (state) => ({\n      increment: state.increment,\n      decrement: state.decrement,\n      setUsername: state.setUsername,\n      reset: state.reset,\n    }),\n    shallow // 方法引用不会变化，可省略 shallow，但加上更规范\n  );\n\n  return (\n    <div style={{ padding: '20px' }}>\n      <h2>Zustand 入门示例</h2>\n      <p>用户名：{username}</p>\n      <p>当前计数：{count}</p>\n      <button onClick={increment} style={{ marginRight: '8px' }}>+1</button>\n      <button onClick={decrement} style={{ marginRight: '8px' }}>-1</button>\n      <button onClick={() => setUsername('Zustand 高手')} style={{ marginRight: '8px' }}>\n        修改用户名\n      </button>\n      <button onClick={reset}>重置</button>\n    </div>\n  );\n}\n```","directory_id":"ed2cdaf2-c966-4d9f-bfad-740b9f352c61","is_published":true,"created_at":"2025-12-22 03:10:22.068941+00","updated_at":"2025-12-23 03:11:05.21255+00"},{"id":"622728a4-0cb0-49e1-b9ae-1c891dea8d91","title":"React Query/SWR","content":"# 1. 核心价值：替代传统数据管理方案\n传统 React 项目中，数据请求需手动处理「加载状态、缓存、刷新、错误处理」，代码冗余且易出错。React Query（现更名为 TanStack Query）和 SWR（Next.js 团队开发）是专注于**服务端状态管理**的库，核心优势：\n- 自动缓存：相同请求数据缓存，避免重复请求；\n- 智能刷新：后台静默刷新、窗口聚焦刷新、定时刷新；\n- 状态管理：内置加载/错误/成功状态，无需手动维护 `useState`；\n- 乐观更新：先更新 UI 再同步接口，提升用户体验；\n- 分页/无限滚动：简化列表数据加载逻辑；\n- 与 Axios 无缝集成：复用已封装的接口请求。\n\n# 2. 选型对比：React Query vs SWR\n| 特性                | React Query（TanStack Query）                | SWR（Stale-While-Revalidate）                |\n|---------------------|----------------------------------------------|----------------------------------------------|\n| 核心理念            | 全面的服务端状态管理（缓存、查询、突变）      | 基于「陈旧数据可用 + 后台刷新」策略           |\n| API 设计            | 更丰富（`useQuery`/`useMutation`/`useInfiniteQuery`） | 更简洁（`useSWR` 一站式处理查询与突变）       |\n| 缓存机制            | 多维度缓存（键、标签、失效时间）              | 基于键的简单缓存，支持自定义重新验证          |\n| 功能丰富度          | 极高（分页、无限滚动、预取、查询失效）        | 轻量（核心功能完善，扩展需自定义）            |\n| 学习成本            | 中（API 较多，配置项丰富）                    | 低（API 简洁，上手快）                        |\n| 适用场景            | 复杂中后台系统（多列表、多筛选、频繁更新）    | 中小型项目、Next.js 生态项目（原生支持）      |\n| 体积                | 稍大（核心包 ~15KB）                          | 极小（~5KB）                                  |\n\n# 3. React Query 实战（推荐中后台项目）\n## 3.1 环境搭建\n```bash\nnpm install @tanstack/react-query @tanstack/react-query-devtools # 安装核心依赖（React Query v5+）\n\nnpm install @tanstack/react-query-persist-client # 如需分页/无限滚动，安装扩展\n```\n\n## 3.2 步骤 1：全局配置（src/providers/QueryProvider.tsx）\n```tsx\nimport React from 'react';\nimport { QueryClient, QueryClientProvider } from '@tanstack/react-query';\nimport { ReactQueryDevtools } from '@tanstack/react-query-devtools'; // 调试工具\n\n// 创建 QueryClient 实例（配置全局缓存策略）\nconst queryClient = new QueryClient({\n  defaultOptions: {\n    queries: {\n      staleTime: 5 * 60 * 1000, // 数据 5 分钟内视为“新鲜”，不重新请求\n      cacheTime: 30 * 60 * 1000, // 缓存保留 30 分钟\n      refetchOnWindowFocus: true, // 窗口聚焦时刷新数据（开发环境推荐开启）\n      refetchOnReconnect: true, // 网络重连时刷新数据\n      retry: 1, // 请求失败后重试 1 次\n      retryDelay: (attemptIndex) => {\n        return attemptIndex * 1000; // 重试延迟（1s、2s、...）\n      },\n    },\n  },\n});\n\n// 全局 Provider 组件\nexport const QueryProvider = ({ children }: { children: React.ReactNode }) => {\n  return (\n    <QueryClientProvider client={queryClient}>\n      {children}\n      {/* 开发环境显示调试工具（默认在右下角） */}\n      {process.env.NODE_ENV === 'development' && <ReactQueryDevtools />}\n    </QueryClientProvider>\n  );\n};\n```\n\n在入口文件中包裹：\n```tsx\n// src/main.tsx\nimport React from 'react';\nimport ReactDOM from 'react-dom/client';\nimport { QueryProvider } from './providers/QueryProvider';\nimport App from './App';\n\nconst root = ReactDOM.createRoot(document.getElementById('root')!);\nroot.render(\n  <QueryProvider>\n    <App />\n  </QueryProvider>\n);\n```\n\n## 3.3 步骤 2：基础查询（useQuery）\n用于获取数据（GET 请求），自动管理加载/错误/成功状态：\n```tsx\nimport React from 'react';\nimport { useQuery } from '@tanstack/react-query';\nimport { getUserList, User } from '@/api/modules/user';\nimport { Table, Spin, Alert } from 'antd';\n\n// 定义查询键（必须是数组，用于缓存标识）\nconst USER_LIST_QUERY_KEY = ['userList'];\n\nconst UserList = () => {\n  // 调用接口（useQuery 接收查询键 + 异步函数）\n  const { data, isLoading, isError, error, refetch } = useQuery({\n    queryKey: USER_LIST_QUERY_KEY, // 缓存键（相同键复用缓存）\n    queryFn: () => getUserList({ page: 1, pageSize: 10 }), // 异步请求函数\n    // 额外配置（覆盖全局默认值）\n    staleTime: 10 * 60 * 1000, // 10 分钟新鲜期\n    enabled: true, // 是否自动触发查询（默认 true，可通过条件控制）\n  });\n\n  // 加载状态\n  if (isLoading) return <Spin size=\"large\" tip=\"加载中...\" />;\n\n  // 错误状态\n  if (isError) return <Alert message=\"加载失败\" description={(error as Error).message} type=\"error\" />;\n\n  return (\n    <div>\n      <Table\n        dataSource={data?.list}\n        columns={[\n          { title: 'ID', dataIndex: 'id' },\n          { title: '姓名', dataIndex: 'name' },\n          { title: '年龄', dataIndex: 'age' },\n        ]}\n        rowKey=\"id\"\n        pagination={{ total: data?.total }}\n      />\n      {/* 手动刷新按钮 */}\n      <button onClick={() => refetch()} style={{ marginTop: 16 }}>\n        手动刷新\n      </button>\n    </div>\n  );\n};\n\nexport default UserList;\n```\n\n## 3.4 步骤 3：带参数查询（动态查询键）\n查询键支持动态值（如分页参数、筛选条件），不同参数对应不同缓存：\n```tsx\nconst UserListWithParams = () => {\n  const [page, setPage] = React.useState(1);\n  const pageSize = 10;\n\n  // 动态查询键：[查询名, 分页参数, 筛选参数]\n  const { data, isLoading, isError } = useQuery({\n    queryKey: ['userList', page, pageSize], // 不同 page 对应不同缓存\n    queryFn: () => getUserList({ page, pageSize }),\n  });\n\n  return (\n    <div>\n      <Table\n        dataSource={data?.list}\n        columns={/* 列定义 */}\n        pagination={{\n          current: page,\n          pageSize,\n          total: data?.total,\n          onChange: (newPage) => setPage(newPage), // 分页切换更新 page\n        }}\n      />\n    </div>\n  );\n};\n```\n\n## 3.5 步骤 4：数据突变（useMutation）\n用于修改数据（POST/PUT/DELETE 请求），支持乐观更新、缓存更新：\n```tsx\nimport React from 'react';\nimport { useMutation, useQueryClient } from '@tanstack/react-query';\nimport { addUser, getUserList } from '@/api/modules/user';\nimport { Button, Form, Input, message } from 'antd';\n\nconst AddUserForm = () => {\n  const [form] = Form.useForm();\n  // 获取 QueryClient 实例（用于更新缓存）\n  const queryClient = useQueryClient();\n\n  // 定义突变（修改数据的操作）\n  const addUserMutation = useMutation({\n    mutationFn: (userData: { name: string; age: number }) => addUser(userData), // 异步修改函数\n    // 成功回调：更新缓存 + 提示\n    onSuccess: () => {\n      message.success('添加用户成功');\n      form.resetFields();\n      // 方法 1：使 userList 缓存失效，触发重新请求\n      queryClient.invalidateQueries({ queryKey: ['userList'] });\n      // 方法 2：乐观更新（不等待接口响应，直接更新缓存）\n      // queryClient.setQueryData(['userList'], (oldData) => {\n      //   return {\n      //     ...oldData,\n      //     list: [...oldData.list, newUser],\n      //     total: oldData.total + 1,\n      //   };\n      // });\n    },\n    // 失败回调\n    onError: (error) => {\n      message.error(`添加失败：${(error as Error).message}`);\n    },\n  });\n\n  const handleSubmit = (values: { name: string; age: number }) => {\n    // 触发突变\n    addUserMutation.mutate(values);\n  };\n\n  return (\n    <Form form={form} onFinish={handleSubmit} layout=\"inline\">\n      <Form.Item name=\"name\" rules={[{ required: true, message: '请输入姓名' }]}>\n        <Input placeholder=\"姓名\" />\n      </Form.Item>\n      <Form.Item name=\"age\" rules={[{ required: true, message: '请输入年龄' }]}>\n        <Input type=\"number\" placeholder=\"年龄\" />\n      </Form.Item>\n      <Form.Item>\n        <Button\n          type=\"primary\"\n          htmlType=\"submit\"\n          loading={addUserMutation.isPending} // 突变加载状态\n        >\n          添加用户\n        </Button>\n      </Form.Item>\n    </Form>\n  );\n};\n\nexport default AddUserForm;\n```\n\n## 3.6 步骤 5：无限滚动（useInfiniteQuery）\n简化分页列表的无限滚动逻辑：\n```tsx\nimport React, { useRef, useEffect } from 'react';\nimport { useInfiniteQuery } from '@tanstack/react-query';\nimport { getUserList } from '@/api/modules/user';\nimport { List, Spin, message } from 'antd';\n\nconst InfiniteUserList = () => {\n  const loadMoreRef = useRef<HTMLDivElement>(null);\n\n  // 无限查询\n  const {\n    data,\n    isLoading,\n    isError,\n    fetchNextPage,\n    hasNextPage,\n    isFetchingNextPage,\n  } = useInfiniteQuery({\n    queryKey: ['infiniteUserList'],\n    // queryFn 接收 pageParam（分页参数，初始为 1）\n    queryFn: ({ pageParam = 1 }) => getUserList({ page: pageParam, pageSize: 10 }),\n    // 提取下一页参数（判断是否还有更多数据）\n    getNextPageParam: (lastPage, allPages) => {\n      const totalPages = Math.ceil(lastPage.total / 10);\n      const nextPage = allPages.length + 1;\n      return nextPage <= totalPages ? nextPage : undefined;\n    },\n  });\n\n  // 滚动监听：触底加载下一页\n  useEffect(() => {\n    const observer = new IntersectionObserver(\n      (entries) => {\n        if (entries[0].isIntersecting && hasNextPage && !isFetchingNextPage) {\n          fetchNextPage(); // 加载下一页\n        }\n      },\n      { threshold: 0.1 }\n    );\n\n    if (loadMoreRef.current) {\n      observer.observe(loadMoreRef.current);\n    }\n\n    return () => {\n      if (loadMoreRef.current) {\n        observer.unobserve(loadMoreRef.current);\n      }\n    };\n  }, [fetchNextPage, hasNextPage, isFetchingNextPage]);\n\n  // 格式化数据（合并所有页的列表）\n  const userList = data?.pages.flatMap((page) => page.list) || [];\n\n  if (isLoading) return <Spin tip=\"加载中...\" />;\n  if (isError) return <div>加载失败</div>;\n\n  return (\n    <List\n      dataSource={userList}\n      renderItem={(user) => <List.Item>{`${user.name}（${user.age}岁）`}</List.Item>}\n      loadMore={\n        hasNextPage && (\n          <div ref={loadMoreRef} style={{ textAlign: 'center', padding: 16 }}>\n            {isFetchingNextPage ? <Spin size=\"small\" /> : '加载更多'}\n          </div>\n        )\n      }\n    />\n  );\n};\n\nexport default InfiniteUserList;\n```\n\n# 4. SWR 实战（推荐轻量项目/Next.js）\n## 4.1 环境搭建\n```bash\nnpm install swr axios\n```\n\n## 4.2 步骤 1：全局配置（src/providers/SWRProvider.tsx）\n```tsx\nimport React from 'react';\nimport { SWRConfig } from 'swr';\nimport axios from '@/api'; // 复用已封装的 Axios 实例\n\n// 自定义请求函数（适配 Axios）\nconst fetcher = async <T = any>(url: string, params?: any): Promise<T> => {\n  const response = await axios.get(url, { params });\n  return response;\n};\n\nexport const SWRProvider = ({ children }: { children: React.ReactNode }) => {\n  return (\n    <SWRConfig\n      value={{\n        fetcher, // 全局请求函数\n        revalidateOnFocus: true, // 窗口聚焦刷新\n        revalidateOnReconnect: true, // 网络重连刷新\n        dedupingInterval: 5 * 60 * 1000, // 5 分钟内相同请求去重\n        revalidateIfStale: true, // 数据陈旧时后台刷新\n      }}\n    >\n      {children}\n    </SWRConfig>\n  );\n};\n```\n\n## 4.3 步骤 2：基础查询（useSWR）\n```tsx\nimport React from 'react';\nimport useSWR from 'swr';\nimport { User } from '@/api/modules/user';\nimport { Table, Spin, Alert } from 'antd';\n\n// 查询键（字符串或数组，支持动态参数）\nconst USER_LIST_KEY = '/user/list';\n\nconst UserList = () => {\n  // 带参数查询：键为数组 [url, params]\n  const { data, error, isLoading, mutate } = useSWR([USER_LIST_KEY, { page: 1, pageSize: 10 }]);\n\n  // 加载状态\n  if (isLoading) return <Spin tip=\"加载中...\" />;\n  // 错误状态\n  if (error) return <Alert message=\"加载失败\" description={(error as Error).message} type=\"error\" />;\n\n  return (\n    <div>\n      <Table\n        dataSource={data?.list}\n        columns={[\n          { title: 'ID', dataIndex: 'id' },\n          { title: '姓名', dataIndex: 'name' },\n          { title: '年龄', dataIndex: 'age' },\n        ]}\n        rowKey=...","directory_id":"f6ecfee0-71f1-4926-96ee-892bbcebe758","is_published":true,"created_at":"2025-12-22 03:21:47.107922+00","updated_at":"2025-12-23 14:22:55.069819+00"},{"id":"62a85f30-d17a-425b-a7f3-f1eadf226b9b","title":"Formik + Yup 表单方案","content":"# 1. Formik + Yup 核心优势\nFormik 是一款成熟的 React 表单状态管理库，专注于解决表单的“脏活累活”（状态同步、验证、提交处理）；Yup 是一款声明式的 Schema 校验库，用于定义表单验证规则。两者结合可实现：\n- **完整的表单状态管理**：自动处理 `values`、`errors`、`touched`、`isSubmitting` 等状态；\n- **声明式验证规则**：通过 Yup Schema 定义验证规则，无需手写大量条件判断；\n- **灵活的验证时机**：支持 onChange、onBlur、onSubmit 等验证时机；\n- **良好的生态兼容**：支持 React Native、第三方 UI 库（Ant Design、Material UI）；\n- **丰富的辅助方法**：内置表单提交、重置、字段更新等方法。\n\n# 2. 基础安装与配置\n```bash\nnpm install formik yup\n\nyarn add formik yup\n```\n\n# 3. 核心概念与 API\n## 3.1 Formik 组件/Hook 两种使用方式\nFormik 支持两种使用方式：组件包裹式（`<Formik>` + `<Form>`）和 Hook 式（`useFormik`），推荐组件式（更简洁）。\n\n### 方式 1：组件包裹式（基础示例）\n```javascript\nimport { Formik, Form, Field, ErrorMessage } from 'formik';\nimport * as Yup from 'yup';\n\nfunction BasicFormikForm() {\n  // 1. 定义 Yup 验证 Schema\n  const validationSchema = Yup.object({\n    username: Yup.string()\n      .required('用户名不能为空')\n      .min(3, '用户名长度不能少于 3 位')\n      .max(10, '用户名长度不能超过 10 位'),\n    password: Yup.string()\n      .required('密码不能为空')\n      .min(6, '密码长度不能少于 6 位')\n  });\n\n  return (\n    <Formik\n      initialValues={{ username: '', password: '' }} // 初始值\n      validationSchema={validationSchema} // 验证规则\n      onSubmit={(values, { setSubmitting }) => {\n        // 提交逻辑\n        setTimeout(() => {\n          console.log('表单数据：', values);\n          setSubmitting(false); // 结束提交状态\n        }, 1000);\n      }}\n    >\n      {({ isSubmitting }) => (\n        <Form>\n          {/* 用户名字段 */}\n          <div>\n            <label>用户名：</label>\n            <Field name=\"username\" type=\"text\" placeholder=\"请输入用户名\" />\n            <ErrorMessage name=\"username\" component=\"span\" style={{ color: 'red' }} />\n          </div>\n\n          {/* 密码字段 */}\n          <div>\n            <label>密码：</label>\n            <Field name=\"password\" type=\"password\" placeholder=\"请输入密码\" />\n            <ErrorMessage name=\"password\" component=\"span\" style={{ color: 'red' }} />\n          </div>\n\n          {/* 提交按钮（禁用提交中状态） */}\n          <button type=\"submit\" disabled={isSubmitting}>\n            {isSubmitting ? '提交中...' : '提交'}\n          </button>\n        </Form>\n      )}\n    </Formik>\n  );\n}\n```\n\n### 方式 2：Hook 式（useFormik）\n```javascript\nimport { useFormik } from 'formik';\nimport * as Yup from 'yup';\n\nfunction UseFormikForm() {\n  // 初始化 Formik 实例\n  const formik = useFormik({\n    initialValues: { username: '', password: '' },\n    validationSchema: Yup.object({\n      username: Yup.string().required('用户名不能为空').min(3, '长度≥3'),\n      password: Yup.string().required('密码不能为空').min(6, '长度≥6')\n    }),\n    onSubmit: (values) => {\n      console.log('提交数据：', values);\n    }\n  });\n\n  return (\n    <form onSubmit={formik.handleSubmit}>\n      <div>\n        <label>用户名：</label>\n        <input\n          name=\"username\"\n          type=\"text\"\n          value={formik.values.username}\n          onChange={formik.handleChange}\n          onBlur={formik.handleBlur}\n          placeholder=\"请输入用户名\"\n        />\n        {/* 显示错误（仅当字段被触碰且有错误时） */}\n        {formik.touched.username && formik.errors.username && (\n          <span style={{ color: 'red' }}>{formik.errors.username}</span>\n        )}\n      </div>\n\n      <div>\n        <label>密码：</label>\n        <input\n          name=\"password\"\n          type=\"password\"\n          value={formik.values.password}\n          onChange={formik.handleChange}\n          onBlur={formik.handleBlur}\n          placeholder=\"请输入密码\"\n        />\n        {formik.touched.password && formik.errors.password && (\n          <span style={{ color: 'red' }}>{formik.errors.password}</span>\n        )}\n      </div>\n\n      <button type=\"submit\" disabled={formik.isSubmitting}>提交</button>\n    </form>\n  );\n}\n```\n\n## 3.2 核心 API 说明\n| API | 作用 |\n|-----|------|\n| `initialValues` | 表单初始值（对象格式，键为字段名） |\n| `validationSchema` | Yup Schema 验证规则 |\n| `onSubmit` | 表单提交成功回调（参数为表单值） |\n| `handleSubmit` | 表单提交处理函数（绑定到 `<form>` 的 onSubmit） |\n| `handleChange` | 字段变化处理函数（绑定到 input 的 onChange） |\n| `handleBlur` | 字段失焦处理函数（绑定到 input 的 onBlur） |\n| `values` | 当前表单值（对象） |\n| `errors` | 当前表单错误信息（对象） |\n| `touched` | 字段是否被触碰（对象，键为字段名，值为布尔值） |\n| `isSubmitting` | 表单是否正在提交（布尔值） |\n| `resetForm` | 重置表单到初始值（可传入新初始值） |\n\n# 4. Yup Schema 核心语法\nYup 提供了丰富的 Schema 类型和验证方法，支持字符串、数字、布尔值、数组、对象等类型的验证：\n\n## 4.1 基础类型验证\n```javascript\nimport * as Yup from 'yup';\n\n// 字符串验证\nYup.string()\n  .required('必填')\n  .min(3, '最小长度3')\n  .max(10, '最大长度10')\n  .email('邮箱格式错误')\n  .matches(/^1[3-9]\\d{9}$/, '手机号格式错误')\n  .oneOf(['男', '女'], '只能选择男/女');\n\n// 数字验证\nYup.number()\n  .required('必填')\n  .min(18, '最小值18')\n  .max(60, '最大值60')\n  .integer('必须为整数');\n\n// 布尔值验证\nYup.boolean()\n  .required('必填')\n  .oneOf([true], '必须同意协议');\n```\n\n## 4.2 嵌套对象验证\n```javascript\nconst validationSchema = Yup.object({\n  user: Yup.object({\n    name: Yup.string().required('姓名不能为空'),\n    email: Yup.string().email('邮箱格式错误').required('邮箱不能为空')\n  }).required('用户信息不能为空'),\n  address: Yup.object({\n    city: Yup.string().required('城市不能为空'),\n    street: Yup.string().required('街道不能为空')\n  })\n});\n```\n\n## 4.3 数组验证\n```javascript\nconst validationSchema = Yup.object({\n  hobbies: Yup.array()\n    .min(1, '至少选择一个兴趣')\n    .of(Yup.string().oneOf(['sports', 'reading', 'coding'], '无效的兴趣选项'))\n});\n```\n\n## 4.4 条件验证（when）\n根据其他字段的值动态调整验证规则：\n```javascript\nconst validationSchema = Yup.object({\n  isStudent: Yup.boolean(),\n  studentId: Yup.string()\n    .when('isStudent', {\n      is: true, // 当 isStudent 为 true 时\n      then: (schema) => schema.required('学生ID不能为空') // 必须填写学生ID\n    })\n});\n```\n\n# 5. 高级用法\n## 5.1 自定义验证（test）\nYup 支持通过 `test` 方法自定义验证逻辑（同步/异步）：\n```javascript\nconst validationSchema = Yup.object({\n  password: Yup.string()\n    .required('密码不能为空')\n    .min(6, '密码长度≥6'),\n  confirmPassword: Yup.string()\n    .required('确认密码不能为空')\n    .test('password-match', '两次密码不一致', function (value) {\n      // 通过 this.parent 获取其他字段值\n      return value === this.parent.password;\n    })\n});\n```\n\n## 5.2 异步验证\n```javascript\nconst validationSchema = Yup.object({\n  email: Yup.string()\n    .email('邮箱格式错误')\n    .required('邮箱不能为空')\n    .test('email-unique', '该邮箱已被注册', async (value) => {\n      const res = await fetch(`/api/check-email?email=${value}`);\n      const data = await res.json();\n      return data.available;\n    })\n});\n```\n\n## 5.3 与 UI 库集成（以 Ant Design 为例）\n```javascript\nimport { Formik, Form } from 'formik';\nimport * as Yup from 'yup';\nimport { Input, Button, Form, message } from 'antd';\n\nfunction AntdFormikForm() {\n  const validationSchema = Yup.object({\n    username: Yup.string().required('用户名不能为空'),\n    password: Yup.string().required('密码不能为空').min(6, '密码长度≥6')\n  });\n\n  return (\n    <Formik\n      initialValues={{ username: '', password: '' }}\n      validationSchema={validationSchema}\n      onSubmit={(values) => {\n        message.success('提交成功');\n        console.log(values);\n      }}\n    >\n      {({ values, errors, touched, handleChange, handleBlur, isSubmitting }) => (\n        <Form layout=\"vertical\">\n          <Form.Item\n            label=\"用户名\"\n            validateStatus={touched.username && errors.username ? 'error' : ''}\n            help={touched.username && errors.username ? errors.username : ''}\n          >\n            <Input\n              name=\"username\"\n              value={values.username}\n              onChange={handleChange}\n              onBlur={handleBlur}\n              placeholder=\"请输入用户名\"\n            />\n          </Form.Item>\n\n          <Form.Item\n            label=\"密码\"\n            validateStatus={touched.password && errors.password ? 'error' : ''}\n            help={touched.password && errors.password ? errors.password : ''}\n          >\n            <Input.Password\n              name=\"password\"\n              value={values.password}\n              onChange={handleChange}\n              onBlur={handleBlur}\n              placeholder=\"请输入密码\"\n            />\n          </Form.Item>\n\n          <Form.Item>\n            <Button type=\"primary\" htmlType=\"submit\" loading={isSubmitting}>\n              提交\n            </Button>\n          </Form.Item>\n        </Form>\n      )}\n    </Formik>\n  );\n}\n```\n\n## 5.4 表单重置与setFieldValue\n- `resetForm`：重置表单到初始值；\n- `setFieldValue`：手动设置单个字段值；\n- `setFieldTouched`：手动标记字段为已触碰。\n\n```javascript\n<Formik\n  initialValues={{ username: '' }}\n  onSubmit={(values, { resetForm }) => {\n    console.log(values);\n    resetForm(); // 重置表单\n  }}\n>\n  {({ setFieldValue, setFieldTouched }) => (\n    <Form>\n      <Field name=\"username\" />\n      <button type=\"button\" onClick={() => setFieldValue('username', '默认值')}>\n        设置默认值\n      </button>\n      <button type=\"button\" onClick={() => setFieldTouched('username', true)}>\n        标记为已触碰\n      </button>\n      <button type=\"submit\">提交</button>\n    </Form>\n  )}\n</Formik>\n```\n\n# 6. Formik vs React Hook Form 对比\n| 特性 | Formik | React Hook Form |\n|------|--------|-----------------|\n| 设计理念 | 受控表单 + 完整状态管理 | 非受控表单 + 原生验证 |\n| 体积 | 约 18KB（gzip） | 约 10KB（gzip） |\n| 性能 | 中等（受控表单可能频繁重渲染） | 优秀（仅追踪必要字段） |\n| 验证方式 | Yup Schema（推荐）/自定义 | 内置规则/自定义/Yup（支持） |\n| 学习成本 | 中等（API 较多） | 低（API 简洁） |\n| 生态兼容 | 良好 | 良好 |\n| 适用场景 | 复杂表单、需要完整状态管理 | 高性能需求、简单/中等表单 |\n\n# 7. 最佳实践\n1. **Schema 复用**：将通用验证规则（如手机号、邮箱）封装为独立的 Yup Schema，便于复用；\n2. **错误提示优化**：仅在字段被触碰（`touched`）后显示错误，避免初始加载时的错误提示；\n3. **提交状态管理**：使用 `isSubmitting` 禁用提交按钮，防止重复提交；\n4. **异步验证防抖**：异步验证（如邮箱查重）添加防抖，减少请求次数；\n5. **表单嵌套处理**：使用嵌套字段名（如 `user.name`）管理复杂表单结构；\n6. **与 UI 库集成**：优先使用组件库的表单验证状态（如 Ant Design 的 `validateStatus`），保持样式统一。\n...","directory_id":"fa2521c5-ab87-4500-9375-449364eb3b13","is_published":true,"created_at":"2025-12-22 03:19:12.977666+00","updated_at":"2025-12-23 13:13:20.764677+00"},{"id":"63448a81-60f8-4335-a5db-dc369065e7ba","title":"Zustand/Redux DevTools 状态调试","content":"# 1. 状态调试工具核心价值\n复杂 React 项目中，全局状态（如用户信息、商品列表）的变化难以追踪，状态调试工具可实现：\n- 可视化状态变化历史：记录每一次状态修改的时间、原因、前后数据；\n- 时间旅行调试：回滚到任意历史状态，复现问题场景；\n- 状态变更追踪：定位触发状态修改的组件/动作；\n- 性能分析：识别频繁的状态更新导致的性能问题。\n\n# 2. Redux DevTools 调试\n## 2.1 安装与配置\n### 2.1.1  浏览器扩展安装\nChrome/Firefox 应用商店搜索「Redux DevTools」安装扩展。\n\n### 2.1.2 项目集成（Redux Toolkit 推荐）\nRedux Toolkit 内置支持 Redux DevTools，无需额外配置：\n```typescript\n// src/store/index.ts\nimport { configureStore } from '@reduxjs/toolkit';\nimport userReducer from './slices/userSlice';\n\nexport const store = configureStore({\n  reducer: {\n    user: userReducer,\n  },\n  // Redux Toolkit 自动配置 DevTools，生产环境自动禁用\n  devTools: process.env.NODE_ENV !== 'production',\n});\n\nexport type RootState = ReturnType<typeof store.getState>;\nexport type AppDispatch = typeof store.dispatch;\n```\n\n### 2.1.3 传统 Redux 集成（非 Toolkit）\n```typescript\nimport { createStore, applyMiddleware, compose } from 'redux';\nimport rootReducer from './reducers';\n\n// 集成 DevTools\nconst composeEnhancers = window.__REDUX_DEVTOOLS_EXTENSION_COMPOSE__ || compose;\nconst store = createStore(rootReducer, composeEnhancers(applyMiddleware(/* 中间件 */)));\n\nexport default store;\n```\n\n## 2.2 核心功能与调试技巧\n### 2.2.1 状态监控（State 面板）\n- 左侧展示 Redux store 的完整状态树，支持展开/折叠对象；\n- 右侧展示选中状态的详细数据，支持搜索、复制；\n- 实时更新：每次 dispatch action 后，状态面板自动刷新。\n\n### 2.2.2 动作追踪（Actions 面板）\n- 记录所有 dispatch 的 action，包括：\n  - **Action Type**：动作类型（如 `user/loginSuccess`）；\n  - **Payload**：动作携带的数据；\n  - **Timestamp**：触发时间；\n  - **Duration**：状态更新耗时；\n- 筛选功能：按 action type 过滤，快速定位目标动作。\n\n### 2.2.3 时间旅行调试\n- 点击历史动作列表中的任意一项，Redux store 会回滚到该动作执行后的状态；\n- 「Pause」按钮：暂停状态更新，复现连续动作导致的问题；\n- 「Replay」按钮：重新执行选中的动作，验证状态更新逻辑。\n\n### 2.2.4 状态差异对比（Diff 面板）\n- 选择任意两个历史状态，Diff 面板展示数据差异（新增/修改/删除的字段）；\n- 示例：对比登录前后的 `user` 状态，确认用户信息是否正确存储。\n\n### 2.2.5  性能分析（Performance 面板）\n- 录制动作执行过程，分析每个 action 触发的状态更新耗时；\n- 识别频繁 dispatch 的 action（如输入框实时搜索导致的高频 action），可通过防抖优化。\n\n### 2.2.6 高级配置\n- 「Settings」面板配置：\n  - 黑/白名单：指定需要/不需要监控的 action type；\n  - 持久化状态：刷新页面后保留状态历史；\n  - 状态序列化：处理不可序列化数据（如函数、Symbol）。\n\n## 2.3 常见问题解决\n### 2.3.1 DevTools 不显示状态\n- 确认 store 配置了 `devTools: true`；\n- 检查是否安装了多个 Redux DevTools 扩展（冲突导致失效）；\n- 确保 action 是标准格式（包含 `type` 字段）。\n\n### 2.3.2 时间旅行后状态异常\n- 检查 reducer 是否为纯函数（纯函数是时间旅行的前提）；\n- 避免在 reducer 中修改原始状态（必须返回新对象/数组）。\n\n### 2.3.3 状态无法序列化\n- 避免在 state 中存储不可序列化数据（如 DOM 节点、函数）；\n- 如需存储，在 DevTools 配置中添加序列化规则：\n  ```typescript\n  const store = configureStore({\n    reducer: { user: userReducer },\n    devTools: {\n      serialize: {\n        replacer: (key, value) => {\n          // 处理不可序列化数据\n          if (key === 'functionData') return '[Function]';\n          return value;\n        },\n      },\n    },\n  });\n  ```\n\n# 3. Zustand DevTools 调试\n## 3.1 安装与配置\nZustand 轻量级状态管理库，需手动集成 Redux DevTools：\n```bash\nnpm install zustand redux-devtools-extension # 安装依赖\n```\n\n```typescript\n// src/store/useUserStore.ts\nimport { create } from 'zustand';\nimport { devtools, persist } from 'zustand/middleware';\n\ninterface UserState {\n  name: string;\n  age: number;\n  setName: (name: string) => void;\n  setAge: (age: number) => void;\n}\n\nexport const useUserStore = create<UserState>()(\n  devtools(\n    persist(\n      (set) => ({\n        name: '张三',\n        age: 18,\n        setName: (name) => set({ name }, false, 'user/setName'), // 第三个参数为 action type\n        setAge: (age) => set({ age }, false, 'user/setAge'),\n      }),\n      { name: 'user-storage' } // 持久化配置\n    ),\n    { name: 'userStore' } // DevTools 实例名\n  )\n);\n```\n\n## 3.2 核心调试技巧\n### 3.2.1 状态监控与动作追踪\n- 打开 Redux DevTools 扩展，选择「userStore」实例；\n- 面板中展示 Zustand store 的状态变化，action type 对应 `set` 方法的第三个参数（如 `user/setName`）；\n- 支持时间旅行调试：回滚到任意历史状态，验证状态修改逻辑。\n\n### 3.2.2 中间件调试\n- 结合 `devtools` 中间件的 `name` 参数，区分多个 Zustand store（如 `userStore`/`cartStore`）；\n- 动作描述：`set` 方法的第三个参数建议遵循「模块/动作」命名规范（如 `cart/addItem`），便于识别。\n\n### 3.2.3 持久化状态调试\n- 「State」面板中查看 `persist` 中间件存储的状态（如 localStorage 中的数据）；\n- 验证持久化逻辑：刷新页面后，状态是否从 localStorage 恢复。\n\n## 3.3 高级调试配置\n### 3.3.1 禁用 DevTools（生产环境）\n```typescript\nconst useUserStore = create<UserState>()(\n  (process.env.NODE_ENV === 'development' ? devtools : (f) => f)(\n    persist((set) => ({ /* 状态定义 */ }))\n  )\n);\n```\n\n### 3.3.2 状态变更日志\n```typescript\ndevtools(\n  (set) => ({ /* 状态定义 */ }),\n  {\n    name: 'userStore',\n    enabled: process.env.NODE_ENV === 'development',\n    actionsBlacklist: ['user/setAge'], // 忽略指定动作\n  }\n)\n```\n\n# 4. 状态调试最佳实践\n1. 统一 action type 命名规范（如「模块/动作」），便于筛选和识别；\n2. 生产环境禁用 DevTools，避免性能损耗和安全风险；\n3. 结合 React DevTools，定位触发状态更新的组件；\n4. 对频繁更新的状态（如输入框内容），添加防抖/节流，减少状态变更次数；\n5. 定期清理状态历史（DevTools 「Clear」按钮），避免内存占用过高。","directory_id":"ac88594f-879e-410b-94ce-266d80cce0f4","is_published":true,"created_at":"2025-12-22 03:22:07.008515+00","updated_at":"2025-12-23 14:30:39.111329+00"},{"id":"66dfc593-871b-47c6-b541-f63c9de6a5b6","title":"Zustand 核心特性","content":"在上一节入门基础上，本文将深入 Zustand 的核心特性，包括状态更新的高级用法、中间件的使用（如调试、日志）、状态持久化（本地存储）等，帮助你灵活应对复杂业务场景。\n\n# 1. 状态更新的高级用法\nZustand 的 `set` 函数支持多种灵活的状态更新方式，除了基础的“函数式更新”“直接更新”，还支持“状态合并”“替换状态”“异步更新”等场景。\n\n## 1.1 状态合并（默认行为）\n`set` 函数默认会将新状态与旧状态合并，无需手动传递所有字段：\n```jsx\nconst useUserStore = create((set) => ({\n  name: '张三',\n  age: 20,\n  address: '北京',\n  // 仅更新 name，age 和 address 保持不变\n  updateName: (newName) => set({ name: newName }),\n}));\n```\n\n## 1.2 替换状态（覆盖整个状态）\n若需完全替换 Store 中的所有状态（而非合并），可给 `set` 函数传递第二个参数 `replace: true`：\n```jsx\nconst useUserStore = create((set) => ({\n  name: '张三',\n  age: 20,\n  // 替换整个状态（仅保留新传递的字段）\n  replaceUser: (newUser) => set(newUser, true),\n}));\n\n// 调用后，Store 状态变为 { name: '李四', age: 25 }（address 被删除）\nuseUserStore.getState().replaceUser({ name: '李四', age: 25 });\n```\n\n## 1.3 异步状态更新\nZustand 支持直接在状态方法中写异步逻辑（无需额外中间件），通过 `set` 函数在异步操作完成后更新状态：\n```jsx\nconst useUserStore = create((set) => ({\n  userInfo: null,\n  loading: false,\n  error: null,\n\n  // 异步获取用户信息\n  fetchUser: async (userId) => {\n    set({ loading: true, error: null }); // 开始请求：更新加载状态\n    try {\n      const res = await fetch(`https://api.example.com/users/${userId}`);\n      const data = await res.json();\n      set({ userInfo: data, loading: false }); // 请求成功：更新用户信息\n    } catch (err) {\n      set({ error: err.message, loading: false }); // 请求失败：更新错误信息\n    }\n  },\n}));\n\n// 组件中调用异步方法\nconst fetchUser = useUserStore((state) => state.fetchUser);\nuseEffect(() => {\n  fetchUser(1); // 组件挂载时请求用户 ID=1 的信息\n}, [fetchUser]);\n```\n\n## 1.4 基于当前状态的链式更新\n若需连续修改状态（且后一次修改依赖前一次的结果），可链式调用 `set` 函数（或在一个 `set` 中处理）：\n```jsx\nconst useCounterStore = create((set) => ({\n  count: 0,\n  // 链式更新：先 +1，再 *2（最终 count = (0+1)*2 = 2）\n  incrementAndDouble: () => \n    set((state) => ({ count: state.count + 1 }))\n      .then(() => set((state) => ({ count: state.count * 2 }))),\n}));\n```\n\n# 2. 中间件（Middleware）\n中间件是 Zustand 扩展功能的核心机制，用于拦截 Store 的创建、状态更新、方法调用等过程，实现日志打印、调试、持久化等功能。Zustand 内置了多个常用中间件，也支持自定义中间件。\n\n## 2.1 核心中间件介绍\nZustand 的中间件通过 `compose` 函数组合（需从 `zustand/middleware` 导入），常用中间件如下：\n\n### （1）`devtools`：Redux DevTools 调试\n支持在 Redux DevTools 中查看状态变化历史、Dispatch 记录、时间线等，开发阶段必备：\n```jsx\nimport { create } from 'zustand';\nimport { devtools } from 'zustand/middleware'; // 导入调试中间件\n\n// 创建 Store 时包裹 devtools 中间件\nconst useCounterStore = create(\n  devtools((set) => ({\n    count: 0,\n    increment: () => set((state) => ({ count: state.count + 1 })),\n  }), {\n    name: 'counter-store', // 调试工具中显示的 Store 名称（可选）\n  })\n);\n```\n\n### （2）`logger`：控制台日志打印\n在控制台打印状态更新的详细日志（旧状态、新状态、触发方法等），简单调试场景可用：\n```jsx\nimport { create } from 'zustand';\nimport { logger } from 'zustand/middleware'; // 导入日志中间件\n\n// 组合 logger 和 devtools 中间件（顺序不影响，compose 会自动处理）\nconst useCounterStore = create(\n  logger(\n    devtools((set) => ({\n      count: 0,\n      increment: () => set((state) => ({ count: state.count + 1 })),\n    }))\n  )\n);\n```\n\n### （3）`persist`：状态持久化（本地存储）\n将 Store 状态持久化到 `localStorage` 或 `sessionStorage`，页面刷新后状态不丢失，核心中间件之一：\n```jsx\nimport { create } from 'zustand';\nimport { persist } from 'zustand/middleware'; // 导入持久化中间件\n\nconst useUserStore = create(\n  persist(\n    (set) => ({\n      userInfo: null,\n      token: '',\n      login: (token, user) => set({ token, userInfo: user }),\n      logout: () => set({ token: '', userInfo: null }),\n    }),\n    {\n      name: 'user-storage', // 本地存储的 key（默认在 localStorage 中）\n      getStorage: () => sessionStorage, // 可选：指定存储方式（sessionStorage）\n      partialize: (state) => ({ token: state.token }), // 可选：仅持久化部分状态（如只存 token）\n    }\n  )\n);\n```\n\n### 持久化中间件关键配置\n- `name`：本地存储的键名（如 `user-storage`，对应 `localStorage.getItem('user-storage')`）；\n- `getStorage`：指定存储介质，默认 `localStorage`，可改为 `sessionStorage` 或自定义存储（如 IndexedDB）；\n- `partialize`：过滤需要持久化的状态（返回需要持久化的对象，忽略其他字段）；\n- `onRehydrateStorage`：持久化恢复前的回调（如处理状态格式兼容）；\n- `version`：状态版本号（用于版本迁移，避免旧版本状态导致的问题）。\n\n## 2.2 中间件组合（compose）\n当需要同时使用多个中间件时，可使用 `compose` 函数（从 `zustand/middleware` 导入）统一组合：\n```jsx\nimport { create } from 'zustand';\nimport { devtools, logger, persist, compose } from 'zustand/middleware';\n\n// 组合多个中间件（顺序：从右到左执行，即 persist → logger → devtools）\nconst middleware = compose(persist, logger, devtools);\n\nconst useCounterStore = create(\n  middleware((set) => ({\n    count: 0,\n    increment: () => set((state) => ({ count: state.count + 1 })),\n  }), {\n    // persist 配置（中间件的配置需放在第二个参数）\n    name: 'counter-storage',\n    // devtools 配置\n    devtools: { name: 'counter-store' },\n  })\n);\n```\n\n## 2.3 自定义中间件（进阶）\n若内置中间件无法满足需求，可自定义中间件。自定义中间件是一个函数，接收 `fn`（Store 初始化函数）和 `options`（配置），返回新的初始化函数：\n```jsx\n// 自定义中间件：记录状态更新的时间戳\nconst timestampMiddleware = (fn) => (set, get, store) => {\n  // 重写 set 函数，添加时间戳\n  const newSet = (...args) => {\n    // 调用原始 set 函数更新状态\n    set(...args);\n    // 记录更新时间戳\n    console.log(`状态更新时间：${new Date().toLocaleTimeString()}`);\n  };\n  // 传递新的 set 函数给原始 Store\n  return fn(newSet, get, store);\n};\n\n// 使用自定义中间件\nconst useCounterStore = create(\n  timestampMiddleware((set) => ({\n    count: 0,\n    increment: () => set((state) => ({ count: state.count + 1 })),\n  }))\n);\n```\n\n# 3. 其他核心特性\n## 3.1 订阅状态变化\n除了通过 `useStore` 在组件中自动订阅状态，还可通过 `subscribe` 方法手动订阅状态变化（适用于非 React 环境或全局监听）：\n```jsx\nconst useCounterStore = create((set) => ({ count: 0, increment: () => set((s) => ({ count: s.count + 1 })) }));\n\n// 手动订阅 count 变化\nconst unsubscribe = useCounterStore.subscribe(\n  (state) => state.count, // 订阅的状态\n  (newCount, oldCount) => { // 状态变化时的回调\n    console.log(`count 从 ${oldCount} 变为 ${newCount}`);\n  }\n);\n\n// 取消订阅（如组件卸载时）\nunsubscribe();\n```\n\n## 3.2 获取当前状态（非组件环境）\n通过 `getState` 方法可在非组件环境（如工具函数、异步回调）中获取当前 Store 状态：\n```jsx\n// 工具函数中获取状态\nconst getCurrentCount = () => {\n  return useCounterStore.getState().count;\n};\n\n// 异步回调中获取状态\nfetch('/api/data').then(() => {\n  const count = useCounterStore.getState().count;\n  console.log('当前计数：', count);\n});\n```\n\n## 3.3 销毁 Store（可选）\n若需手动销毁 Store（如单页应用路由切换时清理状态），可调用 `destroy` 方法：\n```jsx\nuseCounterStore.destroy();\n```\n\n# 4. 核心特性使用注意事项\n1. **异步状态更新的错误处理**：异步方法中必须捕获错误，避免未处理的 Promise 错误导致应用崩溃；\n2. **持久化状态的兼容性**：持久化的状态需支持 JSON 序列化（如函数、Symbol 等类型无法持久化，会被自动忽略）；\n3. **中间件顺序**：组合多个中间件时，顺序会影响执行逻辑（如 `persist` 应放在最外层，确保状态更新先被持久化）；\n4. **手动订阅的清理**：手动调用 `subscribe` 后，需在适当时候（如组件卸载）调用 `unsubscribe`，避免内存泄漏；\n5. **状态不可变性**：虽然 Zustand 自动处理状态合并，但仍需避免直接修改状态（如 `state.count += 1`），必须通过 `set` 函数更新。","directory_id":"ed2cdaf2-c966-4d9f-bfad-740b9f352c61","is_published":true,"created_at":"2025-12-22 03:10:34.735536+00","updated_at":"2025-12-23 03:13:29.755702+00"},{"id":"69b5e14c-c992-460d-8a39-ba63c8c50674","title":"嵌套路由","content":"在实际 React 项目开发中，页面结构往往不是扁平的——比如一个后台管理系统，顶部有导航栏、左侧有侧边栏，点击侧边栏不同选项时，仅右侧内容区域发生变化。这种“外层布局固定，内层内容动态切换”的场景，正是**嵌套路由**要解决的核心问题。\n\n# 1. 嵌套路由的核心概念\n嵌套路由指的是路由之间存在层级关系：一个父路由对应一个包含公共布局的组件，子路由对应布局内的具体内容组件。React Router 中实现嵌套路由的关键是：\n1. 父路由的 `path` 作为基础路径，子路由的 `path` 拼接在其后（支持相对路径）；\n2. 父组件中通过 `<Outlet />` 组件标记子路由内容的渲染位置。\n\n# 2. 基本使用步骤\n## 2.1 定义嵌套路由规则\n在 `Routes` 中，给父路由的 `children` 属性配置子路由列表：\n```jsx\nimport { BrowserRouter, Routes, Route } from 'react-router-dom';\nimport Layout from './pages/Layout'; // 父布局组件\nimport Home from './pages/Home';     // 子组件1\nimport UserList from './pages/UserList'; // 子组件2\nimport UserDetail from './pages/UserDetail'; // 子组件3（带动态参数）\n\nfunction App() {\n  return (\n    <BrowserRouter>\n      <Routes>\n        {/* 父路由：path 为基础路径，element 为布局组件 */}\n        <Route path=\"/\" element={<Layout />}>\n          {/* 子路由：path 为相对路径（可省略 /），index 表示默认子路由 */}\n          <Route index element={<Home />} />\n          <Route path=\"users\" element={<UserList />} />\n          <Route path=\"users/:id\" element={<UserDetail />} />\n        </Route>\n      </Routes>\n    </BrowserRouter>\n  );\n}\n```\n\n## 2.2 父布局组件中使用 `<Outlet />`\n`<Outlet />` 是 React Router 提供的“占位组件”，用于渲染当前匹配的子路由组件：\n```jsx\n// pages/Layout.jsx\nimport { Outlet, Link } from 'react-router-dom';\n\nexport default function Layout() {\n  return (\n    <div className=\"app-layout\">\n      {/* 公共侧边栏（固定布局） */}\n      <aside>\n        <Link to=\"/\">首页</Link>\n        <Link to=\"/users\">用户列表</Link>\n      </aside>\n      {/* 子路由内容渲染位置 */}\n      <main>\n        <Outlet />\n      </main>\n    </div>\n  );\n}\n```\n\n## 2.3 子路由组件正常编写\n子组件无需关心嵌套关系，只需专注自身功能：\n```jsx\n// pages/UserList.jsx\nexport default function UserList() {\n  return <div>用户列表页面：张三、李四、王五</div>;\n}\n```\n\n# 3. 关键细节\n1. **默认子路由（index）**：当父路由匹配但没有具体子路由匹配时（如访问 `/`），渲染 `index` 对应的子组件，避免 `<Outlet />` 区域空白。\n2. **相对路径与绝对路径**：子路由的 `path` 若以 `/` 开头为绝对路径，否则为相对父路由的路径（推荐使用相对路径，便于路由复用）。\n3. **嵌套多层路由**：支持无限层级嵌套，只需在子路由中继续配置 `children` 并使用 `<Outlet />`。\n4. **子路由的导航**：子路由间跳转可使用相对路径（如在 `UserList` 中跳转到 `users/1`，可写 `<Link to=\"1\">`）。\n\n# 4. 嵌套路由的优势\n- 复用公共布局（如导航栏、侧边栏、页脚），减少代码冗余；\n- 清晰的路由层级结构，与页面结构一一对应，便于维护；\n- 支持局部内容刷新，无需重新渲染整个页面，提升用户体验。","directory_id":"77b830a2-38dc-41a0-8e20-9f29ffc5a332","is_published":true,"created_at":"2025-12-22 02:07:51.974472+00","updated_at":"2025-12-23 02:50:27.210642+00"},{"id":"6dd0f2b6-3b01-4fc1-8487-45ae34eaa3ae","title":"子传父——回调函数","content":"React 是单向数据流，数据只能从父组件流向子组件，无法直接反向传递。但实际开发中，子组件常需向父组件传递数据（如表单输入、按钮点击事件结果），此时需通过**回调函数传参**实现“子传父”，核心思路是：父组件传递一个回调函数给子组件，子组件调用该函数并传入需要传递的数据。\n\n# 1. 回调函数传参核心流程\n## 1.1 父组件：定义回调函数 + 传递给子组件\n父组件先定义一个接收参数的回调函数（用于处理子组件传递的数据），再将该函数作为 props 传递给子组件。\n```jsx\n// 父组件 Parent.jsx\nimport Child from './Child';\nimport { useState } from 'react';\n\nfunction Parent() {\n  const [childMsg, setChildMsg] = useState(''); // 存储子组件传递的数据\n\n  // 1. 定义回调函数：接收子组件传递的参数\n  const handleChildData = (data, type) => {\n    console.log('子组件传递的数据：', data);\n    setChildMsg(`[${type}] ${data}`); // 处理数据（如更新父组件状态）\n  };\n\n  return (\n    <div>\n      <h1>父组件</h1>\n      <p>子组件传递的信息：{childMsg}</p>\n      {/* 2. 将回调函数作为 props 传递给子组件 */}\n      <Child onSendData={handleChildData} />\n    </div>\n  );\n}\n```\n\n## 1.2 子组件：调用回调函数 + 传入数据\n子组件通过 `props` 接收父组件传递的回调函数，在需要传递数据的时机（如按钮点击、表单输入变化、接口请求成功后）调用该函数，并将数据作为参数传入。\n```jsx\n// 子组件 Child.jsx（函数组件）\nfunction Child(props) {\n  const [inputValue, setInputValue] = useState('');\n\n  // 子组件内部事件：触发数据传递\n  const handleClick = () => {\n    // 3. 调用父组件传递的回调函数，传入需要传递的数据（可传多个参数）\n    props.onSendData(inputValue, '输入内容');\n  };\n\n  return (\n    <div>\n      <h2>子组件</h2>\n      <input\n        type=\"text\"\n        value={inputValue}\n        onChange={(e) => setInputValue(e.target.value)}\n        placeholder=\"请输入要传递给父组件的内容\"\n      />\n      <button onClick={handleClick}>发送给父组件</button>\n    </div>\n  );\n}\n\n// 子组件 Child.jsx（类组件）\nimport React from 'react';\nclass Child extends React.Component {\n  state = { inputValue: '' };\n\n  handleInputChange = (e) => {\n    this.setState({ inputValue: e.target.value });\n  };\n\n  handleClick = () => {\n    // 类组件通过 this.props 调用回调函数\n    this.props.onSendData(this.state.inputValue, '输入内容');\n  };\n\n  render() {\n    return (\n      <div>\n        <input\n          type=\"text\"\n          value={this.state.inputValue}\n          onChange={this.handleInputChange}\n        />\n        <button onClick={this.handleClick}>发送给父组件</button>\n      </div>\n    );\n  }\n}\n```\n\n# 2. 常见使用场景\n## 2.1 表单数据传递\n子组件是表单组件（如输入框、选择器），将用户输入的内容传递给父组件存储或提交：\n```jsx\n// 子组件：表单组件\nfunction FormChild(props) {\n  const handleSubmit = (e) => {\n    e.preventDefault();\n    const formData = {\n      username: e.target.username.value,\n      password: e.target.password.value\n    };\n    props.onFormSubmit(formData); // 传递表单数据给父组件\n  };\n\n  return (\n    <form onSubmit={handleSubmit}>\n      <input name=\"username\" placeholder=\"用户名\" />\n      <input name=\"password\" type=\"password\" placeholder=\"密码\" />\n      <button type=\"submit\">提交</button>\n    </form>\n  );\n}\n\n// 父组件：接收表单数据并处理\nfunction Parent() {\n  const handleSubmit = (formData) => {\n    console.log('表单提交数据：', formData);\n    // 执行接口请求等逻辑\n  };\n  return <FormChild onFormSubmit={handleSubmit} />;\n}\n```\n\n## 2.2 事件结果传递\n子组件的事件（如按钮点击、弹窗关闭）结果传递给父组件，用于更新父组件状态：\n```jsx\n// 子组件：弹窗组件\nfunction ModalChild(props) {\n  const handleClose = () => {\n    props.onClose(false); // 传递“关闭”状态给父组件\n  };\n  const handleConfirm = () => {\n    props.onClose(true); // 传递“确认”状态给父组件\n  };\n\n  return (\n    <div className=\"modal\">\n      <p>是否确认删除？</p>\n      <button onClick={handleClose}>取消</button>\n      <button onClick={handleConfirm}>确认</button>\n    </div>\n  );\n}\n\n// 父组件：控制弹窗显示/隐藏\nfunction Parent() {\n  const [isModalOpen, setIsModalOpen] = useState(true);\n\n  const handleModalClose = (isConfirmed) => {\n    setIsModalOpen(false);\n    if (isConfirmed) {\n      console.log('用户确认删除，执行删除逻辑');\n    }\n  };\n\n  return isModalOpen ? <ModalChild onClose={handleModalClose} /> : null;\n}\n```\n\n## 2.3 异步数据传递\n子组件内部发起接口请求，请求成功后将结果传递给父组件：\n```jsx\n// 子组件：数据请求组件\nfunction DataChild(props) {\n  const fetchData = async () => {\n    const res = await fetch('/api/user');\n    const data = await res.json();\n    props.onDataFetched(data); // 传递异步请求结果给父组件\n  };\n\n  useEffect(() => {\n    fetchData();\n  }, []);\n\n  return <div>正在请求数据...</div>;\n}\n\n// 父组件：接收并展示数据\nfunction Parent() {\n  const [userData, setUserData] = useState(null);\n  const handleData = (data) => {\n    setUserData(data);\n  };\n  return <DataChild onDataFetched={handleData} />;\n}\n```\n\n# 3. 注意事项\n## 3.1 避免回调函数重复创建（性能优化）\n父组件每次渲染时，若直接定义匿名函数传递给子组件，会导致子组件认为 `props` 变化而重复渲染（尤其是类组件或未使用 `React.memo` 的函数组件）。优化方案：\n- 函数组件：使用 `useCallback` 缓存回调函数。\n- 类组件：将回调函数定义为类的实例方法（箭头函数形式）。\n\n```jsx\n// 函数组件优化：useCallback 缓存回调\nimport { useCallback } from 'react';\n\nfunction Parent() {\n  const [childMsg, setChildMsg] = useState('');\n\n  // 用 useCallback 缓存，依赖项为 setChildMsg（稳定函数）\n  const handleChildData = useCallback((data) => {\n    setChildMsg(data);\n  }, [setChildMsg]);\n\n  return <Child onSendData={handleChildData} />;\n}\n\n// 类组件优化：箭头函数实例方法（this 绑定稳定）\nclass Parent extends React.Component {\n  state = { childMsg: '' };\n\n  // 箭头函数自动绑定 this，且每次渲染不会重新创建\n  handleChildData = (data) => {\n    this.setState({ childMsg: data });\n  };\n\n  render() {\n    return <Child onSendData={this.handleChildData} />;\n  }\n}\n```\n\n## 3.2 回调函数的参数传递\n回调函数支持传递多个参数，子组件可根据需求传递任意数据，父组件按顺序接收即可：\n```jsx\n// 子组件：传递多个参数\nprops.onSendData(inputValue, '输入类型', new Date().getTime());\n\n// 父组件：按顺序接收多个参数\nconst handleChildData = (content, type, timestamp) => {\n  console.log('内容：', content, '类型：', type, '时间戳：', timestamp);\n};\n```\n\n## 3.3 避免循环调用\n确保回调函数只在特定事件触发时调用（如点击、输入变化），不要直接在组件渲染时调用，否则会导致无限循环：\n```jsx\n// 错误：直接调用回调函数，导致组件渲染时无限执行\n<Child onSendData={handleChildData('错误示例')} />\n\n// 正确：传递函数引用，由子组件在事件中调用\n<Child onSendData={handleChildData} />\n```\n\n# 4. 核心总结\n1. **核心原理**：父组件传递回调函数给子组件，子组件调用该函数并传入数据，间接实现“子传父”。\n2. **使用步骤**：父组件定义回调 → 传递给子组件 → 子组件触发事件时调用回调并传参。\n3. **性能优化**：函数组件用 `useCallback` 缓存回调，类组件用箭头函数实例方法。\n4. **适用场景**：表单数据传递、事件结果反馈、异步数据回调等需要子组件向父组件传递信息的场景。","directory_id":"803ada09-ee46-463c-b7f3-403560bfc20b","is_published":true,"created_at":"2025-12-19 10:50:24.127903+00","updated_at":"2025-12-19 10:50:24.127903+00"},{"id":"6eb94efd-6f95-44a6-af65-f9388db5463f","title":"自定义 Hooks 设计规范","content":"自定义 Hooks 是 React 中复用组件逻辑的核心方案，本质是封装了可复用的 Hooks 调用逻辑的函数，遵循特定规范才能保证可读性、复用性和兼容性。以下是自定义 Hooks 的核心设计规范：\n\n# 1. 命名规范\n1. **必须以 `use` 开头**\n   这是 React 识别自定义 Hooks 的关键标识，既符合 React 官方约定，也能让开发者一眼识别这是 Hooks 函数（而非普通工具函数）。\n   - ✅ 正确示例：`useRequest`、`useLocalStorage`、`useDebounce`\n   - ❌ 错误示例：`requestData`、`localStorageHelper`、`debounceHandler`\n\n2. **名称体现功能语义**\n   命名需清晰描述 Hooks 的核心作用，避免模糊或缩写（除非是行业通用缩写，如 `debounce`）。\n   - ✅ 语义明确：`useScrollPosition`（监听滚动位置）、`useWindowSize`（监听窗口尺寸）\n   - ❌ 语义模糊：`useData`、`useUtil`、`useFn`\n\n# 2. 复用逻辑设计规范\n## 2.1 单一职责原则\n一个自定义 Hooks 只专注于解决一个核心问题，避免封装过多无关逻辑，保证复用性和可维护性。\n- ✅ 示例：`useDebounce` 仅处理防抖逻辑，`useThrottle` 仅处理节流逻辑，而非将防抖+节流+请求封装在一个 Hooks 中。\n- ❌ 反例：`useCommon`（同时封装请求、防抖、本地存储逻辑），既难复用，也难调试。\n\n## 2.2 依赖透明化\n自定义 Hooks 内部使用的 `useEffect`、`useCallback` 等 Hooks 的依赖项，若需要外部传入，需通过参数显式声明，避免隐式依赖导致的 bug。\n```jsx\n// ✅ 依赖透明：将防抖延迟时间作为参数传入，外部可控制\nfunction useDebounce(value, delay) {\n  const [debouncedValue, setDebouncedValue] = useState(value);\n  useEffect(() => {\n    const timer = setTimeout(() => setDebouncedValue(value), delay);\n    return () => clearTimeout(timer);\n  }, [value, delay]); // 依赖项包含外部传入的 delay\n  return debouncedValue;\n}\n```\n\n## 2.3 返回值灵活适配场景\n根据 Hooks 功能设计合理的返回值：\n- 单一功能返回单一值：如 `useDebounce` 返回防抖后的值；\n- 复杂功能返回对象/数组：如 `useRequest` 返回 `{ data, loading, error, refresh }`，方便外部按需解构；\n- 避免返回冗余数据：仅返回外部需要的状态/方法，减少不必要的重渲染。\n\n## 2.4 内部 Hooks 调用合规\n自定义 Hooks 本质是 Hooks 函数的组合，需严格遵守 React Hooks 规则：\n- 只能在自定义 Hooks 内部、函数组件或其他 Hooks 中调用 React 内置 Hooks；\n- 不能在条件语句、循环、嵌套函数中调用 Hooks；\n- 确保 Hooks 调用顺序固定。\n\n## 2.5 错误处理与边界兼容\n对可能出现的异常（如网络请求失败、本地存储无权限）进行捕获，并提供默认值或错误回调，避免 Hooks 执行崩溃影响组件。\n```jsx\nfunction useLocalStorage(key, initialValue) {\n  const [value, setValue] = useState(() => {\n    try {\n      // 尝试从本地存储读取，失败则返回初始值\n      const stored = localStorage.getItem(key);\n      return stored ? JSON.parse(stored) : initialValue;\n    } catch (error) {\n      console.error(\"读取本地存储失败：\", error);\n      return initialValue;\n    }\n  });\n  // ... 其他逻辑\n}\n```\n\n## 2.6 避免过度封装\n仅封装**真正可复用**的逻辑，若某段逻辑仅在单个组件中使用，无需封装为自定义 Hooks，避免增加不必要的抽象层。\n\n# 3. 其他设计细节\n1. **参数默认值**：为非必传参数设置合理默认值，提升易用性。\n   ```jsx\n   // useDebounce 默认延迟 500ms\n   function useDebounce(value, delay = 500) { /* ... */ }\n   ```\n2. **注释说明**：为自定义 Hooks 添加清晰注释，说明功能、参数、返回值、使用场景，降低协作成本。\n3. **避免副作用泄漏**：内部的定时器、事件监听、网络请求等，需通过清理函数（如 `useEffect` 的返回函数）销毁，防止内存泄漏。","directory_id":"9e07a04e-b6bb-488a-9725-08821605cfbc","is_published":true,"created_at":"2025-12-22 02:22:16.74988+00","updated_at":"2025-12-22 02:46:13.871809+00"},{"id":"778db0ce-a6b3-45fd-a3c6-e71f3029b659","title":"JSX 与 HTML 的区别","content":"\nJSX 虽然看起来和 HTML 很像，但本质是 JavaScript 语法糖，因此在语法、属性名、关键字等方面存在诸多区别。下面是两者的核心区别对比：\n\n# 1. 核心区别对照表\n| 对比维度 | HTML | JSX | 说明 |\n|----------|------|-----|------|\n| 根节点要求 | 无强制要求，可多个根节点 | 必须有且仅有一个根节点（或用 Fragment 包裹） | JSX 编译后是函数调用，只能返回一个值 |\n| 类名属性 | `class` | `className` | `class` 是 JavaScript 关键字，避免冲突 |\n| 标签闭合 | 部分标签可省略闭合（如 `<img>`、`<br>`） | 所有标签必须闭合（如 `<img />`、`<br />`） | 遵循 XML 严格语法规则 |\n| 事件属性 | 全小写（如 `onclick`、`onchange`） | 驼峰命名（如 `onClick`、`onChange`） | 与 JavaScript 事件处理函数命名一致 |\n| `for` 属性 | `for`（如 `<label for=\"input1\">`） | `htmlFor` | `for` 是 JavaScript 循环关键字，避免冲突 |\n| 样式设置 | `style=\"color: red; font-size: 16px;\"` | `style={{ color: 'red', fontSize: '16px' }}` | JSX 样式是 JavaScript 对象 |\n| 表达式嵌入 | 不支持 | 支持 `{}` 嵌入 JavaScript 表达式 | 这是 JSX 的核心特性 |\n| 注释写法 | `<!-- 注释内容 -->` | `{/* 注释内容 */}` | JSX 注释需要写在 `{}` 内 |\n\n# 2. 重点区别详解\n## （1）类名属性：`class` → `className`\n在 HTML 中，我们使用 `class` 属性为元素设置样式类名，但在 JSX 中不能直接使用 `class`，因为 `class` 是 JavaScript 的**关键字**（用于定义类），为了避免语法冲突，JSX 规定使用 `className` 替代 `class`。\n\n**示例对比**：\n```html\n<!-- HTML 写法 -->\n<div class=\"container\">这是 HTML 元素</div>\n```\n\n```jsx\n// JSX 写法\n<div className=\"container\">这是 JSX 元素</div>\n```\n\n## （2）`for` 属性 → `htmlFor`\n在 HTML 中，`<label>` 标签的 `for` 属性用于关联 `<input>` 元素（点击 label 可触发 input 聚焦）。但 `for` 是 JavaScript 的**循环关键字**，因此 JSX 中使用 `htmlFor` 替代 `for`。\n\n**示例对比**：\n```html\n<!-- HTML 写法 -->\n<label for=\"username\">用户名：</label>\n<input type=\"text\" id=\"username\">\n```\n\n```jsx\n// JSX 写法\n<label htmlFor=\"username\">用户名：</label>\n<input type=\"text\" id=\"username\" />\n```\n\n## （3）事件属性：全小写 → 驼峰命名\nHTML 中的事件属性是全小写形式（如 `onclick`、`onmouseover`），而 JSX 中的事件属性采用**驼峰命名法**（如 `onClick`、`onMouseOver`），这与 JavaScript 中 DOM 事件的处理函数命名规则一致。\n\n**示例对比**：\n```html\n<!-- HTML 写法 -->\n<button onclick=\"alert('点击了按钮')\">点击我</button>\n```\n\n```jsx\n// JSX 写法\n<button onClick={() => alert('点击了按钮')}>点击我</button>\n```\n\n## （4）自闭合标签\nHTML 中部分标签可以省略闭合符号（如 `<img>`、`<br>`、`<input>`），但 JSX 遵循 XML 语法规则，**所有标签必须闭合**，自闭合标签需要添加 `/`。\n\n**示例对比**：\n```html\n<!-- HTML 写法 -->\n<img src=\"logo.png\" alt=\"logo\">\n<br>\n<input type=\"text\">\n```\n\n```jsx\n// JSX 写法\n<img src=\"logo.png\" alt=\"logo\" />\n<br />\n<input type=\"text\" />\n```\n\n# 3. 其他细节区别\n1. **布尔属性处理**：HTML 中布尔属性只要存在，值就为 `true`（如 `<input disabled>` 表示禁用）；JSX 中布尔属性需要显式设置值为 `true` 或 `false`，或者省略属性表示 `false`。\n   ```jsx\n   // 禁用按钮\n   <input type=\"text\" disabled={true} />\n   // 不禁用按钮（省略 disabled 属性）\n   <input type=\"text\" />\n   ```\n2. **特殊字符处理**：HTML 中可以直接使用 `<`、`>` 等特殊字符；JSX 中需要使用转义字符（如 `<` → `&lt;`，`>` → `&gt;`），或者在 `{}` 中嵌入表达式。\n   ```jsx\n   // 正确写法：转义字符\n   <p>1 &lt; 2</p>\n   // 正确写法：表达式\n   <p>{1 < 2 ? '1 小于 2' : '1 大于 2'}</p>\n   ```","directory_id":"22e948d7-98f2-4c47-8ae2-4abb0990f9f7","is_published":true,"created_at":"2025-12-19 07:35:24.737495+00","updated_at":"2025-12-19 09:20:29.769605+00"},{"id":"780d7bf0-97a9-4550-bab4-2cc28f910bf1","title":"React 18 新特性","content":"React 18 的核心升级是引入**并发渲染（Concurrent Rendering）**，这是一种底层架构优化，允许 React 在渲染过程中暂停、恢复或中断任务，优先处理高优先级操作（如用户输入、动画），从而提升应用的响应速度和用户体验。同时，React 18 提供了 `useTransition`、`useDeferredValue` 等新 API，让开发者能够利用并发渲染能力。\n\n# 1. 并发渲染（Concurrent Rendering）\n## 1.1 核心概念\n并发渲染是 React 18 的底层引擎升级，它将渲染过程从“同步不可中断”改为“异步可中断”：\n- **同步渲染**（React 17 及之前）：一旦开始渲染，必须执行到底，期间阻塞浏览器主线程（导致用户交互无响应）；\n- **并发渲染**（React 18）：渲染过程可被高优先级任务（如点击、输入、动画）中断，完成高优先级任务后再继续渲染，避免页面卡顿。\n\n## 1.2 关键特性\n1. **渲染优先级**：React 为不同任务分配优先级（如用户输入 > 动画 > 数据加载 > 普通渲染），高优先级任务可中断低优先级任务；\n2. **非阻塞渲染**：渲染过程不阻塞浏览器主线程，保证页面交互流畅；\n3. **可选特性**：并发渲染不会自动启用，需通过新的根 API（`createRoot`）激活。\n\n## 1.3 启用并发渲染\nReact 18 中，需将 `ReactDOM.render` 替换为 `createRoot` 以启用并发渲染：\n```javascript\n// React 17 及之前\nimport ReactDOM from 'react-dom';\nReactDOM.render(<App />, document.getElementById('root'));\n\n// React 18\nimport { createRoot } from 'react-dom/client';\nconst root = createRoot(document.getElementById('root'));\nroot.render(<App />);\n```\n\n# 2. 自动批处理（Automatic Batching）\n## 2.1 核心概念\n批处理是 React 将多个状态更新合并为一次渲染的优化策略，减少渲染次数，提升性能。React 18 之前，批处理仅在事件处理函数中生效；React 18 实现了**自动批处理**，无论状态更新发生在何处（事件处理、Promise 回调、定时器、异步函数），都会被合并为一次渲染。\n\n## 2.2 对比示例\n```javascript\n// React 17 及之前：仅事件处理函数内的更新会批处理\nfunction Example() {\n  const [count, setCount] = useState(0);\n  const [text, setText] = useState('');\n\n  // 事件处理函数：批处理（1 次渲染）\n  const handleClick = () => {\n    setCount(c => c + 1);\n    setText(t => t + 'a');\n  };\n\n  // Promise 回调：不批处理（2 次渲染）\n  const handlePromise = () => {\n    fetch('/api/data').then(() => {\n      setCount(c => c + 1);\n      setText(t => t + 'a');\n    });\n  };\n\n  return (\n    <div>\n      <button onClick={handleClick}>点击（批处理）</button>\n      <button onClick={handlePromise}>Promise（不批处理）</button>\n    </div>\n  );\n}\n\n// React 18（createRoot 启用）：所有更新自动批处理（均为 1 次渲染）\nfunction Example() {\n  // 同上代码，handlePromise 中的更新也会被批处理\n}\n```\n\n## 2.3 手动取消批处理\n若需立即触发渲染（不批处理），可使用 `flushSync`：\n```javascript\nimport { flushSync } from 'react-dom';\n\nfunction handleClick() {\n  flushSync(() => {\n    setCount(c => c + 1); // 立即渲染\n  });\n  setText(t => t + 'a'); // 单独渲染\n}\n```\n\n# 3. useTransition：标记非紧急更新\n## 3.1 核心概念\n`useTransition` 是 React 18 新增的 Hook，用于将状态更新标记为“非紧急更新”（transition），让 React 优先处理紧急更新（如用户输入），待主线程空闲时再执行非紧急更新，避免页面卡顿。\n\n## 3.2 基本用法\n```javascript\nimport { useState, useTransition } from 'react';\n\nfunction SearchComponent() {\n  const [input, setInput] = useState('');\n  const [results, setResults] = useState([]);\n  // isPending：是否正在执行 transition 更新；startTransition：标记非紧急更新\n  const [isPending, startTransition] = useTransition();\n\n  // 处理输入（紧急更新）\n  const handleInputChange = (e) => {\n    const value = e.target.value;\n    // 紧急更新：立即更新输入框内容\n    setInput(value);\n\n    // 非紧急更新：搜索结果（耗时操作）\n    startTransition(() => {\n      // 模拟耗时搜索\n      const filteredResults = largeData.filter(item => \n        item.includes(value)\n      );\n      setResults(filteredResults);\n    });\n  };\n\n  return (\n    <div>\n      <input \n        type=\"text\" \n        value={input} \n        onChange={handleInputChange} \n        placeholder=\"搜索...\" \n      />\n      {/* 加载状态提示 */}\n      {isPending && <div>搜索中...</div>}\n      <ul>\n        {results.map((item, index) => (\n          <li key={index}>{item}</li>\n        ))}\n      </ul>\n    </div>\n  );\n}\n```\n\n## 3.3 关键特性\n1. **优先级控制**：`startTransition` 包裹的状态更新优先级低于紧急更新（如输入、点击），不会阻塞用户交互；\n2. **加载状态**：`isPending` 标识 transition 更新是否进行中，可用于显示加载提示；\n3. **中断性**：若在 transition 更新过程中触发新的紧急更新，React 会中断当前 transition，优先处理紧急更新；\n4. **无延迟执行**：transition 不会延迟更新执行，只是允许被中断，保证页面响应性。\n\n# 4. useDeferredValue：延迟更新值\n## 4.1 核心概念\n`useDeferredValue` 是 React 18 新增的 Hook，用于创建一个“延迟更新”的变量副本，该副本会在紧急更新完成后才更新，适用于将昂贵的计算或渲染与紧急更新解耦。\n\n## 4.2 基本用法\n```javascript\nimport { useState, useDeferredValue } from 'react';\n\nfunction ListComponent() {\n  const [input, setInput] = useState('');\n  // 创建延迟更新的 input 副本（deferredInput 会滞后于 input 更新）\n  const deferredInput = useDeferredValue(input, {\n    timeoutMs: 200 // 可选：延迟最长时间（毫秒）\n  });\n\n  // 基于 deferredInput 渲染列表（昂贵操作）\n  const results = largeData.filter(item => \n    item.includes(deferredInput)\n  );\n\n  return (\n    <div>\n      <input \n        type=\"text\" \n        value={input} \n        onChange={(e) => setInput(e.target.value)} \n      />\n      <ul>\n        {results.map((item, index) => (\n          <li key={index}>{item}</li>\n        ))}\n      </ul>\n    </div>\n  );\n}\n```\n\n## 4.3 与 useTransition 的区别\n| 特性 | useTransition | useDeferredValue |\n|------|---------------|------------------|\n| 作用对象 | 状态更新（setState） | 变量值（创建延迟副本） |\n| 使用场景 | 标记非紧急状态更新 | 延迟使用某个值（如过滤条件） |\n| 加载状态 | 提供 isPending 标识 | 无内置加载状态（需自行处理） |\n| 中断性 | 支持中断 | 支持中断 |\n\n# 5. 其他 React 18 新特性\n## 5.1 Suspense 增强\nReact 18 中，Suspense 不再局限于懒加载组件，还支持：\n- 数据加载：配合 Suspense-compatible 数据库（如 Relay、React Query）实现数据加载时的占位符；\n- 流式渲染：逐步渲染页面内容，优先显示关键内容；\n- 服务端渲染：支持服务端流式渲染，提升首屏加载速度。\n\n## 5.2 新的客户端渲染 API\n- `createRoot`：替代 `ReactDOM.render`，启用并发渲染；\n- `hydrateRoot`：替代 `ReactDOM.hydrate`，支持服务端渲染的并发 hydration。\n\n## 5.3 严格模式升级\nReact 18 严格模式会在开发环境下**两次挂载组件**，检测组件是否存在副作用（如未清除的定时器、事件监听），帮助开发者编写更健壮的代码。\n\n# 6. 最佳实践\n1. **优先使用 createRoot**：启用并发渲染，享受自动批处理等优化；\n2. **区分紧急/非紧急更新**：用户输入、动画等紧急操作优先处理，数据加载、列表过滤等非紧急操作使用 `useTransition`/`useDeferredValue`；\n3. **合理使用 Suspense**：为懒加载组件、数据加载场景提供友好的占位符；\n4. **避免滥用 transition**：仅对耗时操作使用 `useTransition`，简单更新无需标记；\n5. **兼容旧代码**：React 18 保持向下兼容，旧代码使用 `ReactDOM.render` 仍可运行（但不启用并发渲染）。","directory_id":"0fa74abf-556e-40ef-a0d4-33dc2f8648a5","is_published":true,"created_at":"2025-12-22 03:18:06.752891+00","updated_at":"2025-12-23 10:01:43.615629+00"},{"id":"7a5fe8e0-83a9-417d-819f-bb5eb666339e","title":"useId：生成唯一 ID","content":"# 1. 核心概念\n`useId` 是 React 18 新增的 Hook，用于**生成跨服务端和客户端的唯一 ID**，解决了传统 ID 生成方案（如随机数、时间戳）在服务端渲染（SSR）时的“不匹配”问题（服务端生成的 ID 与客户端生成的 ID 不一致，导致 hydration 错误）。\n\n## 1.1 设计目的：\n- 支持 SSR/SSG：服务端和客户端生成相同的 ID，避免 hydration 不匹配；\n- 无障碍（a11y）适配：为表单控件（如 input/label）、ARIA 属性（如 aria-labelledby）提供唯一关联 ID；\n- 避免 ID 冲突：在循环渲染、组件复用场景下生成唯一 ID。\n\n# 2. 基本用法\n## 2.1 基础使用（表单 label 关联）\n```javascript\nimport { useId } from 'react';\n\nfunction InputWithLabel() {\n  // 生成唯一 ID\n  const inputId = useId();\n\n  return (\n    <div>\n      {/* label 与 input 通过 ID 关联（无障碍必备） */}\n      <label htmlFor={inputId}>用户名：</label>\n      <input id={inputId} type=\"text\" />\n    </div>\n  );\n}\n```\n\n## 2.2 生成多个关联 ID\n```javascript\nimport { useId } from 'react';\n\nfunction FormGroup() {\n  // 生成根 ID，基于根 ID 派生子 ID\n  const rootId = useId();\n  const usernameId = `${rootId}-username`;\n  const passwordId = `${rootId}-password`;\n\n  return (\n    <div>\n      <label htmlFor={usernameId}>用户名：</label>\n      <input id={usernameId} type=\"text\" />\n\n      <label htmlFor={passwordId}>密码：</label>\n      <input id={passwordId} type=\"password\" />\n    </div>\n  );\n}\n```\n\n## 2.3 循环渲染中生成唯一 ID\n```javascript\nimport { useId } from 'react';\n\nfunction CheckboxGroup({ options }) {\n  const rootId = useId();\n\n  return (\n    <div>\n      {options.map((option) => {\n        // 为每个选项生成唯一 ID\n        const checkboxId = `${rootId}-${option.value}`;\n        return (\n          <div key={option.value}>\n            <input\n              type=\"checkbox\"\n              id={checkboxId}\n              value={option.value}\n            />\n            <label htmlFor={checkboxId}>{option.label}</label>\n          </div>\n        );\n      })}\n    </div>\n  );\n}\n\n// 使用组件\nfunction App() {\n  const options = [\n    { label: '选项1', value: 'opt1' },\n    { label: '选项2', value: 'opt2' },\n    { label: '选项3', value: 'opt3' }\n  ];\n\n  return <CheckboxGroup options={options} />;\n}\n```\n\n# 3. 关键特性\n## 3.1 SSR 兼容性\n传统 ID 生成方案（如 `Math.random()`）在 SSR 时会导致服务端和客户端 ID 不一致：\n```javascript\n// 错误示例：SSR 时服务端和客户端生成的 randomId 不同，触发 hydration 错误\nfunction BadInput() {\n  const randomId = `input-${Math.random()}`;\n  return <input id={randomId} />;\n}\n\n// 正确示例：useId 在服务端和客户端生成相同 ID\nfunction GoodInput() {\n  const inputId = useId();\n  return <input id={inputId} />;\n}\n```\n\n## 3.2 ID 格式\n`useId` 生成的 ID 格式为 `react-数字-数字`（如 `react-123-456`），确保全局唯一性，且不会泄露敏感信息（与随机数不同）。\n\n## 3.3 依赖项\n`useId` 无依赖项，每次组件挂载时生成固定 ID（组件重渲染时 ID 不变）。\n\n# 4. 适用场景\n1. **无障碍表单**：label 与 input 关联、aria-describedby/aria-labelledby 等 ARIA 属性；\n2. **服务端渲染**：需要保证服务端和客户端 ID 一致的场景；\n3. **组件复用**：多个相同组件实例需要唯一 ID（如弹窗、下拉菜单）；\n4. **第三方库集成**：为第三方组件（如日历、富文本编辑器）提供唯一挂载 ID。\n\n# 5. 注意事项\n1. **不要用于列表 key**：列表 key 需基于数据本身（如 item.id），`useId` 生成的 ID 与数据无关，无法保证组件复用和性能优化；\n   ```javascript\n   // 错误示例\n   {items.map(item => (\n     <div key={useId()}>{item.name}</div>\n   ))}\n\n   // 正确示例\n   {items.map(item => (\n     <div key={item.id}>{item.name}</div>\n   ))}\n   ```\n2. **不要用于敏感场景**：`useId` 生成的 ID 不是加密安全的，不能用于身份验证、令牌等场景；\n3. **避免过度生成**：优先基于根 ID 派生子 ID（如 `${rootId}-input`），而非多次调用 `useId`；\n4. **客户端渲染也可使用**：即使不使用 SSR，`useId` 也是生成唯一 ID 的最佳实践（比随机数更可靠）。\n","directory_id":"0fa74abf-556e-40ef-a0d4-33dc2f8648a5","is_published":true,"created_at":"2025-12-22 03:17:53.645259+00","updated_at":"2025-12-23 10:00:04.890856+00"},{"id":"7b4663e1-2f44-4ecf-8603-2790eaef77ea","title":"React 虚拟 DOM 与 Diff 算法","content":"# 1. 什么是虚拟 DOM（Virtual DOM）\n虚拟 DOM 是 React 核心概念之一，本质是**描述真实 DOM 结构的 JavaScript 对象**（简称 VNode），它映射了真实 DOM 的层级关系和属性，存储在内存中，是真实 DOM 的“轻量级副本”。\n\n## 1.1 核心结构（简化版）\n```javascript\n// 真实 DOM 对应的虚拟 DOM 对象\nconst vnode = {\n  type: 'div', // 节点类型（标签名/组件）\n  props: {\n    className: 'container',\n    onClick: handleClick\n  },\n  children: [\n    { type: 'h1', props: { children: 'Hello React' } },\n    { type: 'p', props: { children: 'Virtual DOM' } }\n  ],\n  key: null // 用于 Diff 算法识别节点唯一性\n};\n```\n\n## 1.2 虚拟 DOM 的诞生背景\n- 真实 DOM 操作性能极低（DOM 节点是重量级对象，频繁增删改查会触发浏览器重排/重绘）；\n- 直接操作真实 DOM 难以维护复杂 UI 状态（如状态更新后手动同步 DOM）；\n- 虚拟 DOM 以 JS 对象形式存在，操作成本远低于真实 DOM，且能批量更新、按需渲染。\n\n## 1.3 虚拟 DOM 工作流程\n1. **初始化渲染**：React 将组件渲染为虚拟 DOM 对象，再通过 `ReactDOM.render` 转换为真实 DOM 插入页面；\n2. **状态更新**：组件状态变化时，React 生成新的虚拟 DOM 树；\n3. **Diff 对比**：对比新旧虚拟 DOM 树的差异（Diff 算法）；\n4. **DOM 打补丁**：将差异部分批量更新到真实 DOM 中（Reconciliation 协调过程）。\n\n# 2. 为什么需要虚拟 DOM\n## 2.1 核心价值\n1. **性能优化**：\n   - 批量更新：将多次 DOM 操作合并为一次，减少浏览器重排/重绘；\n   - 按需更新：仅更新变化的部分，而非整个 DOM 树；\n   - 跨平台兼容：虚拟 DOM 与平台无关（可渲染到 DOM/原生组件/Canvas 等），是 React Native 实现的基础。\n\n2. **开发体验提升**：\n   - 声明式编程：开发者只需描述 UI “应该是什么样”，无需关心 DOM 操作细节；\n   - 组件化复用：虚拟 DOM 支持组件嵌套，实现 UI 逻辑复用；\n   - 状态驱动 UI：状态变化自动映射到虚拟 DOM，再同步到真实 DOM，无需手动操作。\n\n## 2.2 常见误区\n- ❌ “虚拟 DOM 一定比原生 DOM 快”：虚拟 DOM 优势在于**复杂场景下的批量更新和按需渲染**，简单场景（如单次 DOM 修改）原生操作可能更快；\n- ✅ 虚拟 DOM 的核心价值是“抽象层”，而非单纯的性能提升，它让 React 实现了跨平台、声明式编程等特性。\n\n# 3. React Diff 算法（虚拟 DOM 对比核心）\nDiff 算法是 React 对比新旧虚拟 DOM 树、找出差异的核心逻辑，设计目标是**以最低成本找到差异节点**，其核心原则是：**基于两个假设，降低算法复杂度**（从 O(n³) 降至 O(n)，n 为节点数量）。\n\n## 3.1 核心假设\n1. **同层对比**：只对比同一层级的节点，不跨层级比较（如根节点的子节点只和根节点的子节点对比，不会和孙子节点对比）；\n   - 若节点跨层级移动，React 会直接删除旧节点、创建新节点，而非移动（这也是为什么不建议频繁跨层级操作 DOM）。\n2. **唯一 key 标识**：同一层级的节点通过 `key` 属性标识唯一性，若 `key` 相同则认为是同一节点，否则视为新节点。\n\n## 3.2 Diff 算法执行流程\n### 第一步：对比节点类型\n- 若新旧节点类型不同（如旧节点是 `div`，新节点是 `p`）：直接销毁旧节点及其所有子节点，创建新节点；\n- 若新旧节点类型相同（如都是 `div`）：进入属性对比和子节点对比。\n\n### 第二步：对比节点属性\n- 遍历新节点的 `props`，更新差异属性（如 `className`、`style`、事件绑定）；\n- 移除旧节点有但新节点没有的属性（如旧节点有 `title`，新节点无，则删除 `title` 属性）。\n\n### 第三步：对比子节点（核心难点）\nReact 对列表子节点的对比做了专门优化，核心依赖 `key` 属性：\n\n#### 场景 1：无 key 的列表（不推荐）\n```jsx\n// 旧列表\n<ul>\n  <li>Item 1</li>\n  <li>Item 2</li>\n</ul>\n\n// 新列表（在头部插入 Item 0）\n<ul>\n  <li>Item 0</li>\n  <li>Item 1</li>\n  <li>Item 2</li>\n</ul>\n```\n- 无 `key` 时，React 按顺序对比：\n  1. 第一个 `li`：内容从 `Item 1` 变为 `Item 0` → 更新内容；\n  2. 第二个 `li`：内容从 `Item 2` 变为 `Item 1` → 更新内容；\n  3. 第三个 `li`：新增 `Item 2` → 创建新节点；\n- 结果：3 次 DOM 操作（2 次更新 + 1 次创建），效率极低。\n\n#### 场景 2：有 key 的列表（推荐）\n```jsx\n// 旧列表\n<ul>\n  <li key=\"1\">Item 1</li>\n  <li key=\"2\">Item 2</li>\n</ul>\n\n// 新列表（在头部插入 Item 0）\n<ul>\n  <li key=\"0\">Item 0</li>\n  <li key=\"1\">Item 1</li>\n  <li key=\"2\">Item 2</li>\n</ul>\n```\n- 有 `key` 时，React 按 `key` 匹配：\n  1. `key=\"0\"`：新节点 → 创建；\n  2. `key=\"1\"`：匹配成功 → 无变化；\n  3. `key=\"2\"`：匹配成功 → 无变化；\n- 结果：仅 1 次 DOM 操作（创建 `key=\"0\"` 节点），效率大幅提升。\n\n## 3.3 key 的使用原则\n- ✅ 使用唯一且稳定的值（如数据 ID、后端返回的唯一标识）；\n- ❌ 不使用索引（index）作为 key（列表排序/增删时索引会变化，导致 Diff 失效）；\n- ❌ 不使用随机数（每次渲染生成新 key，导致节点被频繁销毁重建）。\n\n# 4. 虚拟 DOM 与 Diff 算法的局限性\n- 跨层级节点移动：React 会销毁旧节点重建，而非移动（可通过 `ReactTransitionGroup` 优化）；\n- 相同组件不同状态：若组件类型相同但状态差异大，Diff 算法仍会对比属性和子节点（可通过 `shouldComponentUpdate`/`memo` 优化）；\n- 大量列表渲染：长列表场景下，即使使用 key，Diff 对比仍有性能开销（可通过虚拟列表优化）。","directory_id":"46554425-2ee6-405b-b46c-7720d50c48ec","is_published":true,"created_at":"2025-12-22 03:14:31.066194+00","updated_at":"2025-12-23 09:29:37.651134+00"},{"id":"7bc1bad8-b500-4705-bf56-5fcad421ec0e","title":"类组件 state 与 setState","content":"在 React 类组件中，**state** 是用于存储组件内部可变数据的容器，**setState** 是唯一能合法修改 state 的方法。二者配合实现组件的状态管理与视图更新，其中 `setState` 的**异步更新**和**批量更新**特性是核心知识点，也是开发中容易踩坑的地方。\n\n# 1. state 基础用法\n## 1.1 初始化 state\n类组件的 state 必须在 `constructor` 构造函数中初始化，或通过类的实例属性直接定义（ES7 语法），state 本质是一个 JavaScript 对象，可存储多个状态属性。\n```jsx\nimport React from 'react';\n\nclass Counter extends React.Component {\n  // 方式1：ES7 类实例属性（推荐，简洁）\n  state = {\n    count: 0,\n    message: '初始消息'\n  };\n\n  // 方式2：constructor 构造函数初始化（兼容老版本）\n  // constructor(props) {\n  //   super(props);\n  //   this.state = {\n  //     count: 0,\n  //     message: '初始消息'\n  //   };\n  // }\n\n  render() {\n    // 通过 this.state 访问状态\n    return (\n      <div>\n        <p>计数：{this.state.count}</p>\n        <p>消息：{this.state.message}</p>\n      </div>\n    );\n  }\n}\n```\n\n## 1.2 state 的核心特性\n- **不可直接修改**：直接修改 `this.state` 不会触发组件重新渲染，必须通过 `setState` 方法更新。\n  ```jsx\n  // 错误：直接修改 state，组件不更新\n  this.state.count = 1;\n\n  // 正确：通过 setState 更新 state\n  this.setState({ count: 1 });\n  ```\n- **状态与视图联动**：调用 `setState` 后，React 会重新执行 `render` 方法，根据新的 state 生成新的 DOM 结构，实现视图更新。\n- **独立隔离**：每个类组件实例的 state 都是独立的，不同实例之间的状态互不影响。\n\n# 2. setState 基础用法\n`setState` 是 React 提供的用于更新 state 的方法，接收两个参数，语法如下：\n```jsx\nthis.setState(stateChange[, callback]);\n// 或\nthis.setState((prevState, props) => stateChange[, callback]);\n```\n\n## 2.1 两种调用方式\n### （1）对象式更新（适用于不依赖旧状态的场景）\n直接传递一个**状态更新对象**，指定需要修改的属性，未指定的属性会保持不变。\n```jsx\nclass Counter extends React.Component {\n  state = { count: 0 };\n\n  handleIncrement = () => {\n    // 对象式更新：直接设置新值\n    this.setState({ count: this.state.count + 1 });\n  };\n\n  render() {\n    return (\n      <div>\n        <p>计数：{this.state.count}</p>\n        <button onClick={this.handleIncrement}>+1</button>\n      </div>\n    );\n  }\n}\n```\n\n### （2）函数式更新（适用于依赖旧状态的场景）\n传递一个**回调函数**，函数接收两个参数：`prevState`（更新前的 state）和 `props`（当前组件的 props），返回一个状态更新对象。\n```jsx\nclass Counter extends React.Component {\n  state = { count: 0 };\n\n  handleIncrement = () => {\n    // 函数式更新：依赖旧状态计算新值\n    this.setState((prevState, props) => {\n      return { count: prevState.count + 1 };\n    });\n  };\n\n  render() {\n    return (\n      <div>\n        <p>计数：{this.state.count}</p>\n        <button onClick={this.handleIncrement}>+1</button>\n      </div>\n    );\n  }\n}\n```\n\n## 2.2 第二个参数：更新完成后的回调\n`setState` 的第二个参数是一个可选的回调函数，会在**状态更新完成且组件重新渲染后**执行，可用于获取更新后的 DOM 或执行后续逻辑。\n```jsx\nhandleIncrement = () => {\n  this.setState({ count: this.state.count + 1 }, () => {\n    // 回调函数中：state 已更新，DOM 已重新渲染\n    console.log('更新后的 count：', this.state.count);\n    console.log('DOM 中的计数：', document.querySelector('p').innerText);\n  });\n\n  // 这里的 state 还是更新前的值（因为 setState 是异步的）\n  console.log('当前 count：', this.state.count);\n};\n```\n\n# 3. setState 异步更新特性\n## 3.1 核心表现\n在 React 合成事件（如 `onClick`、`onChange`）和生命周期钩子（如 `componentDidMount`）中，`setState` 是**异步执行**的：调用 `setState` 后，不会立即更新 `this.state`，而是将状态更新请求加入队列，等待合适的时机批量处理。\n```jsx\nclass Counter extends React.Component {\n  state = { count: 0 };\n\n  handleIncrement = () => {\n    console.log('更新前 count：', this.state.count); // 输出 0\n\n    this.setState({ count: this.state.count + 1 });\n    console.log('调用 setState 后 count：', this.state.count); // 输出 0（异步未更新）\n  };\n\n  render() {\n    return <button onClick={this.handleIncrement}>+1</button>;\n  }\n}\n```\n\n## 3.2 为什么要设计成异步？\n- **性能优化**：避免频繁的 state 更新导致组件反复渲染，React 会将多个 `setState` 请求合并为一次更新，减少 DOM 操作次数。\n- **保证状态一致性**：确保组件状态和 DOM 状态同步，避免中间状态导致的 UI 混乱。\n\n## 3.3 如何获取异步更新后的状态？\n有两种可靠方式获取更新后的 state：\n- **使用 setState 的第二个参数（回调函数）**：如上文示例，回调函数会在状态更新完成后执行。\n- **在 componentDidUpdate 生命周期钩子中获取**：该钩子会在组件更新完成后触发。\n  ```jsx\n  componentDidUpdate(prevProps, prevState) {\n    // 状态更新完成后执行\n    console.log('更新后的 count：', this.state.count);\n  }\n  ```\n\n## 3.4 特殊场景：setState 同步更新\n在**原生 JavaScript 事件**（如 `addEventListener` 绑定的事件）、**定时器**（`setTimeout`/`setInterval`）、**异步函数**（`Promise.then`）中，`setState` 是**同步执行**的，调用后会立即更新 `this.state`。\n```jsx\nclass Counter extends React.Component {\n  state = { count: 0 };\n\n  componentDidMount() {\n    // 原生事件：setState 同步更新\n    document.getElementById('btn').addEventListener('click', () => {\n      this.setState({ count: this.state.count + 1 });\n      console.log('原生事件中 count：', this.state.count); // 输出 1\n    });\n\n    // 定时器：setState 同步更新\n    setTimeout(() => {\n      this.setState({ count: this.state.count + 1 });\n      console.log('定时器中 count：', this.state.count); // 输出 2\n    }, 1000);\n  }\n\n  render() {\n    return <button id=\"btn\">原生事件按钮</button>;\n  }\n}\n```\n\n# 4. setState 批量更新特性\n## 4.1 核心表现\n在 React 合成事件和生命周期钩子中，**多次调用 setState 会被合并为一次更新**，最终只触发一次 `render` 方法。\n```jsx\nclass Counter extends React.Component {\n  state = { count: 0 };\n\n  handleBatchUpdate = () => {\n    // 连续调用 3 次 setState\n    this.setState({ count: this.state.count + 1 });\n    this.setState({ count: this.state.count + 1 });\n    this.setState({ count: this.state.count + 1 });\n    // 最终 count 只增加 1，因为三次更新都基于同一个旧状态（0）\n  };\n\n  render() {\n    console.log('执行 render 方法');\n    return (\n      <div>\n        <p>计数：{this.state.count}</p>\n        <button onClick={this.handleBatchUpdate}>批量更新</button>\n      </div>\n    );\n  }\n}\n```\n点击按钮后，控制台只会输出一次 `执行 render 方法`，且 `count` 最终值为 `1`，而非 `3`。\n\n## 4.2 解决批量更新的依赖问题\n批量更新导致的问题本质是：多次更新都基于**同一个旧状态**计算新值。解决方法是使用**函数式更新**，因为函数式更新的回调函数会接收最新的 `prevState`（每次更新后的状态）。\n```jsx\nhandleBatchUpdate = () => {\n  // 函数式更新：每次都基于最新的 prevState 计算\n  this.setState(prevState => ({ count: prevState.count + 1 }));\n  this.setState(prevState => ({ count: prevState.count + 1 }));\n  this.setState(prevState => ({ count: prevState.count + 1 }));\n  // 最终 count 增加 3，达到预期效果\n};\n```\n\n# 5. 核心总结\n1. **state 初始化**：类组件可通过类实例属性或 `constructor` 初始化 state，state 是不可直接修改的对象。\n2. **setState 两种方式**：\n   - 对象式更新：适用于不依赖旧状态的场景。\n   - 函数式更新：适用于依赖旧状态或批量更新的场景，推荐优先使用。\n3. **异步更新特性**：\n   - React 合成事件和生命周期钩子中，`setState` 是异步的，需通过回调函数或 `componentDidUpdate` 获取更新后的状态。\n   - 原生事件、定时器、异步函数中，`setState` 是同步的。\n4. **批量更新特性**：\n   - 合成事件和生命周期中，多次 `setState` 会合并为一次更新，减少渲染次数。\n   - 依赖旧状态的批量更新，必须使用函数式更新。\n","directory_id":"e42a3397-52b2-470f-a87d-08e025ba6944","is_published":true,"created_at":"2025-12-19 11:37:25.28939+00","updated_at":"2025-12-19 11:37:25.28939+00"},{"id":"7c078f52-9a91-417a-82e6-3aac1b24e90b","title":"useContext：跨组件取值","content":"在 React 组件树中，组件之间的通信通常通过 `props` 实现，但当组件层级较深（如爷爷组件 → 父组件 → 子组件 → 孙组件）时，逐层传递 `props` 会导致“props 透传”问题（中间组件无需使用该数据，却必须中转传递），代码冗余且维护成本高。`useContext` 是 React 提供的用于解决**跨层级组件通信**的 Hook，配合 `createContext` 可实现数据的“全局共享”，让任意层级的组件直接访问共享数据。\n\n# 1. Context 核心概念与工作流程\n## 1.1 什么是 Context？\nContext 是 React 提供的一种“上下文”机制，用于在组件树中共享**全局数据**（如主题、用户信息、权限配置），避免 props 透传。Context 包含三个核心部分：\n- **Context 对象**：通过 `React.createContext` 创建，用于存储共享数据的容器。\n- **Provider 组件**：Context 对象的属性，用于“提供”数据，包裹需要共享数据的组件树。\n- **Consumer**：用于“消费”数据（类组件使用 `Context.Consumer`，函数组件使用 `useContext`）。\n\n## 1.2 useContext 工作流程\n1. **创建 Context**：使用 `createContext` 创建 Context 对象，可指定默认值（仅在无 Provider 时生效）。\n2. **提供数据**：使用 `Context.Provider` 包裹组件树，通过 `value` 属性传递共享数据。\n3. **消费数据**：在任意子组件中使用 `useContext(Context)` 获取共享数据，无需逐层传递 props。\n\n# 2. useContext 基础用法\n## 步骤1：创建 Context 对象\n推荐将 Context 单独封装在一个文件中，便于复用和维护：\n```jsx\n// src/contexts/ThemeContext.js\nimport { createContext } from 'react';\n\n// 创建 Context，指定默认值（仅无 Provider 时生效）\nconst ThemeContext = createContext({\n  theme: 'light', // 默认主题：亮色\n  toggleTheme: () => {} // 默认空函数\n});\n\nexport default ThemeContext;\n```\n\n## 步骤2：使用 Provider 提供数据\n在组件树的顶层组件（如 App 组件）中，使用 `ThemeContext.Provider` 包裹子组件，并通过 `value` 属性传递共享数据（状态 + 方法）：\n```jsx\n// src/App.jsx\nimport { useState } from 'react';\nimport ThemeContext from './contexts/ThemeContext';\nimport ParentComponent from './ParentComponent';\n\nfunction App() {\n  // 共享状态：主题\n  const [theme, setTheme] = useState('light');\n\n  // 共享方法：切换主题\n  const toggleTheme = () => {\n    setTheme(prev => prev === 'light' ? 'dark' : 'light');\n  };\n\n  // 传递给 Provider 的 value（包含状态和方法）\n  const themeValue = {\n    theme,\n    toggleTheme\n  };\n\n  return (\n    {/* Provider 包裹需要共享数据的组件树 */}\n    <ThemeContext.Provider value={themeValue}>\n      <div className={`app ${theme}`}>\n        <h1>Context 示例</h1>\n        <ParentComponent />\n      </div>\n    </ThemeContext.Provider>\n  );\n}\n\nexport default App;\n```\n\n## 步骤3：使用 useContext 消费数据\n在任意层级的子组件中（即使是深层子组件），使用 `useContext` 获取共享数据，无需 props 传递：\n```jsx\n// src/ParentComponent.jsx（中间组件，无需透传数据）\nimport ChildComponent from './ChildComponent';\n\nfunction ParentComponent() {\n  // 中间组件无需处理主题数据，直接渲染子组件\n  return (\n    <div className=\"parent\">\n      <h2>父组件</h2>\n      <ChildComponent />\n    </div>\n  );\n}\n\nexport default ParentComponent;\n```\n\n```jsx\n// src/ChildComponent.jsx（深层子组件，消费数据）\nimport { useContext } from 'react';\nimport ThemeContext from './contexts/ThemeContext';\n\nfunction ChildComponent() {\n  // 使用 useContext 获取共享数据\n  const { theme, toggleTheme } = useContext(ThemeContext);\n\n  return (\n    <div className={`child ${theme}`}>\n      <h3>子组件（当前主题：{theme}）</h3>\n      <button onClick={toggleTheme}>切换主题</button>\n    </div>\n  );\n}\n\nexport default ChildComponent;\n```\n\n# 3. Context 默认值的生效条件\n`createContext(defaultValue)` 中的默认值**仅在以下场景生效**：\n1. 组件没有被对应的 `Context.Provider` 包裹。\n2. 组件所在的组件树中，没有找到匹配的 `Context.Provider`。\n\n默认值**不会**在 `Provider` 的 `value` 为 `undefined` 时生效：\n```jsx\n// 场景1：无 Provider，使用默认值\nfunction NoProviderComponent() {\n  const { theme } = useContext(ThemeContext);\n  console.log(theme); // 输出：light（默认值）\n  return <div>无 Provider 组件</div>;\n}\n\n// 场景2：有 Provider 但 value 为 undefined，不使用默认值\nfunction UndefinedValueComponent() {\n  return (\n    <ThemeContext.Provider value={undefined}>\n      <ChildComponent /> {/* 子组件获取到的 theme 为 undefined */}\n    </ThemeContext.Provider>\n  );\n}\n```\n\n# 4. 多 Context 联合使用\n实际开发中，往往需要共享多种类型的数据（如主题、用户信息），此时可创建多个独立的 Context，并嵌套使用 `Provider`，子组件通过多次调用 `useContext` 获取不同的 Context 数据。\n\n## 4.1 创建多个 Context\n```jsx\n// src/contexts/UserContext.js\nimport { createContext } from 'react';\n\nconst UserContext = createContext({\n  name: '匿名用户',\n  role: 'guest'\n});\n\nexport default UserContext;\n```\n\n## 4.2 嵌套 Provider 提供数据\n```jsx\n// src/App.jsx\nimport { useState } from 'react';\nimport ThemeContext from './contexts/ThemeContext';\nimport UserContext from './contexts/UserContext';\nimport ChildComponent from './ChildComponent';\n\nfunction App() {\n  const [theme, setTheme] = useState('light');\n  const [user, setUser] = useState({ name: 'React 开发者', role: 'admin' });\n\n  return (\n    {/* 嵌套 Provider，顺序不影响 */}\n    <UserContext.Provider value={user}>\n      <ThemeContext.Provider value={{ theme, toggleTheme: () => setTheme(prev => prev === 'light' ? 'dark' : 'light') }}>\n        <ChildComponent />\n      </ThemeContext.Provider>\n    </UserContext.Provider>\n  );\n}\n```\n\n## 4.3 消费多个 Context 数据\n```jsx\n// src/ChildComponent.jsx\nimport { useContext } from 'react';\nimport ThemeContext from './contexts/ThemeContext';\nimport UserContext from './contexts/UserContext';\n\nfunction ChildComponent() {\n  // 多次调用 useContext，获取不同的 Context 数据\n  const { theme, toggleTheme } = useContext(ThemeContext);\n  const { name, role } = useContext(UserContext);\n\n  return (\n    <div className={theme}>\n      <p>当前用户：{name}（角色：{role}）</p>\n      <p>当前主题：{theme}</p>\n      <button onClick={toggleTheme}>切换主题</button>\n    </div>\n  );\n}\n```\n\n# 5. useContext 性能优化\n## 5.1 问题：Provider 的 value 变化导致子组件重渲染\n当 `Context.Provider` 的 `value` 属性发生变化（引用变化）时，所有消费该 Context 的子组件都会重新渲染，即使子组件只使用了 `value` 中的部分数据。\n\n### 示例：不必要的重渲染\n```jsx\n// App.jsx\nfunction App() {\n  const [theme, setTheme] = useState('light');\n  const [count, setCount] = useState(0);\n\n  // 每次渲染都会创建新的对象（引用变化），导致子组件重渲染\n  const value = {\n    theme,\n    toggleTheme: () => setTheme(prev => prev === 'light' ? 'dark' : 'light')\n  };\n\n  return (\n    <ThemeContext.Provider value={value}>\n      <ChildComponent />\n      <button onClick={() => setCount(count + 1)}>计数+1</button>\n    </ThemeContext.Provider>\n  );\n}\n```\n上述代码中，点击“计数+1”按钮会导致 `App` 组件重新渲染，创建新的 `value` 对象（引用变化），即使 `theme` 没有变化，`ChildComponent` 也会重新渲染。\n\n## 5.2 优化方案\n### 方案1：使用 useMemo 缓存 value 对象\n通过 `useMemo` 缓存 `value` 对象，仅当依赖项变化时才创建新对象：\n```jsx\nfunction App() {\n  const [theme, setTheme] = useState('light');\n  const [count, setCount] = useState(0);\n\n  // 使用 useMemo 缓存 value，仅 theme 变化时更新\n  const value = useMemo(() => ({\n    theme,\n    toggleTheme: () => setTheme(prev => prev === 'light' ? 'dark' : 'light')\n  }), [theme]);\n\n  return (\n    <ThemeContext.Provider value={value}>\n      <ChildComponent />\n      <button onClick={() => setCount(count + 1)}>计数+1</button>\n    </ThemeContext.Provider>\n  );\n}\n```\n\n### 方案2：拆分 Context\n将大的 Context 拆分为多个小的 Context，让子组件仅消费需要的 Context，避免因无关数据变化导致重渲染：\n```jsx\n// 拆分主题状态和主题方法为两个 Context\nconst ThemeStateContext = createContext('light');\nconst ThemeActionContext = createContext(() => {});\n\n// Provider 分别提供数据\nfunction ThemeProvider({ children }) {\n  const [theme, setTheme] = useState('light');\n  const toggleTheme = () => setTheme(prev => prev === 'light' ? 'dark' : 'light');\n\n  return (\n    <ThemeStateContext.Provider value={theme}>\n      <ThemeActionContext.Provider value={toggleTheme}>\n        {children}\n      </ThemeActionContext.Provider>\n    </ThemeStateContext.Provider>\n  );\n}\n\n// 子组件按需消费\nfunction ChildComponent() {\n  const theme = useContext(ThemeStateContext); // 仅依赖主题状态\n  return <p>当前主题：{theme}</p>;\n}\n```\n\n### 方案3：使用 React.memo 包装纯组件\n对于仅展示数据的纯组件，使用 `React.memo` 包装，避免不必要的重渲染：\n```jsx\n// ChildComponent.jsx\nimport { memo, useContext } from 'react';\nimport ThemeContext from './contexts/ThemeContext';\n\n// 使用 memo 包装，仅 props 或 Context 数据变化时重渲染\nconst ChildComponent = memo(() => {\n  const { theme } = useContext(ThemeContext);\n  console.log('ChildComponent 渲染');\n  return <p>当前主题：{theme}</p>;\n});\n\nexport default ChildComponent;\n```\n\n# 6. useContext 与其他通信方案的对比\n| 通信方案       | 适用场景                     | 优点                     | 缺点                     |\n|----------------|------------------------------|--------------------------|--------------------------|\n| props 传递     | 父子组件、层级较浅的组件     | 简单直观，无额外 API      | 层级深时 props 透传      |\n| useContext     | 跨层级组件、全局共享数据     | 避免 props 透传，代码简洁 | 过度使用导致组件耦合度高 |\n| Redux/Zustand  | 大型应用、全局复杂状态管理   | 状态管理集中，支持中间件  | 学习成本高，配置繁琐     |\n\n# 7. 核心总结\n1. **核心作用**：解决跨层级组件通信问题，避免 props 透传，实现全局数据共享。\n2. **基本用法**：\n   - `createContext` 创建 Context 对象。\n   - `Context.Provider` 提供数据（value 属性）。\n   - `useContext(Context)` 消费数据。\n3. **性能优化**：\n   - 使用 `useMemo` 缓存 Provider 的 value 对象，避免不必要的重渲染。\n   - 拆分 Context，按需消费，减少组件依赖。\n   - 使用 `React.memo` 包装纯组件，优化渲染性能。\n4. **使用场景**：\n   - 全局共享数据（主题、用户信息、权限配置）。\n   - 跨层级组件通信（层级 ≥3 层）。\n   - 避免滥用：局部组件通信优先使用 props，全局复杂状态优先使用 Redux/Zustand。...","directory_id":"8ef7f873-12e2-4aaf-933f-26eddf895f27","is_published":true,"created_at":"2025-12-19 15:11:24.370221+00","updated_at":"2025-12-22 02:03:16.808099+00"},{"id":"7c964cbe-c2d9-473f-86cb-be3a904ac4ba","title":"useRef：DOM 引用与持久化变量","content":"`useRef` 是 React 中用于创建“持久化引用”的 Hook，核心作用有两个：一是获取 DOM 元素的引用（替代类组件的 `createRef`），二是存储组件生命周期内持久不变的值（不会因组件重新渲染而重置）。`useRef` 提供了一种在函数组件中保存“跨渲染数据”的方案，且修改其值不会触发组件重新渲染。\n\n# 1. useRef 基础语法与核心特性\n## 1.1 基本语法\n```jsx\nimport { useRef } from 'react';\n\nfunction MyComponent() {\n  // 创建 ref 对象，initialValue 为初始值（可选）\n  const refContainer = useRef(initialValue);\n\n  // ref 对象的核心属性：current，用于存储引用值\n  // 读取：refContainer.current\n  // 修改：refContainer.current = newValue\n\n  return <div ref={refContainer}>Hello useRef</div>;\n}\n```\n\n## 1.2 核心特性\n- **持久化**：`ref.current` 中存储的值在组件整个生命周期内保持不变，组件重新渲染时不会重置。\n- **非响应式**：修改 `ref.current` 的值不会触发组件重新渲染（这是与 `useState` 的核心区别）。\n- **通用性**：可存储任意类型的值（DOM 元素、普通变量、对象、函数等）。\n\n## 2. 场景1：获取 DOM 元素引用（DOM 操作）\n在 React 中，直接操作 DOM 是不推荐的，但某些场景下（如获取 DOM 尺寸、聚焦输入框、播放视频）必须操作 DOM，`useRef` 是官方推荐的 DOM 引用方案。\n\n## 2.1 基础用法：获取单个 DOM 元素\n```jsx\nimport { useRef, useEffect } from 'react';\n\nfunction InputFocus() {\n  // 创建 ref 对象，用于引用 input 元素\n  const inputRef = useRef(null);\n\n  useEffect(() => {\n    // 组件挂载后，通过 inputRef.current 获取 DOM 元素并聚焦\n    inputRef.current.focus();\n  }, []);\n\n  return (\n    <input\n      ref={inputRef} // 将 ref 绑定到 input 元素\n      type=\"text\"\n      placeholder=\"自动聚焦的输入框\"\n    />\n  );\n}\n```\n\n## 2.2 进阶用法：获取列表中的 DOM 元素\n若需获取列表中多个 DOM 元素，可创建 ref 数组：\n```jsx\nimport { useRef, useEffect } from 'react';\n\nfunction ListRef() {\n  // 创建 ref 数组，存储多个 DOM 引用\n  const itemRefs = useRef([]);\n\n  useEffect(() => {\n    // 打印第一个列表项的 DOM 元素\n    console.log(itemRefs.current[0]);\n  }, []);\n\n  const items = ['Item 1', 'Item 2', 'Item 3'];\n\n  return (\n    <ul>\n      {items.map((item, index) => (\n        <li\n          key={index}\n          // 动态绑定 ref 到数组对应位置\n          ref={el => itemRefs.current[index] = el}\n        >\n          {item}\n        </li>\n      ))}\n    </ul>\n  );\n}\n```\n\n## 2.3 注意事项\n- 绑定 DOM 的 ref 仅在组件挂载后才会有值（`current` 不为 null），挂载前访问会报错。\n- 函数组件无法直接通过 ref 引用（需使用 `forwardRef` 转发 ref）。\n- 避免通过 ref 直接修改 DOM 样式/内容，优先通过 state 控制（仅特殊场景使用）。\n\n# 3. 场景2：存储持久化变量（跨渲染数据）\n`useRef` 的另一个核心用途是存储“不需要触发渲染的持久化数据”，例如：\n- 定时器 ID（用于组件卸载时清除）。\n- 上一次的状态/属性值（用于对比变化）。\n- 复杂计算的中间结果（无需响应式）。\n\n## 3.1 示例1：存储定时器 ID\n```jsx\nimport { useRef, useEffect, useState } from 'react';\n\nfunction Timer() {\n  const [count, setCount] = useState(0);\n  // 存储定时器 ID，跨渲染保留\n  const timerRef = useRef(null);\n\n  const startTimer = () => {\n    // 启动定时器，将 ID 存入 ref\n    timerRef.current = setInterval(() => {\n      setCount(prev => prev + 1);\n    }, 1000);\n  };\n\n  const stopTimer = () => {\n    // 从 ref 中获取定时器 ID 并清除\n    clearInterval(timerRef.current);\n  };\n\n  useEffect(() => {\n    // 组件卸载时清除定时器\n    return () => clearInterval(timerRef.current);\n  }, []);\n\n  return (\n    <div>\n      <p>计数：{count}</p>\n      <button onClick={startTimer}>启动</button>\n      <button onClick={stopTimer}>停止</button>\n    </div>\n  );\n}\n```\n\n## 3.2 示例2：存储上一次的状态值\n```jsx\nimport { useRef, useEffect, useState } from 'react';\n\nfunction PreviousState() {\n  const [count, setCount] = useState(0);\n  // 存储上一次的 count 值\n  const prevCountRef = useRef(0);\n\n  useEffect(() => {\n    // 每次 count 变化后，更新 ref 中的值\n    prevCountRef.current = count;\n  }, [count]);\n\n  return (\n    <div>\n      <p>当前值：{count}</p>\n      <p>上一次值：{prevCountRef.current}</p>\n      <button onClick={() => setCount(prev => prev + 1)}>+1</button>\n    </div>\n  );\n}\n```\n\n## 3.3 与 useState 的区别\n| 特性         | useRef                          | useState                        |\n|--------------|---------------------------------|---------------------------------|\n| 响应式       | 非响应式，修改不触发渲染        | 响应式，修改触发渲染            |\n| 持久化       | 组件生命周期内持久不变          | 每次渲染返回当前值              |\n| 用途         | 存储非响应式数据、DOM 引用      | 存储响应式状态                  |\n| 语法         | 直接修改 `ref.current`          | 必须通过更新函数修改            |\n\n# 4. 场景3：解决 useEffect 闭包陷阱\n在 `useEffect` 中，若依赖项数组为空，副作用函数会捕获初始渲染的状态值，后续状态更新后无法获取最新值（闭包陷阱），使用 `useRef` 可解决此问题。\n\n## 4.1 闭包陷阱示例\n```jsx\n// 问题：定时器中始终获取初始 count 值（0）\nfunction ClosureTrap() {\n  const [count, setCount] = useState(0);\n\n  useEffect(() => {\n    const timer = setInterval(() => {\n      console.log('当前 count：', count); // 始终输出 0\n    }, 1000);\n    return () => clearInterval(timer);\n  }, []);\n\n  return (\n    <div>\n      <p>count：{count}</p>\n      <button onClick={() => setCount(prev => prev + 1)}>+1</button>\n    </div>\n  );\n}\n```\n\n## 4.2 使用 useRef 解决\n```jsx\nfunction FixClosureTrap() {\n  const [count, setCount] = useState(0);\n  // 创建 ref 存储最新 count 值\n  const countRef = useRef(count);\n\n  // 每次 count 变化，更新 ref 的值（不触发渲染）\n  useEffect(() => {\n    countRef.current = count;\n  }, [count]);\n\n  useEffect(() => {\n    const timer = setInterval(() => {\n      // 从 ref 中获取最新 count 值\n      console.log('当前 count：', countRef.current);\n    }, 1000);\n    return () => clearInterval(timer);\n  }, []);\n\n  return (\n    <div>\n      <p>count：{count}</p>\n      <button onClick={() => setCount(prev => prev + 1)}>+1</button>\n    </div>\n  );\n}\n```\n\n# 5. useRef 与 createRef 的区别\n| 特性         | useRef                          | createRef                       |\n|--------------|---------------------------------|---------------------------------|\n| 作用域       | 组件内持久化（跨渲染保留）| 每次渲染创建新的 ref 对象       |\n| 适用场景     | 函数组件（推荐）| 类组件                          |\n| 性能         | 更优（仅初始化一次）| 每次渲染重建，性能较差          |\n\n示例：`createRef` 每次渲染重建\n```jsx\nimport { createRef, useState } from 'react';\n\nfunction CreateRefDemo() {\n  const [count, setCount] = useState(0);\n  // 每次渲染都会创建新的 ref 对象\n  const ref = createRef();\n\n  console.log('ref 对象是否变化：', ref); // 每次渲染都不同\n\n  return (\n    <div>\n      <p>count：{count}</p>\n      <button onClick={() => setCount(prev => prev + 1)}>+1</button>\n    </div>\n  );\n}\n```\n\n# 6. 核心总结\n1. **核心作用**：\n   - 获取 DOM 元素引用，实现必要的 DOM 操作。\n   - 存储持久化、非响应式数据，跨渲染保留值。\n2. **关键特性**：\n   - `ref.current` 是存储值的唯一属性，修改不触发渲染。\n   - 组件生命周期内持久不变，不会因重新渲染重置。\n3. **典型场景**：\n   - DOM 操作（聚焦输入框、获取尺寸）。\n   - 存储定时器 ID、上一次状态值。\n   - 解决 useEffect 闭包陷阱。\n4. **注意事项**：\n   - 避免滥用 ref 操作 DOM，优先通过 state 控制 UI。\n   - 函数组件需使用 `forwardRef` 转发 ref。\n   - 区别于 `useState`（非响应式）和 `createRef`（非持久化）。","directory_id":"aac29662-babe-4c96-8f61-0a16830155d4","is_published":true,"created_at":"2025-12-19 15:11:58.078139+00","updated_at":"2025-12-22 02:18:09.730825+00"},{"id":"81f30ac0-7ddc-4c96-a78c-f230bfe90c67","title":"国际化（react-i18next）","content":"# 1. 国际化核心概念\n国际化（i18n）是指让应用支持多语言切换，核心需求包括：\n- 文本翻译：界面文字、提示信息支持多语言；\n- 日期/时间/数字格式化：适配不同地区的显示规则；\n- 动态语言切换：无需刷新页面，实时切换语言；\n- 占位符替换：支持动态内容（如「你好，{{name}}」）；\n- 复数处理：不同语言的复数规则（如英语 one/many，中文无复数）。\n\nreact-i18next 是基于 i18next 的 React 国际化解决方案，相比传统方案（如 react-intl），优势在于：\n- 轻量级、高性能；\n- 支持前后端共享翻译资源；\n- 丰富的插件生态（如本地化存储、自动检测语言）；\n- 支持 Hook/高阶组件/组件三种使用方式。\n\n# 2. 安装与基础配置\n## 2.1 安装依赖\n```bash\nnpm install i18next react-i18next # 核心依赖\nnpm install i18next-browser-languagedetector i18next-localstorage-cache # 可选插件（自动检测浏览器语言、本地化存储）\n```\n\n## 2.2 初始化 i18n（src/i18n/index.ts）\n```typescript\nimport i18n from 'i18next';\nimport { initReactI18next } from 'react-i18next';\nimport LanguageDetector from 'i18next-browser-languagedetector';\nimport Cache from 'i18next-localstorage-cache';\n\n// 翻译资源\nconst resources = {\n  en: {\n    translation: {\n      \"welcome\": \"Welcome to our app\",\n      \"hello\": \"Hello, {{name}}\",\n      \"count\": {\n        \"one\": \"{{count}} item\",\n        \"other\": \"{{count}} items\"\n      },\n      \"button\": {\n        \"login\": \"Login\",\n        \"logout\": \"Logout\"\n      }\n    }\n  },\n  zh: {\n    translation: {\n      \"welcome\": \"欢迎来到我们的应用\",\n      \"hello\": \"你好，{{name}}\",\n      \"count\": {\n        \"one\": \"{{count}} 个项目\",\n        \"other\": \"{{count}} 个项目\"\n      },\n      \"button\": {\n        \"login\": \"登录\",\n        \"logout\": \"退出登录\"\n      }\n    }\n  }\n};\n\ni18n\n  // 集成 React 插件\n  .use(initReactI18next)\n  // 自动检测浏览器语言\n  .use(LanguageDetector)\n  // 缓存语言设置\n  .use(Cache)\n  // 初始化配置\n  .init({\n    resources,\n    fallbackLng: 'zh', // 默认语言\n    debug: process.env.NODE_ENV === 'development', // 开发环境开启调试\n    interpolation: {\n      escapeValue: false, // React 已默认转义，无需重复处理\n    },\n    detection: {\n      // 检测语言的顺序（本地存储 > cookie > 浏览器语言 > 默认语言）\n      order: ['localStorage', 'cookie', 'navigator'],\n      caches: ['localStorage', 'cookie'], // 缓存语言设置到本地存储和 cookie\n    },\n    cache: {\n      enabled: true, // 启用缓存\n    }\n  });\n\nexport default i18n;\n```\n\n## 2.3 全局注入（src/main.tsx）\n```typescript\nimport React from 'react';\nimport ReactDOM from 'react-dom/client';\nimport './i18n'; // 导入 i18n 配置\nimport App from './App';\n\nconst root = ReactDOM.createRoot(document.getElementById('root')!);\nroot.render(<App />);\n```\n\n# 3. 核心使用方式\n## 3.1 Hook 方式（推荐）\n使用 `useTranslation` Hook 实现组件内国际化：\n```tsx\nimport React from 'react';\nimport { useTranslation } from 'react-i18next';\n\nconst HomePage = () => {\n  const { t, i18n } = useTranslation();\n\n  // 切换语言\n  const changeLanguage = (lng: 'en' | 'zh') => {\n    i18n.changeLanguage(lng);\n  };\n\n  return (\n    <div>\n      <h1>{t('welcome')}</h1>\n      <p>{t('hello', { name: '张三' })}</p>\n      <p>{t('count.one', { count: 1 })}</p>\n      <p>{t('count.other', { count: 5 })}</p>\n      <button onClick={() => changeLanguage('en')}>English</button>\n      <button onClick={() => changeLanguage('zh')}>中文</button>\n      <button>{t('button.login')}</button>\n    </div>\n  );\n};\n\nexport default HomePage;\n```\n\n## 3.2 组件方式\n使用 `Trans` 组件支持富文本翻译（如包含 HTML 标签、React 组件）：\n```tsx\nimport React from 'react';\nimport { Trans } from 'react-i18next';\n\nconst RichText = () => {\n  return (\n    <div>\n      <Trans i18nKey=\"richText\">\n        请<a href=\"/terms\">阅读用户协议</a>并确认，<strong>否则无法使用</strong>。\n      </Trans>\n    </div>\n  );\n};\n\n// 翻译资源中配置：\n// \"richText\": \"请<a>{{0}}</a>并确认，<strong>{{1}}</strong>否则无法使用。\"\n```\n\n## 3.3 高阶组件方式\n```tsx\nimport React from 'react';\nimport { withTranslation } from 'react-i18next';\n\nconst LoginButton = ({ t }) => {\n  return <button>{t('button.login')}</button>;\n};\n\nexport default withTranslation()(LoginButton);\n```\n\n# 4. 高级功能\n## 4.1 命名空间（Namespaces）\n拆分翻译资源为多个命名空间（如公共翻译、用户模块翻译），按需加载：\n```typescript\n// 初始化时配置命名空间\ni18n.init({\n  ns: ['common', 'user'], // 命名空间列表\n  defaultNS: 'common', // 默认命名空间\n});\n\n// 组件中指定命名空间\nconst { t } = useTranslation('user'); // 使用 user 命名空间\nt('profile.name'); // 读取 user 命名空间的 profile.name\n\n// 多命名空间\nconst { t } = useTranslation(['common', 'user']);\nt('common:welcome'); // 显式指定命名空间\n```\n\n## 4.2 动态加载翻译资源\n避免一次性加载所有语言资源，提升首屏加载速度：\n```typescript\n// src/i18n/translations.ts\nexport const loadTranslations = (lng: string) => {\n  return import(`./locales/${lng}/translation.json`);\n};\n\n// 初始化时配置\ni18n\n  .use(initReactI18next)\n  .init({\n    fallbackLng: 'zh',\n    interpolation: { escapeValue: false },\n    // 动态加载资源\n    backend: {\n      loadPath: '/locales/{{lng}}/{{ns}}.json',\n    },\n  });\n\n// 组件中按需加载\nconst { t, i18n } = useTranslation();\ni18n.loadNamespaces('cart').then(() => {\n  // 加载 cart 命名空间后使用\n  console.log(t('cart:total'));\n});\n```\n\n## 4.3 日期/数字格式化\n结合 `i18next-intl-fallback` 或 `date-fns` 实现本地化格式化：\n```bash\nnpm install date-fns @formatjs/intl-localematcher\n```\n\n```typescript\nimport { formatDate, formatNumber } from 'date-fns';\nimport { zhCN, enUS } from 'date-fns/locale';\n\nconst formatters = {\n  en: {\n    date: (date) => formatDate(date, 'MM/dd/yyyy', { locale: enUS }),\n    number: (num) => formatNumber(num, { style: 'currency', currency: 'USD' }),\n  },\n  zh: {\n    date: (date) => formatDate(date, 'yyyy年MM月dd日', { locale: zhCN }),\n    number: (num) => formatNumber(num, { style: 'currency', currency: 'CNY' }),\n  },\n};\n\n// 组件中使用\nconst { i18n } = useTranslation();\nconst currentLocale = i18n.language;\nconsole.log(formatters[currentLocale].date(new Date()));\nconsole.log(formatters[currentLocale].number(100));\n```\n\n## 4.4 复数处理\n适配不同语言的复数规则（i18next 内置复数处理）：\n```json\n// 翻译资源\n{\n  \"items\": {\n    \"zero\": \"没有项目\",\n    \"one\": \"1 个项目\",\n    \"two\": \"2 个项目\",\n    \"few\": \"{{count}} 个项目\",\n    \"many\": \"{{count}} 个项目\",\n    \"other\": \"{{count}} 个项目\"\n  }\n}\n```\n\n```tsx\nconst { t } = useTranslation();\nt('items', { count: 0 }); // 没有项目\nt('items', { count: 1 }); // 1 个项目\nt('items', { count: 5 }); // 5 个项目\n```\n\n# 5. 最佳实践\n## 5.1 翻译资源管理\n- 按模块拆分翻译文件（如 `common.json`/`user.json`/`cart.json`）；\n- 使用 JSON 格式存储翻译资源，便于团队协作和翻译工具导入；\n- 翻译键名使用驼峰命名或点分隔（如 `button.login`/`user.profile.name`），避免重复。\n\n## 5.2 避免硬编码\n- 所有界面文本均通过 `t()` 函数获取，禁止硬编码；\n- 动态内容使用占位符（如 `{{name}}`），避免拼接字符串。\n\n## 5.3 语言切换优化\n- 语言切换时，缓存当前语言到本地存储，下次打开自动恢复；\n- 避免语言切换后页面跳转，使用 React 状态管理实现无刷新切换。\n\n## 5.4 生产环境配置\n- 关闭 `debug` 模式，减少日志输出；\n- 压缩翻译资源文件，开启 Gzip 压缩；\n- 按需加载翻译资源，提升首屏加载速度。\n\n# 6. 常见问题解决\n## 6.1 翻译键未找到（missingKey）\n- 检查翻译资源中是否存在对应键名；\n- 确认命名空间是否正确（默认使用 `common` 命名空间）；\n- 开启 `debug` 模式，控制台查看缺失的键名和命名空间。\n\n## 6.2 动态加载翻译资源失败\n- 检查资源路径是否正确（如 `/locales/en/common.json`）；\n- 确认服务器配置了静态资源访问权限；\n- 使用 `i18n.loadNamespaces` 手动加载命名空间，捕获加载错误。\n\n## 6.3 语言切换后组件未重新渲染\n- 确保使用 `useTranslation` Hook 或 `Trans` 组件（自动监听语言变化）；\n- 高阶组件方式需确保组件接收 `t` 函数作为 props；\n- 手动监听语言变化：\n  ```tsx\n  const { i18n } = useTranslation();\n  useEffect(() => {\n    const handleLanguageChange = () => {\n      // 语言变化后执行逻辑\n    };\n    i18n.on('languageChanged', handleLanguageChange);\n    return () => {\n      i18n.off('languageChanged', handleLanguageChange);\n    };\n  }, [i18n]);\n  ```\n","directory_id":"ac88594f-879e-410b-94ce-266d80cce0f4","is_published":true,"created_at":"2025-12-22 03:22:17.246452+00","updated_at":"2025-12-23 14:32:25.997148+00"},{"id":"84b94df2-64a4-46af-ae9c-e8c5169837cc","title":"TypeScript 集成 React","content":"# 1. TypeScript 与 React 集成基础\nTypeScript 是 JavaScript 的超集，通过静态类型检查提升代码健壮性，与 React 集成的核心价值在于：\n- 对组件 Props、状态、Hooks 进行类型约束，减少运行时错误；\n- 编辑器智能提示，提升开发效率；\n- 明确代码接口，降低团队协作成本。\n\n## 1.1 初始化 TypeScript + React 项目\n- **Vite 项目**：直接选择 `react-ts` 模板\n  ```bash\n  npm create vite@latest my-react-ts-project -- --template react-ts\n  ```\n- **Webpack 项目**：需安装 TypeScript 及相关类型依赖\n  ```bash\n  npm install -D typescript @types/react @types/react-dom ts-loader\n  ```\n  并创建 `tsconfig.json`（参考 8.1 中 Webpack 配置章节）。\n\n## 1.2 核心类型依赖\nReact 项目中需安装的基础类型包：\n- `@types/react`：React 核心类型定义；\n- `@types/react-dom`：React DOM 相关类型定义；\n- `@types/node`（可选）：Node.js 环境类型（如路径别名）；\n- `@types/react-router-dom`（可选）：React Router 类型定义。\n\n# 2. Props 类型定义\nProps 是组件的输入参数，TypeScript 提供多种方式约束 Props 类型：\n\n## 2.1 基础 Props 类型（interface/type）\n使用 `interface` 或 `type` 定义 Props 结构：\n```tsx\n// 方式1：interface（推荐，支持扩展）\ninterface ButtonProps {\n  text: string; // 必传属性\n  onClick?: () => void; // 可选属性\n  type?: 'primary' | 'secondary'; // 联合类型（限定取值）\n  size: number;\n}\n\n// 方式2：type（灵活，支持交叉类型）\ntype ButtonProps = {\n  text: string;\n  onClick?: () => void;\n  type?: 'primary' | 'secondary';\n  size: number;\n};\n\nconst Button = (props: ButtonProps) => {\n  const { text, onClick, type = 'primary', size } = props;\n  return (\n    <button onClick={onClick} className={`btn btn-${type}`} style={{ fontSize: size }}>\n      {text}\n    </button>\n  );\n};\n```\n\n## 2.2 必传属性与默认值\n- 必传属性：直接定义类型（如 `text: string`），未传递时 TypeScript 报错；\n- 可选属性：添加 `?`（如 `onClick?: () => void`）；\n- 默认值：通过 `defaultProps` 或解构赋值设置，TypeScript 会自动识别：\n  ```tsx\n  // 解构赋值设置默认值\n  const Button = ({ text, type = 'primary' }: ButtonProps) => { /* ... */ };\n\n  // 或通过 defaultProps（类组件/函数组件均可）\n  Button.defaultProps = {\n    type: 'primary',\n  };\n  ```\n\n## 2.3 子组件（children）类型\n`children` 是 React 组件的特殊 Props，需显式定义类型：\n```tsx\ninterface CardProps {\n  title: string;\n  children: React.ReactNode; // 支持所有 React 可渲染节点（元素、文本、数组等）\n}\n\nconst Card = ({ title, children }: CardProps) => {\n  return (\n    <div className=\"card\">\n      <h3>{title}</h3>\n      <div className=\"card-content\">{children}</div>\n    </div>\n  );\n};\n\n// 使用\n<Card title=\"卡片标题\">\n  <p>卡片内容</p>\n</Card>\n```\n`React.ReactNode` 是最通用的 children 类型，包含：\n- `ReactElement`（组件/元素）；\n- `string`/`number`（文本）；\n- `null`/`undefined`；\n- 数组（`ReactNode[]`）。\n\n## 2.4 继承 Props 类型\n通过 `extends` 扩展已有 Props 类型：\n```tsx\ninterface BaseButtonProps {\n  disabled?: boolean;\n  className?: string;\n}\n\ninterface PrimaryButtonProps extends BaseButtonProps {\n  text: string;\n  onClick: () => void;\n}\n\nconst PrimaryButton = (props: PrimaryButtonProps) => { /* ... */ };\n```\n\n## 2.5 事件处理 Props 类型\nReact 事件有专属类型（如 `React.MouseEvent`），需匹配事件类型：\n```tsx\ninterface InputProps {\n  value: string;\n  onChange: (e: React.ChangeEvent<HTMLInputElement>) => void; // 输入框变更事件\n  onBlur: (e: React.FocusEvent<HTMLInputElement>) => void; // 失焦事件\n}\n\nconst Input = ({ value, onChange, onBlur }: InputProps) => {\n  return <input value={value} onChange={onChange} onBlur={onBlur} />;\n};\n\n// 使用\n<Input \n  value={inputValue} \n  onChange={(e) => setInputValue(e.target.value)} \n  onBlur={(e) => console.log('失焦', e.target.value)} \n/>\n```\n常见 React 事件类型：\n- `React.MouseEvent<HTMLElement>`：鼠标事件（点击、双击等）；\n- `React.ChangeEvent<HTMLInputElement>`：输入框/选择框变更事件；\n- `React.FormEvent<HTMLFormElement>`：表单提交事件；\n- `React.KeyboardEvent<HTMLInputElement>`：键盘事件。\n\n# 3. 状态（State）类型定义\nReact 状态分为类组件 `this.state` 和函数组件 `useState`，需明确状态类型：\n\n## 3.1 函数组件 useState 类型\n- **基础类型**：TypeScript 自动推导（推荐）\n  ```tsx\n  const [count, setCount] = useState(0); // 自动推导 count: number\n  const [name, setName] = useState(''); // 自动推导 name: string\n  const [isShow, setIsShow] = useState(false); // 自动推导 isShow: boolean\n  ```\n- **复杂类型**：需显式指定类型（或通过初始值推导）\n  ```tsx\n  // 数组类型\n  const [list, setList] = useState<string[]>([]); // 字符串数组\n  setList(['a', 'b']); // 正确\n  // setList([1, 2]); // 错误：类型不匹配\n\n  // 对象类型\n  interface User {\n    id: number;\n    name: string;\n    age?: number;\n  }\n  const [user, setUser] = useState<User>({ id: 1, name: '张三' }); // 显式指定类型\n  setUser({ id: 2, name: '李四', age: 20 }); // 正确\n  ```\n- **联合类型状态**：需显式指定\n  ```tsx\n  const [data, setData] = useState<string | number | null>(null);\n  setData('hello'); // 正确\n  setData(123); // 正确\n  setData(null); // 正确\n  ```\n\n## 3.2 类组件 state 类型\n类组件需通过接口定义 state 类型：\n```tsx\ninterface CounterState {\n  count: number;\n  message: string;\n}\n\nclass Counter extends React.Component<{}, CounterState> {\n  // 初始 state\n  state: CounterState = {\n    count: 0,\n    message: 'Hello',\n  };\n\n  increment = () => {\n    this.setState({ count: this.state.count + 1 });\n  };\n\n  render() {\n    return (\n      <div>\n        <p>{this.state.message}</p>\n        <p>Count: {this.state.count}</p>\n        <button onClick={this.increment}>+1</button>\n      </div>\n    );\n  }\n}\n```\n\n# 4. Hooks 类型定义\nReact 内置 Hooks 均有对应的类型约束，需正确指定类型以获得类型检查：\n\n## 4.1 useState（已在 1.3 中说明）\n\n## 4.2 useEffect/useLayoutEffect\n无返回值（或返回清理函数），TypeScript 自动推导，无需显式类型：\n```tsx\nuseEffect(() => {\n  const timer = setInterval(() => {\n    setCount(count + 1);\n  }, 1000);\n  // 清理函数\n  return () => clearInterval(timer);\n}, [count]);\n```\n\n## 4.3 useRef\n`useRef` 有两种用途：DOM 引用 / 持久化变量，需区分类型：\n- **DOM 引用**：指定元素类型，初始值为 `null`\n  ```tsx\n  const inputRef = useRef<HTMLInputElement>(null);\n\n  useEffect(() => {\n    if (inputRef.current) {\n      inputRef.current.focus(); // 类型安全：current 为 HTMLInputElement | null\n    }\n  }, []);\n\n  return <input ref={inputRef} />;\n  ```\n- **持久化变量**：指定变量类型，初始值为任意值\n  ```tsx\n  const timerRef = useRef<NodeJS.Timeout | null>(null);\n\n  const startTimer = () => {\n    timerRef.current = setInterval(() => { /* ... */ }, 1000);\n  };\n\n  const stopTimer = () => {\n    if (timerRef.current) {\n      clearInterval(timerRef.current);\n    }\n  };\n  ```\n\n## 4.4 useContext\n需先定义 Context 类型，通过 `createContext` 指定：\n```tsx\n// 定义 Context 类型\ninterface ThemeContextType {\n  theme: 'light' | 'dark';\n  toggleTheme: () => void;\n}\n\n// 创建 Context（指定默认值类型）\nconst ThemeContext = createContext<ThemeContextType>({\n  theme: 'light',\n  toggleTheme: () => {},\n});\n\n// 提供 Context\nconst ThemeProvider = ({ children }: { children: React.ReactNode }) => {\n  const [theme, setTheme] = useState<'light' | 'dark'>('light');\n  const toggleTheme = () => setTheme(theme === 'light' ? 'dark' : 'light');\n\n  return (\n    <ThemeContext.Provider value={{ theme, toggleTheme }}>\n      {children}\n    </ThemeContext.Provider>\n  );\n};\n\n// 使用 Context\nconst ThemedButton = () => {\n  const { theme, toggleTheme } = useContext(ThemeContext);\n  return (\n    <button onClick={toggleTheme} className={`theme-${theme}`}>\n      当前主题：{theme}\n    </button>\n  );\n};\n```\n\n## 4.5 useReducer\n需定义状态类型、动作类型，确保 reducer 函数类型安全：\n```tsx\n// 定义状态类型\ninterface TodoState {\n  list: { id: number; text: string; done: boolean }[];\n}\n\n// 定义动作类型（联合类型）\ntype TodoAction = \n  | { type: 'ADD_TODO'; payload: string }\n  | { type: 'TOGGLE_TODO'; payload: number }\n  | { type: 'DELETE_TODO'; payload: number };\n\n// 初始状态\nconst initialState: TodoState = {\n  list: [],\n};\n\n// Reducer 函数（类型约束）\nconst todoReducer = (state: TodoState, action: TodoAction): TodoState => {\n  switch (action.type) {\n    case 'ADD_TODO':\n      return {\n        ...state,\n        list: [...state.list, { id: Date.now(), text: action.payload, done: false }],\n      };\n    case 'TOGGLE_TODO':\n      return {\n        ...state,\n        list: state.list.map(item => \n          item.id === action.payload ? { ...item, done: !item.done } : item\n        ),\n      };\n    case 'DELETE_TODO':\n      return {\n        ...state,\n        list: state.list.filter(item => item.id !== action.payload),\n      };\n    default:\n      return state;\n  }\n};\n\n// 使用 useReducer\nconst TodoList = () => {\n  const [state, dispatch] = useReducer(todoReducer, initialState);\n\n  const addTodo = (text: string) => {\n    dispatch({ type: 'ADD_TODO', payload: text });\n  };\n\n  return (\n    <div>\n      <button onClick={() => addTodo('新任务')}>添加任务</button>\n      <ul>\n        {state.list.map(item => (\n          <li key={item.id} onClick={() => dispatch({ type: 'TOGGLE_TODO', payload: item.id })}>\n            {item.text} {item.done ? '✅' : '❌'}\n            <button onClick={() => dispatch({ type: 'DELETE_TODO', payload: item.id })}>删除</button>\n          </li>\n        ))}\n      </ul>\n    </div>\n  );\n};\n```\n\n## 4.6 自定义 Hooks 类型\n自定义 Hooks 需明确返回值类型，TypeScript 可自动推导，复杂场景建议显式指定：\n```tsx\n// 自定义 Hooks：获取窗口尺寸\nconst useWindowSize = (): { width: number; height: number } => {\n  const [size, setSize] = useState({\n    width: typeof window !== 'undefined' ? window.innerWidth : 0,\n    height: typeof window !== 'undefined' ? window.innerHeight : 0,\n  });\n\n  useEffect(() => {\n    const handleResize = () => {\n      setSize({ width: window.innerWidth, height: window.innerHeight });\n    };\n    window.addEventListener('resize', handleResize);\n    return () => window.removeEventListener('resize', handleResize);\n  }, []);\n\n  return size;\n};\n\n// 使用\nconst { width, height } = useWindowSize(); // 类型安全：width/height 为 number\n```\n\n# 5. 类组件类型（可选）\n类组件需指定 Props 和 State 类型，通过 `React.Component<Props, State>` 约束：\n```tsx\ninterface UserCardProps {\n  userId: number;\n}\n\ninterface UserCardState {\n  user: { name: string; age: number } | null;\n  loading: boolean;\n}\n\nclass UserCard extends React.Component<UserCardProps, UserCardState> {\n  constructor(props: UserCardProps) {\n    super(props);\n    this.state = {\n      user: null,\n      loading: true,\n    };\n  }\n\n  componentDidMount() {\n    // 模拟接口请求\n    setTimeout(() => {\n      this.setState({\n        user: { name: '张三', age: 20 },\n        loading: false,\n      });\n    }, 1000);\n  }\n\n  render() {\n    const { loading, user } = this.state;\n    if (loading) return <div>加载中...</div>;\n    return (\n      <div>\n        <h3>{user?.name}</h3>\n        <p>年龄：{user?.age}</p>\n      </div>\n    );\n  }\n}\n```...","directory_id":"f9e86587-de73-4459-b574-fbd8be79b7c1","is_published":true,"created_at":"2025-12-22 03:19:59.415433+00","updated_at":"2025-12-23 13:34:42.783481+00"},{"id":"87bc8b9a-4779-4a94-83f0-6c6b0f07358f","title":"状态提升与组件通信最佳实践","content":"在 React 应用中，组件之间的状态共享和通信是核心需求。**状态提升**是 React 官方推荐的组件通信方案，核心思想是：将多个组件共享的状态提升到它们的**最近公共父组件**中管理，父组件通过 `props` 将状态和更新函数传递给子组件，实现多组件状态同步。\n\n# 1. 状态提升的核心思想与适用场景\n## 1.1 核心思想\nReact 是**单向数据流**，数据只能从父组件流向子组件。当多个子组件需要共享同一状态（如表单输入、开关状态、列表数据）时，若每个子组件都维护一份独立状态，会导致状态不一致、同步困难。\n\n状态提升的解决思路：\n1. 找到多个子组件的**最近公共父组件**。\n2. 将共享状态**移动到公共父组件中管理**。\n3. 父组件定义**状态更新函数**，并通过 `props` 传递给子组件。\n4. 子组件调用父组件传递的更新函数，修改公共状态，实现多组件状态同步。\n\n## 1.2 适用场景\n- 多个子组件需要**共享同一状态**（如兄弟组件之间的状态同步）。\n- 子组件需要**修改父组件的状态**（如表单组件传递输入值给父组件）。\n- 跨层级组件通信（但层级过深时推荐使用 Context，而非多层状态提升）。\n\n# 2. 状态提升实战：温度转换器案例\n以“摄氏度 ↔ 华氏度”转换器为例，两个输入框（摄氏度输入框、华氏度输入框）共享同一温度状态，修改其中一个输入框的值，另一个会自动同步更新。\n\n## 2.1 需求分析\n- 两个子组件：`CelsiusInput`（摄氏度输入）、`FahrenheitInput`（华氏度输入）。\n- 两个子组件共享同一温度状态，修改任意一个，另一个需实时转换。\n- 转换公式：`华氏度 = 摄氏度 × 9/5 + 32`；`摄氏度 = (华氏度 - 32) × 5/9`。\n\n## 2.2 实现步骤\n### （1）定义公共父组件：`TemperatureCalculator`\n父组件作为状态的管理者，负责：\n- 维护共享状态 `temperature` 和 `scale`（当前温度单位：`c` 表示摄氏度，`f` 表示华氏度）。\n- 定义状态更新函数 `handleTemperatureChange`。\n- 通过 `props` 将状态和更新函数传递给两个子组件。\n\n```jsx\nimport { useState } from 'react';\n\n// 温度转换工具函数\nfunction toCelsius(fahrenheit) {\n  return ((fahrenheit - 32) * 5) / 9;\n}\n\nfunction toFahrenheit(celsius) {\n  return (celsius * 9) / 5 + 32;\n}\n\n// 格式化温度显示（保留一位小数）\nfunction tryConvert(temperature, convert) {\n  const input = parseFloat(temperature);\n  if (Number.isNaN(input)) return '';\n  const output = convert(input);\n  const rounded = Math.round(output * 10) / 10;\n  return rounded.toString();\n}\n\n// 父组件：状态提升的核心\nfunction TemperatureCalculator() {\n  // 共享状态：temperature（温度值）、scale（温度单位）\n  const [temperature, setTemperature] = useState('');\n  const [scale, setScale] = useState('c');\n\n  // 状态更新函数：接收子组件传递的温度值和单位\n  const handleTemperatureChange = (newTemperature, newScale) => {\n    setTemperature(newTemperature);\n    setScale(newScale);\n  };\n\n  // 根据当前单位计算对应温度\n  const celsius = scale === 'f' ? tryConvert(temperature, toCelsius) : temperature;\n  const fahrenheit = scale === 'c' ? tryConvert(temperature, toFahrenheit) : temperature;\n\n  return (\n    <div>\n      <h2>温度转换器</h2>\n      {/* 传递状态和更新函数给子组件 */}\n      <CelsiusInput\n        temperature={celsius}\n        onTemperatureChange={(value) => handleTemperatureChange(value, 'c')}\n      />\n      <FahrenheitInput\n        temperature={fahrenheit}\n        onTemperatureChange={(value) => handleTemperatureChange(value, 'f')}\n      />\n    </div>\n  );\n}\n```\n\n### （2）定义子组件：`CelsiusInput` 和 `FahrenheitInput`\n子组件是**受控组件**，自身不维护状态，仅接收父组件传递的 `temperature` 和 `onTemperatureChange`，并在输入变化时调用更新函数。\n\n```jsx\n// 子组件1：摄氏度输入框\nfunction CelsiusInput({ temperature, onTemperatureChange }) {\n  const handleChange = (e) => {\n    // 调用父组件传递的更新函数，传递输入值\n    onTemperatureChange(e.target.value);\n  };\n\n  return (\n    <div>\n      <label>摄氏度：</label>\n      <input type=\"number\" value={temperature} onChange={handleChange} placeholder=\"输入摄氏度\" />\n      <span> °C</span>\n    </div>\n  );\n}\n\n// 子组件2：华氏度输入框\nfunction FahrenheitInput({ temperature, onTemperatureChange }) {\n  const handleChange = (e) => {\n    onTemperatureChange(e.target.value);\n  };\n\n  return (\n    <div style={{ marginTop: '10px' }}>\n      <label>华氏度：</label>\n      <input type=\"number\" value={temperature} onChange={handleChange} placeholder=\"输入华氏度\" />\n      <span> °F</span>\n    </div>\n  );\n}\n```\n\n## 2.3 运行效果\n- 修改摄氏度输入框的值，华氏度输入框会自动转换并显示对应值。\n- 修改华氏度输入框的值，摄氏度输入框会自动转换并显示对应值。\n- 所有状态由父组件统一管理，两个子组件保持状态同步。\n\n# 3. 组件通信最佳实践\nReact 中不同关系的组件，通信方式不同，需根据组件层级和业务需求选择合适的方案。\n\n## 3.1 父子组件通信（最常用）\n| 通信方向 | 实现方式 | 适用场景 |\n|----------|----------|----------|\n| 父 → 子 | **props 传递** | 父组件向子组件传递数据、方法 |\n| 子 → 父 | **回调函数传参** | 子组件向父组件传递数据（如表单输入、事件结果） |\n\n**最佳实践**：\n- 子组件尽量设计为**受控组件**，自身不维护状态，通过 `props` 接收数据和更新函数。\n- 父组件传递的回调函数，函数组件用 `useCallback` 缓存，避免子组件不必要的重渲染。\n\n```jsx\n// 父组件：用 useCallback 缓存回调函数\nimport { useState, useCallback } from 'react';\n\nfunction Parent() {\n  const [value, setValue] = useState('');\n\n  // 缓存回调函数，依赖项仅为 setValue\n  const handleChildChange = useCallback((newValue) => {\n    setValue(newValue);\n  }, [setValue]);\n\n  return <Child onValueChange={handleChildChange} value={value} />;\n}\n```\n\n## 3.2 兄弟组件通信\n兄弟组件没有直接的 props 传递通道，需通过**状态提升**实现通信：\n1. 共享状态提升到兄弟组件的最近公共父组件。\n2. 父组件通过 props 将状态和更新函数传递给所有兄弟组件。\n\n**最佳实践**：\n- 兄弟组件数量较多时，可封装专门的父组件管理状态，避免业务逻辑分散。\n- 状态更新函数命名清晰，明确函数用途（如 `onTodoAdd`、`onTodoDelete`）。\n\n## 3.3 跨层级组件通信（爷孙组件、深层组件）\n有两种主流方案，需根据场景选择：\n\n| 方案 | 实现方式 | 适用场景 | 优缺点 |\n|------|----------|----------|--------|\n| **多层状态提升** | 逐层通过 props 传递状态和更新函数 | 层级较浅（≤3 层）、状态仅少数组件使用 | 优点：简单直观，无需额外 API；缺点：层级过深时 props 透传，代码冗余 |\n| **Context 上下文** | 通过 `createContext` 创建上下文，`Provider` 提供数据，`useContext` 消费数据 | 层级较深、全局共享状态（如主题、用户信息） | 优点：避免 props 透传，代码简洁；缺点：过度使用会导致组件耦合度升高 |\n\n**最佳实践**：\n- **优先使用 Context** 处理跨层级通信，尤其是全局共享状态。\n- 拆分 Context：将不同类型的共享状态拆分为多个独立 Context（如 `ThemeContext`、`UserContext`），避免单个 Context 过大导致不必要的重渲染。\n\n## 3.4 非关联组件通信（无公共父组件）\n非关联组件指没有任何共同父组件的组件（如页面 A 和页面 B），通信方案如下：\n1. **全局状态管理库**：如 Redux、MobX、Zustand，适用于大型应用的全局状态共享。\n2. **浏览器存储**：如 `localStorage`/`sessionStorage`，适用于持久化数据的通信（如用户登录状态）。\n3. **事件总线**：如 `mitt` 库，通过发布/订阅模式实现组件通信，适用于小型应用的临时通信。\n\n**最佳实践**：\n- 中大型应用优先使用**Zustand**（轻量、易用）或 Redux Toolkit（Redux 官方推荐）。\n- 避免滥用事件总线，容易导致数据流混乱，难以维护。\n\n# 4. 状态管理与通信的核心原则\n1. **单一数据源**：\n   - 共享状态尽量集中管理，避免多个组件维护同一状态的副本，导致状态不一致。\n   - 全局状态优先放在顶层组件或专门的状态管理库中。\n\n2. **单向数据流**：\n   - 数据只能从父组件流向子组件，子组件通过回调函数修改父组件状态，禁止子组件直接修改 props。\n   - 状态更新逻辑清晰，便于追踪数据流向和调试。\n\n3. **最小状态原则**：\n   - 只保留必要的状态，避免冗余状态。可以通过计算得到的数据（如温度转换结果），不要作为独立状态存储。\n   - 示例：温度转换器中，只存储 `temperature` 和 `scale`，摄氏度和华氏度的值通过计算得到，无需单独存储。\n\n4. **组件职责单一**：\n   - 组件分为两类：**容器组件**（管理状态和业务逻辑）和**展示组件**（仅负责渲染 UI，无状态）。\n   - 展示组件通过 props 接收数据和回调，可复用性更强。\n\n# 5. 核心总结\n1. **状态提升**是解决兄弟组件通信的核心方案，将共享状态提升到最近公共父组件管理。\n2. **组件通信方案选型**：\n   - 父子通信：props + 回调函数。\n   - 兄弟通信：状态提升。\n   - 跨层级通信：优先 Context，层级较浅时可用多层状态提升。\n   - 非关联组件通信：全局状态管理库或浏览器存储。\n3. **最佳实践**：\n   - 子组件尽量设计为受控组件，遵循单一数据源原则。\n   - 回调函数用 `useCallback` 缓存，优化性能。\n   - 拆分 Context，避免过度耦合。\n   - 遵循单向数据流，保持状态更新逻辑清晰。","directory_id":"e42a3397-52b2-470f-a87d-08e025ba6944","is_published":true,"created_at":"2025-12-19 11:41:25.747809+00","updated_at":"2025-12-19 11:41:25.747809+00"},{"id":"8a465da6-06c8-44e3-b277-b2e34debb0bb","title":"React 开发环境搭建","content":"搭建 React 开发环境需先安装 Node.js（运行 JavaScript 的服务器环境），再选择合适的脚手架工具（Create React App 或 Vite）快速创建项目。\n\n# 1. 前置准备：安装 Node.js\n- 下载地址：[Node.js 官网](https://nodejs.org/)（推荐安装 LTS 长期支持版，自带 npm 包管理器）。\n- 验证安装：安装完成后，打开终端（Windows 命令提示符/ PowerShell，Mac 终端），输入以下命令，显示版本号即安装成功：\n  ```bash\n  node -v  # 查看 Node.js 版本\n  npm -v   # 查看 npm 版本\n  ```\n\n# 2. 方案一：Create React App（官方推荐，零配置）\nCreate React App（CRA）是 React 官方提供的脚手架工具，无需手动配置 Webpack、Babel 等构建工具，开箱即用，适合初学者。\n\n## 2.1 创建项目\n1. 打开终端，进入需创建项目的目录（如 `cd Desktop/ReactProjects`）。\n2. 执行创建命令（项目名建议英文，如 `react-demo`）：\n   ```bash\n   npx create-react-app react-demo  # npx 可直接使用 npm 包，无需全局安装\n   ```\n   或全局安装 CRA 后创建（可选）：\n   ```bash\n   npm install -g create-react-app  # 全局安装\n   create-react-app react-demo      # 创建项目\n   ```\n3. 等待依赖安装完成（需联网，时间根据网络情况而定）。\n\n## 2.2 启动项目\n1. 进入项目目录：\n   ```bash\n   cd react-demo\n   ```\n2. 启动开发服务器：\n   ```bash\n   npm start  # 或 yarn start（若安装了 yarn）\n   ```\n3. 启动成功后，终端会显示访问地址（默认 `http://localhost:3000`），打开浏览器即可看到 React 默认首页（带有 React 标志的页面）。\n\n# 3. 方案二：Vite（快速构建，开发体验更优）\nVite 是新一代前端构建工具，相比 CRA 启动速度更快（基于 ES 模块原生支持，无需打包），热更新更高效，适合追求开发效率的场景。\n\n## 3.1 创建项目\n1. 终端进入目标目录，执行创建命令：\n   ```bash\n   npm create vite@latest  # 启动 Vite 项目创建向导\n   ```\n2. 按提示配置：\n   - 输入项目名（如 `react-vite-demo`）。\n   - 选择框架：上下箭头选择 `React`。\n   - 选择变体：`React`（默认，使用 JavaScript）或 `React + TypeScript`（支持 TS 类型检查）。\n3. 进入项目目录并安装依赖：\n   ```bash\n   cd react-vite-demo\n   npm install  # 安装项目依赖\n   ```\n\n## 3.2 启动项目\n执行启动命令：\n```bash\nnpm run dev\n```\n启动成功后，终端会显示访问地址（默认 `http://127.0.0.1:5173/`），打开浏览器即可看到 Vite + React 的默认页面。\n\n# 4. 两种方案对比\n| 特性                | Create React App       | Vite                   |\n|---------------------|------------------------|------------------------|\n| 启动速度            | 较慢（需打包所有文件） | 极快（原生 ES 模块）   |\n| 热更新效率          | 一般                   | 极快（只更新变化模块） |\n| 配置复杂度          | 零配置（隐藏构建细节） | 简洁配置（支持自定义） |\n| 适用场景            | 初学者、快速原型       | 生产项目、追求效率     |\n","directory_id":"885129c3-bae4-445c-979c-09863b3895f8","is_published":true,"created_at":"2025-12-19 06:46:58.983421+00","updated_at":"2025-12-19 09:05:09.477681+00"},{"id":"90d6c87b-d397-4053-8788-3da07c5d1ed0","title":"Redux 中间件","content":"Redux 原生 Reducer 是纯函数，**无法处理异步操作**（如 API 请求、定时器）——中间件（Middleware）是 Redux 的扩展机制，用于在 Action 被 dispatch 后、到达 Reducer 前，插入自定义逻辑（如异步请求、日志打印、错误捕获）。\n\n# 1. 中间件核心作用\n- 拦截 Action，实现自定义处理逻辑；\n- 支持异步 Action（如先请求 API，再 dispatch 同步 Action 更新状态）；\n- 扩展 Redux 功能（如日志、持久化、撤销/重做）。\n\n# 2. Redux-Thunk：轻量级异步解决方案\n`redux-thunk` 是最常用的 Redux 中间件，允许 Action 创建函数返回**函数**（而非普通对象），该函数接收 `dispatch` 和 `getState` 作为参数，可在内部执行异步操作，完成后 dispatch 同步 Action 更新状态。\n\n## 2.1 核心特性\n- 轻量（无额外依赖）、易用；\n- 适合简单异步场景（如单次 API 请求）；\n- Redux Toolkit 已内置 `redux-thunk`，无需手动安装。\n\n## 2.2 实现异步逻辑：创建 Thunk Action\nThunk Action 是返回函数的 Action 创建函数，内部可执行异步操作：\n\n```javascript\nimport { createSlice, createAsyncThunk } from '@reduxjs/toolkit';\nimport axios from 'axios';\n\n// 方式1：手动创建 Thunk Action（基础用法）\nexport const fetchTodos = () => {\n  // 返回函数，接收 dispatch 和 getState\n  return async (dispatch, getState) => {\n    try {\n      // 1. 发送加载中 Action（更新加载状态）\n      dispatch(setLoading(true));\n\n      // 2. 异步请求 API\n      const res = await axios.get('https://jsonplaceholder.typicode.com/todos');\n\n      // 3. 请求成功，dispatch 同步 Action 更新状态\n      dispatch(loadTodos(res.data));\n    } catch (err) {\n      // 4. 请求失败，dispatch 错误 Action\n      dispatch(setError(err.message));\n    } finally {\n      // 5. 结束加载\n      dispatch(setLoading(false));\n    }\n  };\n};\n\n// 方式2：RTK 内置 createAsyncThunk（推荐，自动生成 pending/fulfilled/rejected Action）\nexport const fetchTodosAsync = createAsyncThunk(\n  'todo/fetchTodos', // Action 类型前缀\n  async (_, { rejectWithValue }) => {\n    try {\n      const res = await axios.get('https://jsonplaceholder.typicode.com/todos');\n      return res.data; // 成功时，结果会作为 payload 传入 fulfilled Action\n    } catch (err) {\n      // 失败时，返回错误信息（通过 rejectWithValue 传递）\n      return rejectWithValue(err.message);\n    }\n  }\n);\n\n// Todo Slice 中处理异步 Action\nconst todoSlice = createSlice({\n  name: 'todo',\n  initialState: {\n    todos: [],\n    loading: false,\n    error: null\n  },\n  reducers: {\n    // 同步 Action 处理\n    setLoading: (state, action) => {\n      state.loading = action.payload;\n    }\n  },\n  // 处理 createAsyncThunk 生成的异步 Action\n  extraReducers: (builder) => {\n    builder\n      // 请求中（pending）\n      .addCase(fetchTodosAsync.pending, (state) => {\n        state.loading = true;\n        state.error = null;\n      })\n      // 请求成功（fulfilled）\n      .addCase(fetchTodosAsync.fulfilled, (state, action) => {\n        state.loading = false;\n        state.todos = action.payload; // payload 为 API 返回数据\n      })\n      // 请求失败（rejected）\n      .addCase(fetchTodosAsync.rejected, (state, action) => {\n        state.loading = false;\n        state.error = action.payload; // payload 为 rejectWithValue 传递的错误信息\n      });\n  }\n});\n\nexport const { setLoading } = todoSlice.actions;\nexport default todoSlice.reducer;\n```\n\n## 2.3 组件中调用 Thunk Action\n```javascript\nimport { useEffect } from 'react';\nimport { useDispatch, useSelector } from 'react-redux';\nimport { fetchTodosAsync } from './features/todo/todoSlice';\n\nfunction TodoList() {\n  const dispatch = useDispatch();\n  const { todos, loading, error } = useSelector((state) => state.todos);\n\n  // 组件挂载时触发异步请求\n  useEffect(() => {\n    dispatch(fetchTodosAsync());\n  }, [dispatch]);\n\n  if (loading) return <div>加载中...</div>;\n  if (error) return <div>错误：{error}</div>;\n\n  return (\n    <ul>\n      {todos.map((todo) => (\n        <li key={todo.id}>{todo.title}</li>\n      ))}\n    </ul>\n  );\n}\n```\n\n# 3. Redux-Saga：复杂异步流程管理\n`redux-saga` 是基于**生成器（Generator）** 的 Redux 中间件，专注于处理复杂异步流程（如并发请求、取消请求、轮询、依赖请求），通过“监听 Action”的方式触发异步逻辑，代码可读性和可维护性更高。\n\n## 3.1 核心特性\n- 支持 Generator 函数，用同步写法处理异步逻辑；\n- 提供丰富的 Effect 函数（如 `call`、`put`、`takeEvery`、`fork`），处理异步操作；\n- 支持取消异步任务、错误捕获、并发控制；\n- 适合复杂异步场景（如电商下单流程、实时数据同步）。\n\n## 3.2 快速上手：安装与配置\n```bash\nnpm install redux-saga\n\nyarn add redux-saga\n```\n\n配置 Store（需手动添加 saga 中间件）：\n```javascript\nimport { configureStore } from '@reduxjs/toolkit';\nimport createSagaMiddleware from 'redux-saga';\nimport todoReducer from './features/todo/todoSlice';\nimport rootSaga from './sagas';\n\n// 创建 saga 中间件\nconst sagaMiddleware = createSagaMiddleware();\n\n// 配置 Store，添加 saga 中间件\nconst store = configureStore({\n  reducer: {\n    todos: todoReducer\n  },\n  middleware: (getDefaultMiddleware) =>\n    getDefaultMiddleware().concat(sagaMiddleware) // 加入 saga 中间件\n});\n\n// 运行根 saga\nsagaMiddleware.run(rootSaga);\n\nexport default store;\n```\n\n## 3.3 核心 Effect 函数\n| Effect 函数 | 作用 |\n|-------------|------|\n| `call(fn, ...args)` | 调用异步函数（如 API 请求），阻塞等待结果 |\n| `put(action)` | 触发 Action（相当于 dispatch） |\n| `takeEvery(actionType, saga)` | 监听指定 Action，每次触发都执行 saga（支持并发） |\n| `takeLatest(actionType, saga)` | 监听指定 Action，只执行最后一次触发的 saga（取消之前未完成的任务） |\n| `fork(fn, ...args)` | 非阻塞调用函数（不等待结果，适合后台任务） |\n| `cancel(task)` | 取消 fork 创建的异步任务 |\n\n## 3.4 实现异步逻辑：创建 Saga\n```javascript\n// src/sagas/todoSaga.js\nimport { call, put, takeLatest } from 'redux-saga/effects';\nimport axios from 'axios';\nimport { fetchTodosSuccess, fetchTodosFailure, setLoading } from '../features/todo/todoSlice';\n\n// 定义异步请求函数\nconst fetchTodosApi = async () => {\n  const res = await axios.get('https://jsonplaceholder.typicode.com/todos');\n  return res.data;\n};\n\n// 定义 Saga 生成器函数（处理异步逻辑）\nfunction* fetchTodosSaga() {\n  try {\n    // 触发加载中 Action\n    yield put(setLoading(true));\n\n    // 调用 API（阻塞等待结果）\n    const data = yield call(fetchTodosApi);\n\n    // 请求成功，触发成功 Action\n    yield put(fetchTodosSuccess(data));\n  } catch (err) {\n    // 请求失败，触发失败 Action\n    yield put(fetchTodosFailure(err.message));\n  } finally {\n    // 结束加载\n    yield put(setLoading(false));\n  }\n}\n\n// 监听 Action：当 dispatch(fetchTodosRequest()) 时，执行 fetchTodosSaga\nexport function* watchFetchTodos() {\n  // takeLatest：只处理最后一次请求（避免重复请求）\n  yield takeLatest('todo/fetchTodosRequest', fetchTodosSaga);\n}\n```\n\n## 3.5 根 Saga（组合多个 Saga）\n```javascript\n// src/sagas/index.js（rootSaga）\nimport { all } from 'redux-saga/effects';\nimport { watchFetchTodos } from './todoSaga';\nimport { watchFetchUser } from './userSaga';\n\n// 根 Saga：合并所有子 Saga\nexport default function* rootSaga() {\n  yield all([\n    watchFetchTodos(),\n    watchFetchUser()\n  ]);\n}\n```\n\n## 3.6 组件中触发 Saga 监听的 Action\n```javascript\n// src/features/todo/todoSlice.js（定义触发 Saga 的 Action）\nimport { createSlice } from '@reduxjs/toolkit';\n\nconst todoSlice = createSlice({\n  name: 'todo',\n  initialState: {\n    todos: [],\n    loading: false,\n    error: null\n  },\n  reducers: {\n    fetchTodosRequest: (state) => {}, // 仅用于触发 Saga，无状态修改\n    fetchTodosSuccess: (state, action) => {\n      state.todos = action.payload;\n    },\n    fetchTodosFailure: (state, action) => {\n      state.error = action.payload;\n    },\n    setLoading: (state, action) => {\n      state.loading = action.payload;\n    }\n  }\n});\n\nexport const { fetchTodosRequest, fetchTodosSuccess, fetchTodosFailure, setLoading } = todoSlice.actions;\nexport default todoSlice.reducer;\n```\n\n```javascript\n// 组件中触发 Action\nimport { useEffect } from 'react';\nimport { useDispatch, useSelector } from 'react-redux';\nimport { fetchTodosRequest } from './features/todo/todoSlice';\n\nfunction TodoList() {\n  const dispatch = useDispatch();\n  const { todos, loading, error } = useSelector((state) => state.todos);\n\n  useEffect(() => {\n    // 触发 fetchTodosRequest Action，Saga 监听到后执行异步逻辑\n    dispatch(fetchTodosRequest());\n  }, [dispatch]);\n\n  // 渲染逻辑...\n}\n```\n\n# 4. Redux-Thunk vs Redux-Saga 对比\n| 特性                | Redux-Thunk                | Redux-Saga                  |\n|---------------------|----------------------------|-----------------------------|\n| 语法                | 普通函数 + Promise          | Generator 函数 + Effect      |\n| 学习成本            | 低（无需学习新概念）| 高（需理解 Generator/Effect）|\n| 异步流程控制        | 简单（适合单次请求）| 强大（支持并发、取消、轮询）|\n| 错误处理            | try/catch 包裹异步代码      | try/catch 包裹 Effect 函数   |\n| 可读性              | 中等（嵌套 Promise 易混乱） | 高（同步写法，流程清晰）|\n| 适用场景            | 简单异步需求（如列表请求）| 复杂异步需求（如订单流程）|\n","directory_id":"a3109983-f66b-42c0-afb5-8d07e97cbc4e","is_published":true,"created_at":"2025-12-22 03:13:23.512805+00","updated_at":"2025-12-23 08:40:19.202808+00"},{"id":"91045cc1-a8c8-46b4-8d8a-c3209736ae60","title":"路由参数","content":"在单页应用中，路由参数是传递数据的重要方式，React Router v6 支持两种核心参数类型：**动态路由参数**（URL 路径中的参数，如 `/user/:id`）和**搜索参数**（URL 中 `?` 后的参数，如 `/list?page=1&size=10`）。对应的，提供了 `useParams` 和 `useSearchParams` 两个钩子函数用于获取和操作这些参数，以下是详细解析：\n\n# 1. 动态路由参数（路径参数）\n动态路由参数是嵌入在路由路径中的变量，用于匹配一类路径（如 `/user/123`、`/user/456` 可匹配同一个路由规则），参数名以 `:` 开头，是实现“详情页”“个性化页面”的核心方式。\n\n## 1.1 定义动态路由\n在 `Route` 组件的 `path` 属性中，通过 `:参数名` 定义动态参数：\n```jsx\nimport { Routes, Route } from 'react-router-dom';\nimport UserDetail from './pages/UserDetail';\nimport ArticleDetail from './pages/ArticleDetail';\n\nfunction App() {\n  return (\n    <Routes>\n      {/* 定义动态参数 id：匹配 /user/123、/user/456 等路径 */}\n      <Route path=\"/user/:id\" element={<UserDetail />} />\n      \n      {/* 支持多个动态参数：匹配 /article/2024/10 */}\n      <Route path=\"/article/:year/:month\" element={<ArticleDetail />} />\n      \n      {/* 可选动态参数（加 ?）：匹配 /tag 或 /tag/react */}\n      <Route path=\"/tag/:name?\" element={<TagPage />} />\n    </Routes>\n  );\n}\n```\n\n## 1.2 useParams：获取动态路由参数\n`useParams` 是 React Router v6 提供的钩子函数，用于在路由组件中获取动态路由参数，返回一个对象，键为参数名，值为 URL 中对应的参数值（字符串类型）。\n\n### 1.2.1 基本用法\n```jsx\n// UserDetail.js（路由组件）\nimport { useParams } from 'react-router-dom';\n\nfunction UserDetail() {\n  // 获取动态参数：params 为 { id: \"123\" }（若 URL 为 /user/123）\n  const params = useParams();\n  \n  // 注意：参数值默认是字符串，需根据需求转换为数字/布尔值\n  const userId = Number(params.id);\n\n  return (\n    <div>\n      <h1>用户详情页</h1>\n      <p>用户 ID：{userId}</p>\n      <p>参数原始类型：{typeof params.id}</p> {/* 输出 string */}\n    </div>\n  );\n}\n\nexport default UserDetail;\n```\n\n### 1.2.2 多个动态参数示例\n```jsx\n// ArticleDetail.js\nimport { useParams } from 'react-router-dom';\n\nfunction ArticleDetail() {\n  // URL 为 /article/2024/10 时，params 为 { year: \"2024\", month: \"10\" }\n  const { year, month } = useParams();\n\n  return (\n    <div>\n      <h1>2024年10月文章列表</h1>\n      <p>年份：{year}（类型：{typeof year}）</p>\n      <p>月份：{month}（类型：{typeof month}）</p>\n    </div>\n  );\n}\n```\n\n### 1.2.3 可选动态参数示例\n```jsx\n// TagPage.js\nimport { useParams } from 'react-router-dom';\n\nfunction TagPage() {\n  // URL 为 /tag 时，params 为 {} → name 为 undefined\n  // URL 为 /tag/react 时，params 为 { name: \"react\" }\n  const { name } = useParams();\n\n  return (\n    <div>\n      <h1>{name ? `标签：${name}` : '所有标签'}</h1>\n    </div>\n  );\n}\n```\n\n## 1.3 动态路由参数的注意事项\n- 参数值默认是**字符串类型**，若需数字、布尔值等类型，需手动转换（如 `Number(params.id)`）；\n- 动态参数不能包含 `/` 字符（URL 中 `/` 用于分隔路径），若需传递包含 `/` 的数据，需使用搜索参数；\n- 可选参数需在参数名后加 `?`（如 `:name?`），否则 URL 中缺少该参数时会匹配失败（跳转到 404 页面）；\n- 路由匹配优先级：静态路由（如 `/user/profile`）优先级高于动态路由（如 `/user/:id`），需将静态路由放在动态路由之前定义。\n\n# 2. 搜索参数（Query 参数）\n搜索参数是 URL 中 `?` 后面的键值对（如 `/list?page=1&size=10&keyword=react`），用于传递非核心数据（如分页信息、筛选条件、搜索关键词），支持多个参数拼接（用 `&` 分隔），参数顺序不影响匹配。\n\n## 2.1 定义与跳转时传递搜索参数\n搜索参数无需在路由规则中预先定义，可通过 `Link`、`NavLink` 或 `useNavigate` 跳转时直接拼接在 URL 后：\n\n### 方式1：通过 Link/NavLink 传递\n```jsx\nimport { Link } from 'react-router-dom';\n\nfunction ProductList() {\n  return (\n    <div>\n      {/* 直接拼接搜索参数 */}\n      <Link to=\"/list?page=1&size=10&keyword=手机\">手机列表（第1页）</Link>\n      \n      {/* 通过对象形式传递（更优雅） */}\n      <Link\n        to={{\n          pathname: '/list',\n          search: 'page=2&size=10&keyword=电脑'\n        }}\n      >\n        电脑列表（第2页）\n      </Link>\n    </div>\n  );\n}\n```\n\n### 方式2：通过 useNavigate 传递（编程式）\n```jsx\nimport { useNavigate } from 'react-router-dom';\n\nfunction SearchBar() {\n  const navigate = useNavigate();\n  const keyword = 'react';\n\n  const handleSearch = () => {\n    // 方式1：直接拼接\n    navigate(`/search?keyword=${keyword}&page=1`);\n    \n    // 方式2：使用 URLSearchParams 拼接（自动处理特殊字符）\n    const params = new URLSearchParams();\n    params.append('keyword', keyword);\n    params.append('page', '1');\n    params.append('size', '10');\n    navigate(`/search?${params}`); // 结果：/search?keyword=react&page=1&size=10\n  };\n\n  return <button onClick={handleSearch}>搜索</button>;\n}\n```\n\n## 2.2 useSearchParams：获取与操作搜索参数\n`useSearchParams` 是 React Router v6 新增的核心钩子，用于在路由组件中**获取、修改、删除**搜索参数，返回一个数组：`[searchParams, setSearchParams]`，其中：\n- `searchParams`：`URLSearchParams` 实例，提供 `get`、`getAll` 等方法获取参数；\n- `setSearchParams`：函数，用于修改搜索参数（会触发路由更新）。\n\n### 2.2.1 核心方法（searchParams）\n| 方法名      | 说明                                                                 |\n|-------------|----------------------------------------------------------------------|\n| `get(key)`  | 获取单个参数值（若有多个同名参数，返回第一个），不存在返回 `null`     |\n| `getAll(key)`| 获取多个同名参数值（返回数组），不存在返回空数组                     |\n| `has(key)`  | 判断参数是否存在（返回布尔值）                                       |\n| `keys()`    | 获取所有参数名（返回迭代器）                                         |\n| `entries()` | 获取所有参数的键值对（返回迭代器）                                   |\n\n### 2.2.2 基本用法：获取搜索参数\n```jsx\n// ListPage.js（路由组件，URL 为 /list?page=1&size=10&keyword=手机）\nimport { useSearchParams } from 'react-router-dom';\n\nfunction ListPage() {\n  // 初始化：searchParams 是 URLSearchParams 实例，setSearchParams 用于修改参数\n  const [searchParams, setSearchParams] = useSearchParams();\n\n  // 1. 获取单个参数（默认字符串类型，需手动转换）\n  const page = Number(searchParams.get('page')) || 1; // 若不存在，默认1\n  const size = Number(searchParams.get('size')) || 10;\n  const keyword = searchParams.get('keyword') || '全部';\n\n  // 2. 获取多个同名参数（如 /list?tag=react&tag=vue）\n  const tags = searchParams.getAll('tag'); // 返回 [\"react\", \"vue\"]\n\n  // 3. 判断参数是否存在\n  const hasFilter = searchParams.has('filter'); // 返回 true/false\n\n  return (\n    <div>\n      <h1>商品列表</h1>\n      <p>关键词：{keyword}</p>\n      <p>当前页：{page}，每页条数：{size}</p>\n      <p>标签：{tags.join(', ')}</p>\n    </div>\n  );\n}\n```\n\n### 2.2.3 进阶用法：修改搜索参数\n`setSearchParams` 函数用于修改搜索参数，支持两种传入形式：对象或 `URLSearchParams` 实例，修改后会触发路由更新（组件重新渲染）。\n\n```jsx\nfunction ListPage() {\n  const [searchParams, setSearchParams] = useSearchParams();\n\n  // 1. 跳转到下一页（保留其他参数，仅修改 page）\n  const goToNextPage = () => {\n    const currentPage = Number(searchParams.get('page')) || 1;\n    // 传入对象：会合并现有参数（同名参数会覆盖）\n    setSearchParams({\n      ...Object.fromEntries(searchParams.entries()), // 保留现有所有参数\n      page: currentPage + 1 // 修改 page 参数\n    });\n  };\n\n  // 2. 筛选标签（添加 tag 参数）\n  const addTag = (tag) => {\n    const newParams = new URLSearchParams(searchParams);\n    newParams.append('tag', tag); // 添加同名参数（支持多个标签）\n    setSearchParams(newParams);\n  };\n\n  // 3. 重置筛选条件（清空所有搜索参数）\n  const resetFilters = () => {\n    setSearchParams({}); // 传入空对象，清空所有参数\n  };\n\n  return (\n    <div>\n      <button onClick={goToNextPage}>下一页</button>\n      <button onClick={() => addTag('react')}>添加标签：react</button>\n      <button onClick={resetFilters}>重置筛选</button>\n    </div>\n  );\n}\n```\n\n## 2.3 搜索参数的注意事项\n- 搜索参数值默认是**字符串类型**，且会自动编码特殊字符（如空格、中文 → `%20`、`%E4%B8%AD%E6%96%87`），无需手动处理；\n- `setSearchParams` 会默认使用 `push` 模式（添加新历史记录），若需替换历史记录，可传入第二个参数 `{ replace: true }`：\n  ```jsx\n  setSearchParams({ page: 2 }, { replace: true });\n  ```\n- 搜索参数可动态添加、删除，无需修改路由规则，适合传递临时、非核心数据（如分页、筛选条件）；\n- 刷新页面后，搜索参数会保留在 URL 中（优于动态路由参数的 `state`），适合需要持久化的临时数据。\n\n# 3. 动态路由参数 vs 搜索参数：对比与场景选择\n| 特性                | 动态路由参数（/user/:id）                | 搜索参数（/list?page=1）                  |\n|---------------------|-------------------------------------------|-------------------------------------------|\n| URL 形式            | 路径内嵌，简洁直观（如 /user/123）        | 路径后拼接，显式键值对（如 /list?page=1） |\n| 核心用途            | 标识资源唯一性（如用户 ID、文章 ID）      | 传递临时/筛选数据（分页、搜索关键词）      |\n| 必传性              | 默认必传（可选需加 ?），否则路由不匹配    | 可选，不存在不影响路由匹配                |\n| 数据类型            | 仅支持字符串，需手动转换其他类型          | 仅支持字符串，自动编码特殊字符            |\n| 刷新页面保留        | 是（URL 可见）                            | 是（URL 可见）                            |\n| 多个同名参数        | 不支持（路径中无法重复同名参数）          | 支持（通过 getAll 方法获取数组）          |\n\n## 3.1 场景选择建议\n- 若参数是资源的唯一标识（如用户 ID、商品 ID、文章 ID），使用**动态路由参数**（如 `/user/:id`）；\n- 若参数是临时筛选条件（如分页、搜索关键词、标签筛选），使用**搜索参数**（如 `/list?page=1&keyword=react`）；\n- 若参数可选且不影响路由匹配，使用**搜索参数**或**可选动态参数**（如 `/tag/:name?`）；\n- 若需要传递多个同名参数（如多个标签），只能使用**搜索参数**。\n\n# 4. 常见问题与解决方案\n1. **动态参数类型转换错误**：参数默认是字符串，若需数字类型，需用 `Number()` 转换，同时处理 `null` 情况（如 `Number(params.id) || 0`）；\n2. **搜索参数中文乱码**：`URLSearchParams` 会自动编码/解码中文，无需手动处理，直接通过 `get` 方法获取即可；\n3. **修改搜索参数后组件不更新**：`useSearchParams` 会监听参数变化并触发组件重渲染，若未更新，检查是否遗漏参数依赖（如 `useEffect` 中需依赖 `searchParams`）；\n4. **可选动态参数匹配失败**：确保参数名后加 `?`（如 `/tag/:name?`），否则 URL 中缺少该参数时会匹配 404 页面。\n\n# 5. 实战示例：结合两种参数实现详情页+筛选\n```jsx\n// 路由规则定义\n<Route path=\"/product/:id\" element={<ProductDetail />} />\n\n// ProductDetail.js（URL 为 /product/123?color=red&size=M）\nimport { useParams, useSearchParams } from 'react-router-dom';\n\nfunction ProductDetail() {\n  // 获取动态参数（商品 ID）\n  const { id } = useParams();\n  const productId = Number(id);\n\n  // 获取搜索参数（筛选条件）\n  const [searchParams] = useSearchParams();\n  const color = searchParams.get('color');\n  const size = searchParams.get('size');\n\n  // 模拟请求商品详情（结合 ID 和筛选条件）\n  useEffect(() => {\n    fetch(`/api/product/${productId}?color=${color}&size=${size}`)\n      .then(res => res.json())\n      .then(data => setProduct(data));\n  }, [productId, color, size]); // 依赖参数变化，重新请求数据\n\n  return (\n    <div>\n      <h1>商品 ID：{productId}</h1>\n      <p>筛选条件：颜色={color || '默认'}，尺寸={size || '默认'}</p>\n      {/* 商品详情内容 */}\n    </div>\n  );\n}\n```...","directory_id":"aee449bc-0035-43a6-834d-3e6ce98b6aff","is_published":true,"created_at":"2025-12-22 02:07:10.169563+00","updated_at":"2025-12-23 02:43:09.516784+00"},{"id":"94d4cf65-a0d7-4fb6-832a-a33781ae483f","title":"useImperativeHandle：暴露组件方法","content":"# 1. 核心概念\n在 React 中，组件间通信遵循“自上而下”的单向数据流（父组件通过 props 传递数据给子组件），默认情况下父组件无法直接调用子组件的方法或访问子组件的 DOM 元素。`useImperativeHandle` 是 React 提供的 Hook，用于**自定义子组件暴露给父组件的实例值**（通常是方法或 DOM 引用），配合 `ref` 实现父组件对子女件的“命令式”操作。\n\n## 1.1 设计目的\n- 替代直接传递 DOM ref（避免父组件过度访问子组件内部 DOM，破坏封装性）；\n- 自定义暴露的方法/属性，仅开放必要的接口，增强组件封装性；\n- 兼容函数组件（函数组件无实例，需通过 `forwardRef` + `useImperativeHandle` 实现 ref 传递）。\n\n# 2. 基本用法\n## 步骤1：子组件使用 `forwardRef` + `useImperativeHandle`\n```javascript\nimport { forwardRef, useImperativeHandle, useRef } from 'react';\n\n// 子组件：通过 forwardRef 接收父组件传递的 ref\nconst ChildInput = forwardRef((props, ref) => {\n  // 子组件内部的 DOM ref\n  const inputRef = useRef(null);\n\n  // 自定义暴露给父组件的方法/属性\n  useImperativeHandle(ref, () => ({\n    // 暴露聚焦方法\n    focus: () => {\n      inputRef.current.focus();\n    },\n    // 暴露清空方法\n    clear: () => {\n      inputRef.current.value = '';\n    },\n    // 暴露获取值的方法\n    getValue: () => {\n      return inputRef.current.value;\n    }\n  }), []); // 依赖项为空：仅初始化一次暴露的对象\n\n  return <input ref={inputRef} type=\"text\" placeholder=\"请输入内容\" />;\n});\n\nexport default ChildInput;\n```\n\n## 步骤2：父组件通过 ref 调用子组件方法\n```javascript\nimport { useRef } from 'react';\nimport ChildInput from './ChildInput';\n\nfunction ParentComponent() {\n  // 创建 ref 传递给子组件\n  const childInputRef = useRef(null);\n\n  const handleFocus = () => {\n    // 调用子组件暴露的 focus 方法\n    childInputRef.current?.focus();\n  };\n\n  const handleClear = () => {\n    // 调用子组件暴露的 clear 方法\n    childInputRef.current?.clear();\n  };\n\n  const handleGetValue = () => {\n    // 调用子组件暴露的 getValue 方法\n    const value = childInputRef.current?.getValue();\n    alert(`输入框值：${value}`);\n  };\n\n  return (\n    <div>\n      <ChildInput ref={childInputRef} />\n      <button onClick={handleFocus}>聚焦输入框</button>\n      <button onClick={handleClear}>清空输入框</button>\n      <button onClick={handleGetValue}>获取输入框值</button>\n    </div>\n  );\n}\n```\n\n# 3. 关键细节\n## 3.1 依赖项数组\n`useImperativeHandle` 的第三个参数是依赖项数组，当依赖项变化时，会重新创建暴露的对象：\n```javascript\nuseImperativeHandle(ref, () => ({\n  // 依赖 inputValue，当 inputValue 变化时重新创建对象\n  logValue: () => console.log(inputValue)\n}), [inputValue]);\n```\n\n## 3.2 避免暴露过多内容\n`useImperativeHandle` 的核心价值是**封装**，应仅暴露父组件必需的方法/属性，避免暴露整个 DOM 元素或子组件内部状态：\n```javascript\n// 不推荐：暴露整个 DOM 元素（破坏封装）\nuseImperativeHandle(ref, () => inputRef.current, []);\n\n// 推荐：仅暴露必要方法\nuseImperativeHandle(ref, () => ({\n  focus: () => inputRef.current.focus()\n}), []);\n```\n\n## 3.3 与类组件的对比\n类组件通过 `this.refs` 或传递 `ref` 可直接访问子组件实例，但函数组件需通过 `forwardRef` + `useImperativeHandle` 实现：\n```javascript\n// 类组件子组件\nclass ClassChildInput extends React.Component {\n  focus() {\n    this.inputRef.focus();\n  }\n\n  render() {\n    return <input ref={el => this.inputRef = el} />;\n  }\n}\n\n// 父组件调用\nclass Parent extends React.Component {\n  childRef = React.createRef();\n\n  handleFocus = () => {\n    this.childRef.current.focus();\n  };\n\n  render() {\n    return (\n      <div>\n        <ClassChildInput ref={this.childRef} />\n        <button onClick={this.handleFocus}>聚焦</button>\n      </div>\n    );\n  }\n}\n```\n\n# 4. 适用场景\n1. **表单组件交互**：父组件需要控制子组件表单元素（如聚焦输入框、清空文本域）；\n2. **第三方组件封装**：封装第三方 UI 组件时，暴露自定义方法（如弹窗的打开/关闭）；\n3. **动画控制**：父组件触发子组件内部的动画（如滚动到指定位置、播放动画）；\n4. **避免 DOM 穿透**：子组件内部有多个 DOM 元素，父组件无需知道具体 DOM 结构，仅调用封装好的方法。\n\n# 5. 注意事项\n1. **尽量避免使用**：命令式操作违背 React 声明式编程理念，优先通过 props + 状态管理实现组件通信；\n2. **空值保护**：调用子组件方法时需用 `?.` 保护（避免子组件未挂载时调用导致报错）；\n3. **不要暴露状态**：优先通过 props 传递状态，而非让父组件直接访问子组件内部状态；\n4. **配合 TypeScript 使用**：需定义 ref 类型，增强类型安全：\n   ```typescript\n   import { forwardRef, useImperativeHandle, useRef, Ref } from 'react';\n\n   // 定义暴露的方法类型\n   interface ChildInputRef {\n     focus: () => void;\n     clear: () => void;\n     getValue: () => string;\n   }\n\n   const ChildInput = forwardRef((props: {}, ref: Ref<ChildInputRef>) => {\n     const inputRef = useRef<HTMLInputElement>(null);\n\n     useImperativeHandle(ref, () => ({\n       focus: () => inputRef.current?.focus(),\n       clear: () => { if (inputRef.current) inputRef.current.value = ''; },\n       getValue: () => inputRef.current?.value || ''\n     }), []);\n\n     return <input ref={inputRef} />;\n   });\n\n   // 父组件中使用\n   const childInputRef = useRef<ChildInputRef>(null);\n   ```","directory_id":"0fa74abf-556e-40ef-a0d4-33dc2f8648a5","is_published":true,"created_at":"2025-12-22 03:17:42.652525+00","updated_at":"2025-12-23 09:58:31.326745+00"},{"id":"9588b44a-391e-4575-8266-6e159eb7b275","title":"路由模式","content":"React Router 提供了两种核心的路由模式：`HashRouter` 和 `BrowserRouter`，二者的本质区别在于**使用的 URL 格式不同**、**依赖的浏览器特性不同**，以及**服务端配置要求不同**。\n\n# 1. 核心区别对比\n| 特性                | HashRouter                          | BrowserRouter                      |\n|---------------------|-------------------------------------|------------------------------------|\n| URL 格式            | 包含 `#` 符号（如 `http://localhost:3000/#/home`） | 无 `#` 符号（如 `http://localhost:3000/home`） |\n| 底层实现            | 基于浏览器的 `hashchange` 事件（监听 URL 中 `#` 后的变化） | 基于 HTML5 History API（`pushState`/`replaceState` + `popstate` 事件） |\n| 服务端配置          | 无需服务端配置（`#` 后的内容不会发送到服务端） | 需服务端配置（刷新页面时需返回 index.html，否则 404） |\n| SEO 友好性          | 不友好（搜索引擎可能忽略 `#` 后的内容） | 友好（URL 为真实路径，搜索引擎可正常爬取） |\n| 兼容性              | 兼容所有浏览器（包括 IE 低版本）    | 仅兼容支持 HTML5 History API 的浏览器（IE10+） |\n| 路径参数传递        | 支持（如 `#/users/:id`）            | 支持（如 `/users/:id`）            |\n| 美观性              | 较差（URL 中有 `#` 符号）           | 较好（URL 简洁，与传统网站一致）   |\n\n# 2. HashRouter 详解\n## 2.1 工作原理\n`HashRouter` 利用 URL 中的 **哈希值（`#` 后的部分）** 实现路由跳转：\n- 哈希值的变化不会触发浏览器向服务端发送请求；\n- 浏览器会监听 `hashchange` 事件，当哈希值变化时，React Router 匹配对应的路由组件并渲染。\n\n## 2.2 使用方式\n```jsx\nimport { HashRouter, Routes, Route } from 'react-router-dom';\nimport Home from './pages/Home';\nimport About from './pages/About';\n\nfunction App() {\n  return (\n    <HashRouter>\n      <Routes>\n        <Route path=\"/\" element={<Home />} />\n        <Route path=\"/about\" element={<About />} />\n      </Routes>\n    </HashRouter>\n  );\n}\n```\n\n## 2.3 适用场景\n- 静态网站（无服务端后端）：如部署在 GitHub Pages、Netlify 等静态托管平台的项目；\n- 老项目兼容（需支持 IE 低版本）；\n- 快速原型开发（无需配置服务端）。\n\n## 2.4 局限性\n- URL 中包含 `#` 符号，不够美观；\n- 哈希值部分不会被服务端接收，无法通过服务端获取路由参数；\n- 对 SEO 不友好，部分搜索引擎无法解析哈希后的内容。\n\n# 3. BrowserRouter 详解\n## 3.1 工作原理\n`BrowserRouter` 基于 HTML5 的 **History API** 实现：\n- 通过 `history.pushState()`/`history.replaceState()` 方法修改 URL 路径（不触发页面刷新）；\n- 浏览器监听 `popstate` 事件（用户点击前进/后退按钮时），React Router 匹配路由并渲染组件；\n- 当用户刷新页面时，浏览器会向服务端发送请求，请求当前 URL 对应的资源。\n\n## 3.2 使用方式\n```jsx\nimport { BrowserRouter, Routes, Route } from 'react-router-dom';\nimport Home from './pages/Home';\nimport About from './pages/About';\n\nfunction App() {\n  return (\n    <BrowserRouter>\n      <Routes>\n        <Route path=\"/\" element={<Home />} />\n        <Route path=\"/about\" element={<About />} />\n      </Routes>\n    </BrowserRouter>\n  );\n}\n```\n\n## 3.3 服务端配置要求\n由于刷新页面时浏览器会请求当前 URL 路径，服务端需配置“所有路径都返回 index.html”（让前端路由接管），否则会出现 404 错误。以下是常见服务端的配置示例：\n\n### （1）Nginx 配置\n```nginx\nserver {\n  listen 80;\n  server_name your-domain.com;\n  root /path/to/your/project/build;\n  index index.html;\n\n  # 所有请求都返回 index.html\n  location / {\n    try_files $uri $uri/ /index.html;\n  }\n}\n```\n\n### （2）Express 配置\n```jsx\nconst express = require('express');\nconst path = require('path');\nconst app = express();\n\n// 静态资源目录\napp.use(express.static(path.join(__dirname, 'build')));\n\n// 所有请求返回 index.html\napp.get('*', (req, res) => {\n  res.sendFile(path.join(__dirname, 'build', 'index.html'));\n});\n\napp.listen(3000, () => {\n  console.log('Server running on port 3000');\n});\n```\n\n### （3）GitHub Pages 配置\n若需在 GitHub Pages 上使用 `BrowserRouter`，需添加 `404.html` 文件（内容与 `index.html` 相同），并配置 `basename`（项目仓库名）：\n```jsx\n<BrowserRouter basename=\"/your-repo-name\">\n  {/* 路由配置 */}\n</BrowserRouter>\n```\n\n## 3.4 适用场景\n- 有服务端后端的项目（可配置路由转发）；\n- 对 SEO 有要求的项目（如官网、营销页）；\n- 追求 URL 美观的现代前端项目。\n\n## 3.5 局限性\n- 依赖 HTML5 History API，不兼容 IE 9 及以下版本；\n- 需服务端配置，否则刷新页面会出现 404；\n- 若项目部署在子路径下（如 `https://example.com/app/`），需配置 `basename` 属性。\n\n# 4. 如何选择路由模式？\n1. **优先选 BrowserRouter**：\n   - 项目有服务端支持（可配置路由转发）；\n   - 对 SEO 和 URL 美观性有要求；\n   - 无需兼容低版本 IE。\n\n2. **选 HashRouter**：\n   - 项目为纯静态页面（无服务端）；\n   - 部署在无法配置服务端的平台（如部分免费静态托管）；\n   - 需兼容 IE 低版本；\n   - 快速开发原型，无需关心 URL 美观性。\n\n# 5. 其他注意事项\n1. **`basename` 属性**：当项目部署在域名的子路径下时（如 `https://example.com/my-app/`），需给路由组件配置 `basename` 属性，确保路由路径正确：\n   ```jsx\n   <BrowserRouter basename=\"/my-app\">\n   <HashRouter basename=\"/my-app\">\n   ```\n2. **路由参数与哈希值**：`HashRouter` 中，哈希值后的路径同样支持动态参数（如 `#/users/:id`），使用 `useParams` 可正常获取；\n3. **History 对象**：两种路由模式下，`useHistory`（v5）/`useNavigate`（v6）钩子的使用方式完全一致，无需区分；\n4. **第三方工具兼容**：部分第三方工具（如埋点、分享链接）可能对哈希路由的支持不佳，需额外处理。","directory_id":"77b830a2-38dc-41a0-8e20-9f29ffc5a332","is_published":true,"created_at":"2025-12-22 02:13:08.528384+00","updated_at":"2025-12-23 02:55:42.796275+00"},{"id":"9aff2e40-d52e-43ac-8be4-d7f98ba94fc5","title":"函数组件 useState","content":"在 React 函数组件中，**useState** 是用于管理组件内部状态的 Hook，从 React 16.8 开始引入，彻底解决了函数组件无法存储内部状态的问题。相比类组件的 `state`，`useState` 更轻量、灵活，是函数组件状态管理的核心方案。\n\n# 1. useState 基础用法\n## 1.1 基本语法\n`useState` 是一个函数，接收一个**初始状态值**作为参数，返回一个长度为 2 的数组：\n- 数组第一个元素：**当前状态值**，类似于类组件的 `this.state`。\n- 数组第二个元素：**状态更新函数**，类似于类组件的 `setState`，用于修改状态值。\n\n语法结构：\n```jsx\nimport { useState } from 'react';\n\nfunction Counter() {\n  // 解构赋值：count 是当前状态，setCount 是更新函数，初始值为 0\n  const [count, setCount] = useState(0);\n\n  return (\n    <div>\n      <p>计数：{count}</p>\n      <button onClick={() => setCount(count + 1)}>+1</button>\n    </div>\n  );\n}\n```\n\n## 1.2 初始化状态的两种方式\n### （1）直接传递初始值（适用于初始值为简单类型且无需计算的场景）\n初始值可以是任意 JavaScript 类型：数字、字符串、布尔值、数组、对象等。\n```jsx\n// 数字类型\nconst [age, setAge] = useState(18);\n// 字符串类型\nconst [name, setName] = useState('React');\n// 布尔类型\nconst [isVisible, setIsVisible] = useState(true);\n// 数组类型\nconst [list, setList] = useState(['a', 'b', 'c']);\n// 对象类型\nconst [user, setUser] = useState({ name: '张三', age: 20 });\n```\n\n### （2）传递初始化函数（适用于初始值需要复杂计算的场景）\n如果初始状态的计算逻辑比较复杂（如从本地存储读取数据、执行复杂运算），可以传递一个**无参函数**作为 `useState` 的参数，该函数的返回值会作为初始状态，且**只在组件首次渲染时执行一次**，避免重复计算。\n```jsx\nfunction UserProfile() {\n  // 初始化函数：仅首次渲染执行\n  const initUser = () => {\n    console.log('初始化用户数据（仅执行一次）');\n    return JSON.parse(localStorage.getItem('user')) || { name: '匿名用户' };\n  };\n\n  // 传递初始化函数，避免每次渲染都执行复杂计算\n  const [user, setUser] = useState(initUser);\n\n  return <p>用户名：{user.name}</p>;\n}\n```\n\n## 1.3 核心特性\n- **无 this 绑定**：函数组件没有 `this` 关键字，直接通过解构的变量访问状态，避免类组件的 `this` 指向问题。\n- **状态独立**：多次调用 `useState` 可以定义多个独立的状态，状态之间互不影响。\n  ```jsx\n  function MultiState() {\n    // 多个独立状态\n    const [count, setCount] = useState(0);\n    const [message, setMessage] = useState('Hello');\n    const [isActive, setIsActive] = useState(false);\n\n    return (\n      <div>\n        <p>计数：{count}</p>\n        <p>消息：{message}</p>\n        <p>状态：{isActive ? '激活' : '未激活'}</p>\n      </div>\n    );\n  }\n  ```\n- **触发重新渲染**：调用状态更新函数（如 `setCount`）后，函数组件会重新执行，使用新的状态值生成新的 UI。\n\n# 2. 状态更新规则\n## 2.1 基本更新方式\n`useState` 的状态更新函数有两种调用方式，适用于不同场景：\n\n### （1）直接传递新值（适用于不依赖旧状态的场景）\n直接将新的状态值传递给更新函数，适用于状态更新不依赖当前状态的情况。\n```jsx\nfunction Counter() {\n  const [count, setCount] = useState(0);\n\n  // 直接传递新值\n  const handleReset = () => setCount(0);\n\n  return (\n    <div>\n      <p>计数：{count}</p>\n      <button onClick={() => setCount(count + 1)}>+1</button>\n      <button onClick={handleReset}>重置</button>\n    </div>\n  );\n}\n```\n\n### （2）传递更新函数（适用于依赖旧状态的场景）\n传递一个**回调函数**，函数接收**当前的旧状态**作为参数，返回新的状态值。适用于状态更新依赖旧状态的场景（如累加、数组追加）。\n```jsx\nfunction Counter() {\n  const [count, setCount] = useState(0);\n\n  // 传递更新函数：依赖旧状态计算新值\n  const handleIncrement = () => {\n    setCount(prevCount => prevCount + 1);\n  };\n\n  return (\n    <div>\n      <p>计数：{count}</p>\n      <button onClick={handleIncrement}>+1</button>\n    </div>\n  );\n}\n```\n\n## 2.2 关键更新规则\n### （1）状态更新是“替换”而非“合并”\n这是 `useState` 与类组件 `setState` 的核心区别：\n- 类组件 `setState`：更新时会**合并**旧状态和新状态，未指定的属性会保留。\n- 函数组件 `useState`：更新时会**直接替换**旧状态，未指定的属性会丢失。\n\n```jsx\n// 类组件 setState：合并更新\nthis.setState({ name: '李四' }); // age 属性会保留\n\n// 函数组件 useState：替换更新\nconst [user, setUser] = useState({ name: '张三', age: 20 });\n// 错误：更新后 age 属性会丢失，user 变为 { name: '李四' }\nsetUser({ name: '李四' });\n```\n\n### （2）如何实现对象/数组的“合并更新”？\n要实现对象或数组的合并更新，需要借助**扩展运算符**（`...`），先复制旧状态的所有属性，再修改需要更新的属性。\n```jsx\nfunction UserProfile() {\n  const [user, setUser] = useState({ name: '张三', age: 20 });\n\n  // 对象合并更新：保留旧属性，修改新属性\n  const updateAge = () => {\n    setUser(prevUser => ({\n      ...prevUser, // 复制旧对象的所有属性\n      age: prevUser.age + 1 // 修改需要更新的属性\n    }));\n  };\n\n  return (\n    <div>\n      <p>姓名：{user.name}</p>\n      <p>年龄：{user.age}</p>\n      <button onClick={updateAge}>年龄+1</button>\n    </div>\n  );\n}\n```\n\n### （3）状态更新的“批量性”\n与类组件 `setState` 类似，`useState` 的状态更新在 React 合成事件中也是**批量执行**的，多次调用更新函数会合并为一次渲染，提升性能。\n```jsx\nfunction BatchUpdate() {\n  const [count, setCount] = useState(0);\n\n  const handleBatch = () => {\n    // 多次调用更新函数，合并为一次渲染\n    setCount(prev => prev + 1);\n    setCount(prev => prev + 1);\n    setCount(prev => prev + 1);\n  };\n\n  return (\n    <div>\n      <p>计数：{count}</p>\n      <button onClick={handleBatch}>批量+3</button>\n    </div>\n  );\n}\n```\n点击按钮后，`count` 会从 `0` 直接变为 `3`，且组件只渲染一次。\n\n# 3. 复杂状态管理\n复杂状态指的是状态值为**数组**或**对象**的情况，这类状态的更新需要遵循“不可变数据”原则，避免直接修改原数据。\n\n## 3.1 数组状态管理\n数组状态的常见操作：添加元素、删除元素、修改元素，都需要通过**创建新数组**的方式更新，不能直接修改原数组。\n\n```jsx\nfunction TodoList() {\n  // 初始化数组状态\n  const [todos, setTodos] = useState([\n    { id: 1, text: '学习 React', done: false }\n  ]);\n\n  // 1. 添加元素：创建新数组（原数组 + 新元素）\n  const addTodo = () => {\n    const newTodo = { id: Date.now(), text: '新任务', done: false };\n    setTodos(prevTodos => [...prevTodos, newTodo]);\n  };\n\n  // 2. 删除元素：过滤出需要保留的元素，创建新数组\n  const deleteTodo = (id) => {\n    setTodos(prevTodos => prevTodos.filter(todo => todo.id !== id));\n  };\n\n  // 3. 修改元素：映射数组，更新指定元素\n  const toggleTodo = (id) => {\n    setTodos(prevTodos => \n      prevTodos.map(todo => \n        todo.id === id ? { ...todo, done: !todo.done } : todo\n      )\n    );\n  };\n\n  return (\n    <div>\n      <button onClick={addTodo}>添加任务</button>\n      <ul>\n        {todos.map(todo => (\n          <li key={todo.id} style={{ textDecoration: todo.done ? 'line-through' : 'none' }}>\n            {todo.text}\n            <button onClick={() => deleteTodo(todo.id)}>删除</button>\n            <button onClick={() => toggleTodo(todo.id)}>切换状态</button>\n          </li>\n        ))}\n      </ul>\n    </div>\n  );\n}\n```\n\n## 3.2 对象状态管理\n对象状态的更新需要通过**扩展运算符**复制旧对象的属性，再修改目标属性，确保不直接修改原对象。\n\n```jsx\nfunction UserForm() {\n  // 初始化对象状态\n  const [form, setForm] = useState({\n    username: '',\n    password: '',\n    remember: false\n  });\n\n  // 处理输入变化：更新对象的指定属性\n  const handleChange = (e) => {\n    const { name, value, type, checked } = e.target;\n    // 根据输入类型获取值（普通输入框取 value，复选框取 checked）\n    const inputValue = type === 'checkbox' ? checked : value;\n    // 合并更新对象\n    setForm(prevForm => ({\n      ...prevForm,\n      [name]: inputValue\n    }));\n  };\n\n  return (\n    <form>\n      <div>\n        <label>用户名：</label>\n        <input name=\"username\" value={form.username} onChange={handleChange} />\n      </div>\n      <div>\n        <label>密码：</label>\n        <input type=\"password\" name=\"password\" value={form.password} onChange={handleChange} />\n      </div>\n      <div>\n        <label>\n          <input type=\"checkbox\" name=\"remember\" checked={form.remember} onChange={handleChange} />\n          记住我\n        </label>\n      </div>\n      <button type=\"button\" onClick={() => console.log(form)}>打印表单</button>\n    </form>\n  );\n}\n```\n\n## 3.3 嵌套复杂状态管理\n对于嵌套层级较深的状态（如 `{ user: { info: { address: '北京' } } }`），更新时需要逐层使用扩展运算符复制，确保每一层都是新对象。\n```jsx\nfunction NestedState() {\n  const [data, setData] = useState({\n    user: {\n      name: '张三',\n      info: {\n        age: 20,\n        address: '北京'\n      }\n    }\n  });\n\n  // 更新嵌套的 address 属性\n  const updateAddress = () => {\n    setData(prevData => ({\n      ...prevData, // 复制外层对象\n      user: {\n        ...prevData.user, // 复制 user 对象\n        info: {\n          ...prevData.user.info, // 复制 info 对象\n          address: '上海' // 修改目标属性\n        }\n      }\n    }));\n  };\n\n  return (\n    <div>\n      <p>地址：{data.user.info.address}</p>\n      <button onClick={updateAddress}>修改地址</button>\n    </div>\n  );\n}\n```\n> 注意：如果嵌套层级过深，使用 `useState` 会导致更新逻辑繁琐，此时推荐使用 `useReducer` 或第三方状态管理库（如 Redux）。\n\n# 4. 核心总结\n1. **基础用法**：\n   - `useState` 接收初始值或初始化函数，返回 `[状态值, 更新函数]`。\n   - 初始化函数仅在组件首次渲染时执行，适用于复杂初始值计算。\n2. **状态更新规则**：\n   - 直接传新值：适用于不依赖旧状态的场景。\n   - 传更新函数：适用于依赖旧状态的场景，推荐优先使用。\n   - 状态更新是“替换”而非“合并”，对象/数组更新需用扩展运算符实现合并。\n3. **复杂状态管理**：\n   - 数组更新：使用 `...`、`filter`、`map` 等方法创建新数组。\n   - 对象更新：使用 `...` 复制旧对象属性，再修改目标属性。\n   - 嵌套状态更新：逐层复制，避免直接修改原数据；层级过深时推荐使用 `useReducer`。...","directory_id":"e42a3397-52b2-470f-a87d-08e025ba6944","is_published":true,"created_at":"2025-12-19 11:39:48.983418+00","updated_at":"2025-12-19 11:39:48.983418+00"},{"id":"9b51b490-31be-47b0-9690-e7b23ec7f718","title":"useEffect：副作用处理","content":"`useEffect` 是 React 中用于处理**副作用**的核心 Hook，所谓“副作用”指的是组件渲染过程中无法完成的操作（如数据请求、DOM 操作、订阅/监听、定时器/延时器等）。`useEffect` 让函数组件具备了类似类组件生命周期的能力，统一管理组件的“挂载-更新-卸载”阶段的副作用逻辑。\n\n# 1. 副作用的定义与分类\n## 1.1 什么是副作用？\nReact 组件的核心职责是根据状态（state）和属性（props）渲染 UI，属于“纯逻辑”；而副作用是指：\n- 与外部系统交互的操作（如调用 API 获取数据、操作 localStorage）。\n- 会产生“持久化影响”的操作（如设置定时器、添加事件监听）。\n- 直接操作 DOM 的操作（如修改 DOM 样式、获取 DOM 尺寸）。\n\n这些操作无法在组件渲染期间执行（会导致渲染不一致），必须在渲染完成后执行，`useEffect` 正是为处理这类操作而生。\n\n## 1.2 副作用的分类\n- **无需清理的副作用**：执行后无需后续操作，如数据请求、DOM 一次性修改、日志打印。\n- **需要清理的副作用**：执行后需要在组件卸载或更新前清理，如定时器、事件监听、订阅（避免内存泄漏）。\n\n# 2. useEffect 基本语法与执行机制\n## 2.1 基本语法\n```jsx\nimport { useEffect } from 'react';\n\nuseEffect(() => {\n  // 副作用逻辑（组件渲染后执行）\n\n  // 可选：清理函数（组件卸载或副作用重新执行前执行）\n  return () => {\n    // 清理逻辑（如清除定时器、取消监听）\n  };\n}, [依赖项数组]); // 控制 useEffect 执行时机的依赖项\n```\n\n## 2.2 核心参数说明\n| 参数               | 作用                                                                 |\n|--------------------|----------------------------------------------------------------------|\n| 副作用函数         | 组件渲染后执行的逻辑，支持异步（但建议内部定义 async 函数，而非直接返回 Promise） |\n| 清理函数（可选）| 副作用的“反向操作”，用于清理资源，避免内存泄漏                         |\n| 依赖项数组（可选）| 决定 useEffect 何时执行：<br>1. 不传：组件每次渲染后都执行<br>2. 空数组：仅组件挂载后执行一次<br>3. 有值：仅当依赖项变化时执行 |\n\n## 2.3 执行机制\n- 组件首次渲染：执行副作用函数（挂载阶段）。\n- 组件更新渲染：\n  1. 先执行上一次副作用的清理函数（若有）。\n  2. 再执行新的副作用函数（更新阶段）。\n- 组件卸载：执行最后一次副作用的清理函数（卸载阶段）。\n\n# 3. useEffect 的三种使用场景（依赖项控制）\n## 场景1：无依赖项数组 → 每次渲染后执行\n不传递依赖项数组时，`useEffect` 会在**组件每次渲染完成后执行**（包括首次渲染和每次更新渲染），相当于类组件的 `componentDidMount + componentDidUpdate`。\n\n### 示例：实时更新文档标题\n```jsx\nfunction DocumentTitle() {\n  const [count, setCount] = useState(0);\n\n  // 无依赖项数组：每次渲染后执行\n  useEffect(() => {\n    console.log('副作用执行：更新文档标题');\n    document.title = `当前计数：${count}`;\n  }); // 注意：无依赖项数组\n\n  return (\n    <div>\n      <p>计数：{count}</p>\n      <button onClick={() => setCount(count + 1)}>+1</button>\n    </div>\n  );\n}\n```\n> 缺点：组件每次更新（如 count 变化）都会执行副作用，若副作用逻辑复杂（如数据请求），会导致性能浪费，需谨慎使用。\n\n## 场景2：空依赖项数组 → 仅挂载时执行一次\n传递空数组 `[]` 作为依赖项时，`useEffect` 仅在**组件首次渲染完成后执行一次**（挂载阶段），且清理函数仅在组件卸载时执行，相当于类组件的 `componentDidMount + componentWillUnmount`。\n\n### 示例1：无需清理的副作用（数据请求）\n```jsx\nfunction UserList() {\n  const [users, setUsers] = useState([]);\n\n  // 空依赖项：仅挂载时请求一次数据\n  useEffect(() => {\n    // 数据请求（副作用逻辑）\n    const fetchUsers = async () => {\n      const res = await fetch('https://api.example.com/users');\n      const data = await res.json();\n      setUsers(data);\n    };\n    fetchUsers();\n  }, []); // 空依赖项数组\n\n  return (\n    <ul>\n      {users.map(user => (\n        <li key={user.id}>{user.name}</li>\n      ))}\n    </ul>\n  );\n}\n```\n\n### 示例2：需要清理的副作用（定时器）\n```jsx\nfunction Timer() {\n  const [count, setCount] = useState(0);\n\n  // 空依赖项：仅挂载时设置定时器，卸载时清除\n  useEffect(() => {\n    // 副作用逻辑：设置定时器\n    const timer = setInterval(() => {\n      setCount(prev => prev + 1);\n    }, 1000);\n\n    // 清理函数：组件卸载时清除定时器\n    return () => {\n      clearInterval(timer);\n      console.log('定时器已清除');\n    };\n  }, []); // 空依赖项数组\n\n  return <p>定时器计数：{count}</p>;\n}\n```\n\n## 场景3：有依赖项数组 → 依赖变化时执行\n传递包含变量/函数的依赖项数组时，`useEffect` 仅在**依赖项的值发生变化时执行**（首次渲染会执行一次，后续仅依赖变化执行），精准控制副作用的执行时机，是最常用的场景。\n\n### 示例1：依赖 props 变化请求数据\n```jsx\nfunction UserDetail({ userId }) {\n  const [user, setUser] = useState(null);\n\n  // 依赖 userId：userId 变化时重新请求数据\n  useEffect(() => {\n    const fetchUser = async () => {\n      const res = await fetch(`https://api.example.com/users/${userId}`);\n      const data = await res.json();\n      setUser(data);\n    };\n    fetchUser();\n\n    // 清理函数：取消未完成的请求（可选）\n    return () => {\n      // 若使用 axios 可取消请求：source.cancel('请求取消')\n    };\n  }, [userId]); // 依赖项：userId\n\n  if (!user) return <div>加载中...</div>;\n  return (\n    <div>\n      <h2>{user.name}</h2>\n      <p>年龄：{user.age}</p>\n    </div>\n  );\n}\n```\n\n### 示例2：依赖 state 变化执行副作用\n```jsx\nfunction ThemeSwitcher() {\n  const [theme, setTheme] = useState('light');\n\n  // 依赖 theme：主题变化时修改 body 样式\n  useEffect(() => {\n    document.body.className = theme;\n    console.log(`主题切换为：${theme}`);\n  }, [theme]); // 依赖项：theme\n\n  return (\n    <div>\n      <button onClick={() => setTheme('light')}>亮色主题</button>\n      <button onClick={() => setTheme('dark')}>暗色主题</button>\n    </div>\n  );\n}\n```\n\n# 4. 清理函数的作用与使用场景\n清理函数是 `useEffect` 返回的可选函数，用于清理副作用产生的资源，避免内存泄漏，核心使用场景包括：\n\n## 4.1 清除定时器/延时器\n```jsx\nuseEffect(() => {\n  const timer = setTimeout(() => {\n    console.log('延时执行');\n  }, 1000);\n\n  // 清理函数：组件卸载或副作用重新执行时清除延时器\n  return () => clearTimeout(timer);\n}, []);\n```\n\n## 4.2 取消事件监听\n```jsx\nuseEffect(() => {\n  const handleResize = () => {\n    console.log('窗口尺寸变化：', window.innerWidth);\n  };\n\n  // 副作用：添加窗口resize监听\n  window.addEventListener('resize', handleResize);\n\n  // 清理函数：移除监听\n  return () => window.removeEventListener('resize', handleResize);\n}, []);\n```\n\n## 4.3 取消订阅/数据请求\n```jsx\nuseEffect(() => {\n  // 副作用：订阅数据更新\n  const subscription = dataService.subscribe(data => {\n    console.log('数据更新：', data);\n  });\n\n  // 清理函数：取消订阅\n  return () => subscription.unsubscribe();\n}, []);\n```\n\n## 4.4 清理 DOM 操作痕迹\n```jsx\nuseEffect(() => {\n  // 副作用：添加全局样式\n  document.body.style.backgroundColor = 'red';\n\n  // 清理函数：恢复原样式\n  return () => {\n    document.body.style.backgroundColor = '';\n  };\n}, []);\n```\n\n# 5. useEffect 与类组件生命周期的对应关系\n| useEffect 用法                | 类组件生命周期对应               | 执行时机                     |\n|-------------------------------|----------------------------------|------------------------------|\n| `useEffect(() => { ... })`    | `componentDidMount + componentDidUpdate` | 每次渲染后执行               |\n| `useEffect(() => { ... }, [])`| `componentDidMount`              | 仅挂载时执行一次             |\n| `useEffect(() => { return () => { ... } }, [])` | `componentDidMount + componentWillUnmount` | 挂载时执行副作用，卸载时执行清理 |\n| `useEffect(() => { ... }, [dep])` | 自定义更新逻辑                   | 首次渲染 + dep 变化时执行    |\n\n# 6. useEffect 常见陷阱与避坑指南\n## 陷阱1：依赖项缺失导致无限循环\n#### 问题：\n副作用函数中修改了某个 state，但未将该 state 加入依赖项数组，导致每次渲染都执行副作用，修改 state 后再次渲染，形成无限循环：\n```jsx\n// 错误示例：依赖项缺失导致无限循环\nfunction InfiniteLoop() {\n  const [count, setCount] = useState(0);\n\n  useEffect(() => {\n    // 副作用中修改了 count，但未将 count 加入依赖项\n    setCount(count + 1);\n  }, []); // 空依赖项 → 期望仅执行一次，但实际无限循环\n\n  return <p>count：{count}</p>;\n}\n```\n\n#### 解决：\n- 若依赖该 state，将其加入依赖项数组：\n  ```jsx\n  useEffect(() => {\n    setCount(count + 1);\n  }, [count]); // 加入依赖项，仅 count 变化时执行\n  ```\n- 若无需依赖当前值，使用更新函数（推荐）：\n  ```jsx\n  useEffect(() => {\n    setCount(prev => prev + 1);\n  }, []); // 无依赖，仅执行一次\n  ```\n\n## 陷阱2：异步函数直接返回 Promise\n#### 问题：\n`useEffect` 的副作用函数若直接返回 Promise（如使用 async/await 修饰），会导致 React 警告（因为 useEffect 期望返回清理函数或 undefined，而非 Promise）：\n```jsx\n// 错误示例：副作用函数返回 Promise\nuseEffect(async () => {\n  const res = await fetch('/api/data');\n  const data = await res.json();\n  setData(data);\n}, []);\n```\n\n#### 解决：\n在副作用函数内部定义 async 函数并调用，避免直接返回 Promise：\n```jsx\n// 正确示例：内部定义 async 函数\nuseEffect(() => {\n  const fetchData = async () => {\n    const res = await fetch('/api/data');\n    const data = await res.json();\n    setData(data);\n  };\n  fetchData();\n}, []);\n```\n\n## 陷阱3：闭包陷阱导致获取不到最新状态\n#### 问题：\n副作用函数形成闭包，捕获了渲染时的 state 值，后续 state 更新后，副作用函数仍使用旧值：\n```jsx\n// 闭包陷阱示例：定时器中获取的是初始 count 值\nfunction ClosureTrap() {\n  const [count, setCount] = useState(0);\n\n  useEffect(() => {\n    const timer = setInterval(() => {\n      console.log('count：', count); // 始终输出 0，无法获取最新值\n    }, 1000);\n    return () => clearInterval(timer);\n  }, []); // 空依赖项，副作用仅执行一次\n\n  return (\n    <div>\n      <p>count：{count}</p>\n      <button onClick={() => setCount(prev => prev + 1)}>+1</button>\n    </div>\n  );\n}\n```\n\n#### 解决：\n- 若需实时获取最新状态，将 state 加入依赖项数组：\n  ```jsx\n  useEffect(() => {\n    const timer = setInterval(() => {\n      console.log('count：', count); // 依赖 count，变化时重新创建定时器\n    }, 1000);\n    return () => clearInterval(timer);\n  }, [count]); // 加入依赖项\n  ```\n- 若不想频繁重建定时器，使用 `useRef` 存储最新状态（后续 `useRef` 章节详细说明）。\n\n## 陷阱4：忽略清理函数导致内存泄漏\n#### 问题：\n组件卸载后，未清理的副作用（如定时器、请求）仍在执行，修改已卸载组件的 state，导致控制台警告：\n```jsx\n// 内存泄漏示例：组件卸载后请求仍在执行\nfunction LeakExample() {\n  const [data, setData] = useState(null);\n\n  useEffect(() => {\n    fetch('/api/data').then(res => res.json()).then(data => {\n      setData(data); // 组件卸载后执行，导致警告\n    });\n  }, []);\n\n  return <div>{data ? data.name : '加载中...'}</div>;\n}\n```\n\n#### 解决：\n- 使用 AbortController 取消请求：\n  ```jsx\n  useEffect(() => {\n    const controller = new AbortController();\n    const signal = controller.signal;\n\n    fetch('/api/data', { signal }).then(res => res.json()).then(data => {\n      setData(data);\n    }).catch(err => {\n      if (err.name !== 'AbortError') console.error(err);\n    });\n\n    // 清理函数：取消请求\n    return () => controller.abort();\n  }, []);\n  ```\n- 添加组件挂载状态标记：\n  ```jsx\n  useEffect(() => {\n    let isMounted = true; // 标记组件是否挂载\n\n    fetch('/api/data').then(res => res.json()).then(data => {\n      if (isMounted) setData(data); // 仅组件挂载时修改 state\n    });\n\n    // 清理函数：标记组件已卸载\n    return () => {\n      isMounted = false;\n    };\n  }, []);\n  ```\n\n# 7. 核心总结\n1. **核心作用**：处理函数组件的副作用，统一管理组件挂载、更新、卸载阶段的非渲染逻辑。\n2. **执行时机**：由依赖项数组控制，分为“每次渲染执行”“仅挂载执行”“依赖变化执行”三种场景。\n3. **清理函数**：用于清理副作用资源（定时器、监听、订阅），避免内存泄漏，在组件卸载或副作用重新执行前执行。\n4. **避坑要点**：\n   - 依赖项数组必须包含副作用中使用的所有 state/props/函数。\n   - 副作用函数内部定义 async 函数，避免直接返回 Promise。\n   - 闭包陷阱需通过依赖项或 useRef 解决。\n   - 异步操作需添加清理逻辑，避免组件卸载后修改 state。...","directory_id":"8ef7f873-12e2-4aaf-933f-26eddf895f27","is_published":true,"created_at":"2025-12-19 15:11:05.540486+00","updated_at":"2025-12-22 02:00:02.894093+00"},{"id":"9b611696-9f87-44b5-8c42-e1207769c5b4","title":" Ant Design/Element Plus/MUI 选型与使用","content":"# 1. 三大组件库核心对比\n| 特性                | Ant Design (AntD)                          | Element Plus                              | MUI (Material UI)                        |\n|---------------------|--------------------------------------------|-------------------------------------------|-------------------------------------------|\n| 设计语言            | 蚂蚁集团企业级设计体系（简约、专业）| 饿了么团队基于 Vue 生态的桌面端设计体系    | Google Material Design（拟物、动效）|\n| 技术栈支持          | React 优先（Vue 版本为 AntD Vue）| Vue 3 优先（React 无官方版本）| React 专属                                |\n| 组件丰富度          | 极高（200+ 组件，覆盖企业级场景）| 高（100+ 组件，聚焦中后台）| 高（100+ 组件，覆盖多端）|\n| 生态与社区          | 国内生态成熟，中文文档完善                 | Vue 生态内活跃，中文文档完善              | 全球社区活跃，英文文档为主                |\n| 定制化能力          | 支持主题定制、组件二次封装                 | 支持主题定制、按需引入                    | 支持 CSS-in-JS 深度定制、主题切换        |\n| 国际化支持          | 内置多语言，支持自定义                     | 内置多语言，Vue I18n 集成                 | 内置多语言，i18next 集成                  |\n| 适用场景            | 中后台系统、企业级应用                     | Vue 技术栈中后台系统                      | 移动端/桌面端 Material Design 风格应用    |\n| 学习成本            | 低（中文文档，组件逻辑统一）| 低（Vue 生态友好，中文文档）| 中（CSS-in-JS 概念，英文文档）|\n\n# 2. 选型决策依据\n## 2.1 技术栈匹配\n- 若项目基于 React：优先选择 AntD 或 MUI（AntD 更适配国内企业级场景，MUI 更适配 Material Design 设计）；\n- 若项目基于 Vue：直接选择 Element Plus（无竞品替代）；\n- 跨端项目（React Native）：MUI 有配套的 MUI X 支持，AntD 有 AntD Mobile。\n\n## 2.2 设计风格匹配\n- 企业级中后台：AntD/Element Plus（设计风格更贴合国内办公场景）；\n- 消费级产品（ToC）：MUI（Material Design 更符合移动端用户习惯）；\n- 定制化设计需求高：MUI（CSS-in-JS 支持更灵活的样式定制）。\n\n## 2.3 功能需求匹配\n- 需要复杂表单、表格、权限组件：AntD（ProComponents 扩展组件更强大）；\n- 需要轻量化组件、快速开发：Element Plus（组件体积更小）；\n- 需要 Material Design 动效、无障碍支持：MUI（原生支持 WCAG 标准）。\n\n# 3. 快速上手（React 生态）\n## 3.1 Ant Design 集成\n### 3.1.1 安装依赖\n```bash\nnpm install antd # 核心依赖\n# 图标库（AntD 5.x 内置 @ant-design/icons，无需单独安装）\n```\n\n### 3.1.2 基础使用\n```tsx\nimport React from 'react';\nimport { Button, Space, message } from 'antd';\n\nconst App = () => {\n  const handleClick = () => {\n    message.success('AntD 按钮点击成功！');\n  };\n\n  return (\n    <Space direction=\"vertical\" size=\"middle\">\n      <Button type=\"primary\" onClick={handleClick}>\n        主要按钮\n      </Button>\n      <Button type=\"default\">默认按钮</Button>\n      <Button type=\"dashed\">虚线按钮</Button>\n      <Button type=\"text\">文本按钮</Button>\n      <Button type=\"link\">链接按钮</Button>\n    </Space>\n  );\n};\n\nexport default App;\n```\n\n###  3.1.3 主题定制（ConfigProvider）\n```tsx\nimport { ConfigProvider } from 'antd';\n\nconst App = () => {\n  return (\n    <ConfigProvider\n      theme={{\n        token: {\n          colorPrimary: '#1890ff', // 主色调\n          fontSize: 14, // 基础字体大小\n          borderRadius: 4, // 圆角大小\n        },\n      }}\n    >\n      {/* 应用内容 */}\n      <Button type=\"primary\">定制主题按钮</Button>\n    </ConfigProvider>\n  );\n};\n```\n\n## 3.2 MUI 集成\n### 3.2.1 安装依赖\n```bash\nnpm install @mui/material @emotion/react @emotion/styled # 核心依赖\nnpm install @mui/icons-material # 图标库\n```\n\n### 3.2.2 基础使用\n```tsx\nimport React from 'react';\nimport Button from '@mui/material/Button';\nimport Box from '@mui/material/Box';\nimport Snackbar from '@mui/material/Snackbar';\nimport Alert from '@mui/material/Alert';\n\nconst App = () => {\n  const [open, setOpen] = React.useState(false);\n\n  const handleClick = () => {\n    setOpen(true);\n  };\n\n  const handleClose = () => {\n    setOpen(false);\n  };\n\n  return (\n    <Box sx={{ display: 'flex', gap: 2 }}>\n      <Button variant=\"contained\" onClick={handleClick}>\n        Contained 按钮\n      </Button>\n      <Button variant=\"outlined\">Outlined 按钮</Button>\n      <Button variant=\"text\">Text 按钮</Button>\n      <Snackbar open={open} autoHideDuration={6000} onClose={handleClose}>\n        <Alert onClose={handleClose} severity=\"success\" sx={{ width: '100%' }}>\n          MUI 按钮点击成功！\n        </Alert>\n      </Snackbar>\n    </Box>\n  );\n};\n\nexport default App;\n```\n\n### 3.2.3 主题定制（ThemeProvider）\n```tsx\nimport { createTheme, ThemeProvider } from '@mui/material/styles';\nimport Button from '@mui/material/Button';\n\n// 自定义主题\nconst theme = createTheme({\n  palette: {\n    primary: {\n      main: '#1976d2',\n    },\n    secondary: {\n      main: '#dc004e',\n    },\n  },\n  typography: {\n    fontSize: 14,\n  },\n});\n\nconst App = () => {\n  return (\n    <ThemeProvider theme={theme}>\n      <Button variant=\"contained\" color=\"primary\">\n        定制主题按钮\n      </Button>\n    </ThemeProvider>\n  );\n};\n```\n\n# 4. 最佳实践\n## 4.1 按需引入\n- AntD 5.x 及 MUI 均支持 Tree Shaking，无需额外配置，直接导入组件即可；\n- 避免全量导入（如 `import * as Antd from 'antd'`），减少打包体积。\n\n## 4.2 组件二次封装\n- 对高频使用的组件（如按钮、输入框）进行二次封装，统一业务逻辑和样式：\n  ```tsx\n  // AntD 按钮二次封装\n  import { Button, ButtonProps } from 'antd';\n\n  interface MyButtonProps extends ButtonProps {\n    bizType?: 'primary' | 'danger' | 'success';\n  }\n\n  const MyButton = ({ bizType = 'primary', children, ...props }: MyButtonProps) => {\n    const typeMap = {\n      primary: 'primary',\n      danger: 'danger',\n      success: 'success',\n    };\n\n    return (\n      <Button type={typeMap[bizType]} {...props}>\n        {children}\n      </Button>\n    );\n  };\n\n  export default MyButton;\n  ```\n\n## 4.3 性能优化\n- 避免频繁创建内联样式（如 MUI 的 `sx` 属性），抽离为常量；\n- 对大数据表格（如 AntD Table）使用虚拟滚动（`scroll={{ y: 500 }}` + `pagination`）；\n- 关闭不必要的动画（如 AntD 的 `motion` 配置）提升低性能设备体验。\n\n# 5. 扩展生态\n## 5.1 Ant Design 扩展\n- **Ant Design Pro**：企业级中后台脚手架（https://pro.ant.design/）；\n- **ProComponents**：高级组件库（表格、表单、布局，https://procomponents.ant.design/）；\n- **Ant Design Mobile**：移动端组件库（https://mobile.ant.design/）。\n\n## 5.2 MUI 扩展\n- **MUI X**：高级组件库（数据网格、日期选择器，https://mui.com/x/）；\n- **MUI Base**：无样式基础组件（支持自定义主题，https://mui.com/base/）；\n- **MUI System**：样式工具库（https://mui.com/system/）。","directory_id":"7fccb039-1e39-4894-ba93-5568169fef6e","is_published":true,"created_at":"2025-12-22 03:21:17.172404+00","updated_at":"2025-12-23 14:11:25.18823+00"},{"id":"9bd6f57f-1784-4a42-9ece-7af926f0b70a","title":"TypeScript 高级用法","content":"# 1. 泛型（Generics）\n泛型是 TypeScript 的核心特性，用于创建可复用的类型组件，支持“类型参数化”—— 让类型像函数参数一样传递，解决类型固化问题。\n\n## 1.1 泛型基础：函数泛型\n需求：创建一个函数，接收任意类型的参数并返回相同类型的值：\n```tsx\n// 非泛型实现（类型固化，只能处理 string）\nfunction returnValue(value: string): string {\n  return value;\n}\n\n// 泛型实现（类型参数化，T 为类型变量）\nfunction returnValue<T>(value: T): T {\n  return value;\n}\n\n// 使用：显式指定类型\nconst str = returnValue<string>('hello'); // str: string\nconst num = returnValue<number>(123); // num: number\n\n// 自动推导类型（推荐）\nconst bool = returnValue(false); // bool: boolean\nconst arr = returnValue([1, 2, 3]); // arr: number[]\n```\n- `T` 是类型变量（可自定义名称，如 `U`/`V`），代表任意类型；\n- 调用函数时，TypeScript 会根据传入的参数自动推导 `T` 的具体类型。\n\n## 1.2 泛型接口/类型\n泛型可用于接口或类型别名，创建通用的类型结构：\n```tsx\n// 泛型接口\ninterface Result<T> {\n  code: number;\n  data: T; // data 类型由 T 决定\n  message: string;\n}\n\n// 使用：指定 T 为 User 类型\ninterface User {\n  id: number;\n  name: string;\n}\nconst userResult: Result<User> = {\n  code: 200,\n  data: { id: 1, name: '张三' },\n  message: 'success',\n};\n\n// 指定 T 为商品数组类型\ninterface Product {\n  id: number;\n  price: number;\n}\nconst productResult: Result<Product[]> = {\n  code: 200,\n  data: [{ id: 1, price: 99 }],\n  message: 'success',\n};\n\n// 泛型类型别名\ntype Container<T> = {\n  value: T;\n  label: string;\n};\n\nconst stringContainer: Container<string> = { value: 'test', label: '字符串容器' };\n```\n\n## 1.3 泛型组件（React 核心场景）\nReact 中泛型组件用于创建可复用的通用组件（如列表、表单组件）：\n```tsx\n// 泛型列表组件\ninterface ListProps<T> {\n  data: T[];\n  renderItem: (item: T, index: number) => React.ReactNode; // 渲染函数，接收 T 类型的 item\n}\n\n// 泛型函数组件（语法：<T,>(props: ListProps<T>) => ...）\nconst List = <T,>({ data, renderItem }: ListProps<T>) => {\n  return (\n    <ul>\n      {data.map((item, index) => (\n        <li key={index}>{renderItem(item, index)}</li>\n      ))}\n    </ul>\n  );\n};\n\n// 使用：指定 T 为 User 类型\ninterface User {\n  id: number;\n  name: string;\n}\nconst userList: User[] = [{ id: 1, name: '张三' }, { id: 2, name: '李四' }];\n\n<List<User> \n  data={userList} \n  renderItem={(item) => <div>{item.name}</div>} \n/>\n\n// 使用：指定 T 为 number 类型\n<List<number> \n  data={[1, 2, 3]} \n  renderItem={(item) => <div>数字：{item}</div>} \n/>\n```\n- 泛型组件语法：函数组件需在参数前添加 `<T,>`（逗号避免与 JSX 标签混淆）；\n- 调用组件时通过 `<T>` 指定具体类型，确保 `data` 和 `renderItem` 类型匹配。\n\n## 1.4 泛型约束（Constraints）\n泛型默认支持任意类型，通过 `extends` 可约束泛型的范围：\n```tsx\n// 约束 T 必须包含 id 属性\ninterface HasId {\n  id: number;\n}\n\n// 泛型函数：仅处理包含 id 的对象\nfunction findById<T extends HasId>(list: T[], id: number): T | undefined {\n  return list.find(item => item.id === id);\n}\n\n// 正确：User 包含 id\ninterface User extends HasId { name: string; }\nconst users: User[] = [{ id: 1, name: '张三' }, { id: 2, name: '李四' }];\nfindById(users, 1); // 返回 User | undefined\n\n// 错误：string[] 不包含 id 属性\nfindById(['a', 'b'], 1); // TypeScript 报错\n```\n\n## 1.5 多泛型参数\n支持多个类型变量，适用于关联多个类型的场景：\n```tsx\nfunction merge<T, U>(a: T, b: U): { a: T; b: U } {\n  return { a, b };\n}\n\nconst result = merge({ name: '张三' }, { age: 20 });\n// result 类型：{ a: { name: string }; b: { age: number } }\n```\n\n# 2. 类型断言（Type Assertion）\n类型断言用于告诉 TypeScript：“我知道这个值的具体类型，你不用推导了”，本质是类型覆盖（无运行时影响）。\n\n## 2.1 语法\n- 尖括号语法：`<类型>值`（React 中避免使用，与 JSX 冲突）；\n- as 语法：`值 as 类型`（推荐，React 中唯一可用）。\n\n## 2.2 常见场景\n### 场景1：DOM 元素类型断言\n`useRef` 初始值为 `null`，需断言为具体 DOM 类型：\n```tsx\nconst inputRef = useRef<HTMLInputElement>(null);\n\nuseEffect(() => {\n  // 断言 inputRef.current 不为 null（非空断言 + 类型断言）\n  (inputRef.current as HTMLInputElement).focus();\n  // 或简化（非空断言：! 表示排除 null/undefined）\n  inputRef.current!.focus();\n}, []);\n```\n\n### 场景2：API 响应数据类型断言\n接口返回数据为 `any` 类型，需断言为具体类型：\n```tsx\ninterface User {\n  id: number;\n  name: string;\n}\n\nconst fetchUser = async () => {\n  const res = await fetch('/api/user');\n  const data = await res.json(); // data: any\n  const user = data as User; // 断言为 User 类型\n  console.log(user.name); // 类型安全\n};\n```\n\n### 场景3：联合类型缩小范围\n联合类型中需明确具体类型：\n```tsx\ntype Data = string | number;\n\nfunction handleData(data: Data) {\n  if ((data as string).length) {\n    // 断言为 string 类型，访问 length 属性\n    console.log('字符串长度：', (data as string).length);\n  } else {\n    console.log('数字：', data);\n  }\n}\n```\n\n## 2.3 非空断言（!）\n`!` 是特殊的类型断言，表示“该值不为 null/undefined”：\n```tsx\nconst getElement = (): HTMLElement | null => {\n  return document.getElementById('test');\n};\n\nconst element = getElement();\nelement!.style.color = 'red'; // ! 断言 element 不为 null\n```\n\n## 2.4 类型断言的限制\n类型断言不能完全违背类型体系，只能在“兼容类型”间转换：\n```tsx\n// 错误：string 与 number 不兼容\nconst num = '123' as number; // TypeScript 报错\n\n// 正确：先断言为 any，再断言为 number（不推荐，避免滥用）\nconst num = '123' as any as number;\n```\n\n# 3. TypeScript 工具类型（Utility Types）\nTypeScript 内置了一系列工具类型，用于快速转换类型，避免重复定义。以下是 React 项目中最常用的工具类型：\n\n## 3.1 Partial<T>：将 T 的所有属性变为可选\n```tsx\ninterface User {\n  id: number;\n  name: string;\n  age: number;\n}\n\n// Partial<User> 等价于 { id?: number; name?: string; age?: number }\ntype PartialUser = Partial<User>;\n\n// 场景：更新用户信息（无需传递所有属性）\nconst updateUser = (user: PartialUser) => { /* ... */ };\nupdateUser({ name: '李四' }); // 正确，仅更新 name\n```\n\n## 3.2 Required<T>：将 T 的所有属性变为必选\n```tsx\ninterface User {\n  id?: number;\n  name?: string;\n}\n\n// Required<User> 等价于 { id: number; name: string }\ntype RequiredUser = Required<User>;\n\nconst user: RequiredUser = { id: 1, name: '张三' }; // 必须传递所有属性\n```\n\n## 3.3 Readonly<T>：将 T 的所有属性变为只读\n```tsx\ninterface User {\n  name: string;\n}\n\n// Readonly<User> 等价于 { readonly name: string }\ntype ReadonlyUser = Readonly<User>;\n\nconst user: ReadonlyUser = { name: '张三' };\nuser.name = '李四'; // 错误：属性只读\n```\n\n## 3.4 Pick<T, K>：从 T 中挑选指定属性 K\n```tsx\ninterface User {\n  id: number;\n  name: string;\n  age: number;\n  email: string;\n}\n\n// Pick<User, 'name' | 'age'> 等价于 { name: string; age: number }\ntype UserInfo = Pick<User, 'name' | 'age'>;\n\nconst userInfo: UserInfo = { name: '张三', age: 20 }; // 仅包含 name 和 age\n```\n\n## 3.5 Omit<T, K>：从 T 中排除指定属性 K\n```tsx\ninterface User {\n  id: number;\n  name: string;\n  age: number;\n  email: string;\n}\n\n// Omit<User, 'id' | 'email'> 等价于 { name: string; age: number }\ntype UserInfo = Omit<User, 'id' | 'email'>;\n\nconst userInfo: UserInfo = { name: '张三', age: 20 }; // 排除 id 和 email\n```\n\n## 3.6 Exclude<T, U>：从 T 中排除可赋值给 U 的类型\n```tsx\n// Exclude<string | number | boolean, number> 等价于 string | boolean\ntype MyType = Exclude<string | number | boolean, number>;\n\nconst a: MyType = 'hello'; // 正确\nconst b: MyType = 123; // 错误：排除了 number\n```\n\n## 3.7 Extract<T, U>：从 T 中提取可赋值给 U 的类型\n```tsx\n// Extract<string | number | boolean, number | boolean> 等价于 number | boolean\ntype MyType = Extract<string | number | boolean, number | boolean>;\n\nconst a: MyType = 123; // 正确\nconst b: MyType = true; // 正确\nconst c: MyType = 'hello'; // 错误：未提取 string\n```\n\n## 3.8 Record<K, T>：创建键为 K、值为 T 的对象类型\n```tsx\n// Record<string, number> 等价于 { [key: string]: number }\ntype Score = Record<string, number>;\n\nconst score: Score = {\n  math: 90,\n  english: 85,\n};\n\n// 结合联合类型指定键名\ntype Subject = 'math' | 'english' | 'chinese';\ntype SubjectScore = Record<Subject, number>;\n\nconst subjectScore: SubjectScore = {\n  math: 90,\n  english: 85,\n  chinese: 95,\n};\n```\n\n## 3.9 ReturnType<T>：获取函数 T 的返回值类型\n```tsx\nfunction getUser() {\n  return { id: 1, name: '张三', age: 20 };\n}\n\n// ReturnType<typeof getUser> 等价于 { id: number; name: string; age: number }\ntype User = ReturnType<typeof getUser>;\n\nconst user: User = { id: 2, name: '李四', age: 25 }; // 类型匹配\n```\n\n## 3.10 Parameters<T>：获取函数 T 的参数类型（数组）\n```tsx\nfunction add(a: number, b: string): number {\n  return a + Number(b);\n}\n\n// Parameters<typeof add> 等价于 [number, string]\ntype AddParams = Parameters<typeof add>;\n\nconst params: AddParams = [123, '456']; // 正确\nadd(...params); // 调用函数\n```\n\n# 4. 工具类型组合使用\n实际项目中常组合多个工具类型，实现复杂类型转换：\n```tsx\ninterface User {\n  id: number;\n  name: string;\n  age: number;\n  email: string;\n  password: string;\n}\n\n// 需求1：创建用户表单类型（排除 id，其他可选）\ntype UserForm = Partial<Omit<User, 'id'>>;\n// 等价于：{ name?: string; age?: number; email?: string; password?: string }\n\n// 需求2：创建用户展示类型（挑选 name/age，且只读）\ntype UserDisplay = Readonly<Pick<User, 'name' | 'age'>>;\n// 等价于：{ readonly name: string; readonly age: number }\n\n// 需求3：创建 API 响应类型（通用结果 + 用户数据）\ntype ApiResponse<T> = {\n  code: number;\n  message: string;\n  data: T;\n};\n\ntype UserApiResponse = ApiResponse<User>;\n// 等价于：{ code: number; message: string; data: User }\n```\n\n# 5. 类型守卫（Type Guard）\n类型守卫用于在运行时判断类型，缩小类型范围，常与联合类型配合：\n\n## 5.1 typeof 类型守卫\n判断基础类型（string/number/boolean 等）：\n```tsx\ntype Data = string | number;\n\nfunction handleData(data: Data) {\n  if (typeof data === 'string') {\n    // 此处 data 被推断为 string 类型\n    console.log(data.length);\n  } else {\n    // 此处 data 被推断为 number 类型\n    console.log(data.toFixed(2));\n  }\n}\n```\n\n## 5.2 instanceof 类型守卫\n判断类实例类型：\n```tsx\nclass User {\n  name: string;\n  constructor(name: string) {\n    this.name = name;\n  }\n}\n\nclass Product {\n  price: number;\n  constructor(price: number) {\n    this.price = price;\n  }\n}\n\ntype Item = User | Product;\n\nfunction handleItem(item: Item) {\n  if (item instanceof User) {\n    // 此处 item 被推断为 User 类型\n    console.log(item.name);\n  } else {\n    // 此处 item 被推断为 Product 类型\n    console.log(item.price);\n  }\n}\n```\n\n## 5.3 自定义类型守卫\n通过 `is` 关键字定义自定义类型判断：\n```tsx\ninterface Cat {\n  type: 'cat';\n  meow: () => void;\n}\n\ninterface Dog {\n  type: 'dog';\n  bark: () => void;\n}\n\ntype Animal = Cat | Dog;\n\n// 自定义类型守卫：判断是否为 Cat\nfunction isCat(animal: Animal): animal is Cat {\n  return animal.type === 'cat';\n}\n\nfunction handleAnimal(animal: Animal) {\n  if (isCat(animal)) {\n    // 此处 animal 被推断为 Cat 类型\n    animal.meow();\n  } else {\n    // 此处 animal 被推断为 Dog 类型\n    animal.bark();\n  }\n}\n```...","directory_id":"f9e86587-de73-4459-b574-fbd8be79b7c1","is_published":true,"created_at":"2025-12-22 03:20:11.480142+00","updated_at":"2025-12-23 13:37:57.613623+00"},{"id":"9bfcb4a8-5b96-4bce-9814-06785c13efad","title":"useState：状态管理核心","content":"`useState` 是 React 中最基础、最核心的 Hook，用于在函数组件中添加和管理局部状态，是函数组件实现“状态化”的核心方案。从 React 16.8 引入 Hooks 开始，`useState` 彻底解决了函数组件无法存储内部状态的痛点，让函数组件具备了与类组件同等的状态管理能力。\n\n# 1. useState 基本概念与原理\n## 1.1 核心定义\n`useState` 是一个**内置函数**，接收一个**初始状态值**作为参数，返回一个包含两个元素的数组：\n- 第一个元素：`state` → 当前的状态值，类比类组件的 `this.state`。\n- 第二个元素：`setState` → 状态更新函数，类比类组件的 `this.setState`，用于修改状态值并触发组件重新渲染。\n\n## 1.2 工作原理\n- 组件首次渲染时，`useState` 会根据传入的初始值初始化状态，并将状态存储在 React 的内部状态管理队列中。\n- 调用 `setState` 时，React 会更新对应的状态值，并将组件标记为“需要重新渲染”。\n- 组件重新渲染时，`useState` 会返回更新后的最新状态值，而非初始值（初始值仅在首次渲染生效）。\n\n# 2. useState 基础用法\n## 2.1 基本语法与解构\n```jsx\nimport { useState } from 'react';\n\nfunction Counter() {\n  // 解构赋值：count 是状态值，setCount 是更新函数，初始值为 0\n  const [count, setCount] = useState(0);\n\n  // 状态更新逻辑：点击按钮调用 setCount 修改 count\n  const handleIncrement = () => {\n    setCount(count + 1);\n  };\n\n  return (\n    <div>\n      <p>当前计数：{count}</p>\n      <button onClick={handleIncrement}>+1</button>\n    </div>\n  );\n}\n```\n\n## 2.2 初始值的两种设置方式\n### （1）直接传递初始值（简单场景）\n初始值可以是任意 JavaScript 类型（数字、字符串、布尔、数组、对象），适用于初始值无需计算的场景：\n```jsx\n// 数字\nconst [age, setAge] = useState(18);\n// 字符串\nconst [name, setName] = useState('React');\n// 布尔\nconst [isShow, setIsShow] = useState(false);\n// 数组\nconst [list, setList] = useState(['a', 'b', 'c']);\n// 对象\nconst [user, setUser] = useState({ name: '张三', age: 20 });\n```\n\n### （2）传递初始化函数（复杂场景）\n如果初始值需要通过**复杂计算**（如从本地存储读取、执行API请求、复杂运算）得到，建议传递一个**无参函数**作为 `useState` 的参数。该函数仅在**组件首次渲染时执行一次**，避免每次渲染重复计算，优化性能：\n```jsx\nfunction UserProfile() {\n  // 初始化函数：仅首次渲染执行\n  const initUser = () => {\n    console.log('初始化用户数据（仅执行一次）');\n    return JSON.parse(localStorage.getItem('user')) || { name: '匿名用户' };\n  };\n\n  // 传递初始化函数，而非直接传递计算结果\n  const [user, setUser] = useState(initUser);\n\n  return <p>用户名：{user.name}</p>;\n}\n```\n> 注意：若直接传递计算结果（如 `useState(JSON.parse(localStorage.getItem('user')))`），则每次组件渲染都会执行该计算，导致性能浪费。\n\n## 2.3 多状态管理\n`useState` 支持在一个组件中多次调用，实现多个独立状态的管理，状态之间互不干扰：\n```jsx\nfunction MultiStateComponent() {\n  // 多个独立状态\n  const [count, setCount] = useState(0);\n  const [message, setMessage] = useState('Hello React');\n  const [isActive, setIsActive] = useState(true);\n\n  return (\n    <div>\n      <p>计数：{count}</p>\n      <p>消息：{message}</p>\n      <p>状态：{isActive ? '激活' : '未激活'}</p>\n      <button onClick={() => setCount(count + 1)}>计数+1</button>\n      <button onClick={() => setMessage('Hello Hooks')}>修改消息</button>\n      <button onClick={() => setIsActive(!isActive)}>切换状态</button>\n    </div>\n  );\n}\n```\n\n# 3. 状态更新的两种方式\n## 3.1 直接传递新值（非依赖更新）\n适用于状态更新**不依赖当前状态值**的场景，直接将新值传递给 `setState`：\n```jsx\n// 重置计数为 0（不依赖当前 count 值）\nsetCount(0);\n// 修改消息为固定内容（不依赖当前 message 值）\nsetMessage('新消息');\n```\n\n## 3.2 传递更新函数（依赖更新）\n适用于状态更新**依赖当前状态值**的场景（如累加、数组追加），传递一个接收 `prevState`（当前状态值）的回调函数，返回新的状态值。这种方式能确保获取到最新的状态值，避免批量更新导致的错误：\n```jsx\n// 累加：依赖当前 count 值，使用更新函数\nsetCount(prevCount => prevCount + 1);\n\n// 数组追加：依赖当前 list 值，使用更新函数\nsetList(prevList => [...prevList, 'd']);\n```\n\n### 为什么需要更新函数？\nReact 的状态更新在合成事件中是**批量执行**的，多次直接传递新值可能导致基于旧状态计算的错误：\n```jsx\n// 错误示例：多次直接更新，最终 count 只加 1\nconst handleBatchAdd = () => {\n  setCount(count + 1);\n  setCount(count + 1);\n  setCount(count + 1);\n};\n\n// 正确示例：使用更新函数，最终 count 加 3\nconst handleBatchAdd = () => {\n  setCount(prev => prev + 1);\n  setCount(prev => prev + 1);\n  setCount(prev => prev + 1);\n};\n```\n\n# 4. 复杂状态管理（数组/对象）\n`useState` 管理数组、对象等复杂类型时，需遵循**不可变数据原则**：不直接修改原状态，而是创建新的数组/对象替换原状态（因为 React 是通过引用比较判断状态是否变化的）。\n\n## 4.1 数组状态管理\n| 操作       | 实现方式（创建新数组）| 示例                                                                 |\n|------------|---------------------------------|----------------------------------------------------------------------|\n| 添加元素   | 扩展运算符（...）+ 新元素       | `setList(prev => [...prev, 'new item'])`                             |\n| 删除元素   | filter 过滤                     | `setList(prev => prev.filter(item => item.id !== targetId))`         |\n| 修改元素   | map 映射                        | `setList(prev => prev.map(item => item.id === targetId ? {...item, name: '新名称'} : item))` |\n| 清空数组   | 直接设置空数组                  | `setList([])`                                                        |\n\n### 示例：待办事项列表\n```jsx\nfunction TodoList() {\n  const [todos, setTodos] = useState([\n    { id: 1, text: '学习 useState', done: false }\n  ]);\n\n  // 添加待办\n  const addTodo = () => {\n    const newTodo = { id: Date.now(), text: '新待办', done: false };\n    setTodos(prev => [...prev, newTodo]);\n  };\n\n  // 切换待办状态\n  const toggleTodo = (id) => {\n    setTodos(prev => prev.map(todo => \n      todo.id === id ? { ...todo, done: !todo.done } : todo\n    ));\n  };\n\n  // 删除待办\n  const deleteTodo = (id) => {\n    setTodos(prev => prev.filter(todo => todo.id !== id));\n  };\n\n  return (\n    <div>\n      <button onClick={addTodo}>添加待办</button>\n      <ul>\n        {todos.map(todo => (\n          <li key={todo.id} style={{ textDecoration: todo.done ? 'line-through' : 'none' }}>\n            {todo.text}\n            <button onClick={() => toggleTodo(todo.id)}>切换</button>\n            <button onClick={() => deleteTodo(todo.id)}>删除</button>\n          </li>\n        ))}\n      </ul>\n    </div>\n  );\n}\n```\n\n## 4.2 对象状态管理\n| 操作       | 实现方式（创建新对象）| 示例                                                                 |\n|------------|---------------------------------|----------------------------------------------------------------------|\n| 修改属性   | 扩展运算符（...）+ 新属性       | `setUser(prev => ({ ...prev, age: 21 }))`                            |\n| 添加属性   | 扩展运算符（...）+ 新属性       | `setUser(prev => ({ ...prev, address: '北京' }))`                    |\n| 删除属性   | 解构赋值 + rest 运算符          | `setUser(prev => { const { age, ...rest } = prev; return rest; })`   |\n\n### 示例：用户信息表单\n```jsx\nfunction UserForm() {\n  const [form, setForm] = useState({\n    username: '',\n    password: '',\n    remember: false\n  });\n\n  // 统一处理输入变化\n  const handleChange = (e) => {\n    const { name, value, type, checked } = e.target;\n    // 复选框取 checked，其他输入取 value\n    const inputValue = type === 'checkbox' ? checked : value;\n    // 合并更新对象（创建新对象）\n    setForm(prev => ({\n      ...prev,\n      [name]: inputValue\n    }));\n  };\n\n  return (\n    <form>\n      <div>\n        <label>用户名：</label>\n        <input name=\"username\" value={form.username} onChange={handleChange} />\n      </div>\n      <div>\n        <label>密码：</label>\n        <input type=\"password\" name=\"password\" value={form.password} onChange={handleChange} />\n      </div>\n      <div>\n        <label>\n          <input type=\"checkbox\" name=\"remember\" checked={form.remember} onChange={handleChange} />\n          记住我\n        </label>\n      </div>\n    </form>\n  );\n}\n```\n\n# 5. useState 与类组件 state 的对比\n| 特性                | useState（函数组件）| 类组件 state                          |\n|---------------------|---------------------------------------|---------------------------------------|\n| 状态定义            | 多次调用，多个独立状态                | 单一对象，所有状态合并管理            |\n| 状态更新            | 直接替换（非合并），需手动合并复杂类型 | 自动合并（仅更新指定属性，其他保留）  |\n| 初始值              | 支持初始化函数（仅首次执行）| 仅支持构造函数初始化                  |\n| 依赖更新            | 需传递更新函数确保最新状态            | 需传递函数式 setState 确保最新状态    |\n| 语法简洁性          | 简洁，无 this 绑定问题                | 繁琐，需处理 this 指向                |\n\n# 6. 核心总结\n1. **核心作用**：为函数组件提供局部状态管理能力，是函数组件实现交互的基础。\n2. **基本用法**：`const [state, setState] = useState(initialValue)`，初始值支持直接传递或通过初始化函数传递。\n3. **状态更新**：\n   - 非依赖更新：直接传递新值。\n   - 依赖更新：传递接收 `prevState` 的回调函数，确保获取最新状态。\n4. **复杂状态**：数组/对象更新需遵循不可变原则，通过扩展运算符、filter、map 等创建新数据，避免直接修改原状态。\n5. **性能优化**：初始化复杂状态时使用初始化函数，避免重复计算；依赖更新时使用回调函数，避免批量更新错误。...","directory_id":"8ef7f873-12e2-4aaf-933f-26eddf895f27","is_published":true,"created_at":"2025-12-19 15:10:44.07384+00","updated_at":"2025-12-22 01:56:38.311537+00"},{"id":"9cae0857-0fb3-477f-8269-d7141868102d","title":"useMemo：缓存计算结果","content":"`useMemo` 是 React 中用于**缓存复杂计算结果**的 Hook，核心作用是优化组件性能：避免组件每次渲染时重复执行昂贵的计算（如大数据排序、复杂数学运算、深层对象克隆）。在 React 中，函数组件每次渲染时，内部的所有代码都会重新执行，若包含昂贵计算，会严重影响渲染性能，`useMemo` 通过缓存计算结果，仅在依赖项变化时重新计算，解决这一问题。\n\n# 1. useMemo 核心原理与问题背景\n## 1.1 问题背景：重复昂贵计算导致的性能问题\n函数组件每次渲染时，内部的计算逻辑会重新执行，若计算逻辑复杂（如处理大量数据），会显著增加渲染时间：\n```jsx\nimport { useState } from 'react';\n\n// 昂贵计算：对大数据数组排序\nfunction expensiveCalculation(list) {\n  console.log('执行昂贵计算');\n  return list.sort((a, b) => b - a); // 排序操作（大数据下性能差）\n}\n\nfunction DataProcessor() {\n  const [count, setCount] = useState(0);\n  const [data] = useState([1, 3, 2, 5, 4, 7, 6, 9, 8, 10]); // 模拟大数据\n\n  // 每次组件渲染，都会执行 expensiveCalculation（即使 data 未变化）\n  const sortedData = expensiveCalculation([...data]);\n\n  return (\n    <div>\n      <p>count：{count}</p>\n      <button onClick={() => setCount(prev => prev + 1)}>+1</button>\n      <ul>\n        {sortedData.map((item, index) => (\n          <li key={index}>{item}</li>\n        ))}\n      </ul>\n    </div>\n  );\n}\n```\n上述代码中，点击“+1”按钮会触发组件重渲染，尽管 `data` 状态未变化，但 `expensiveCalculation` 仍会重新执行（控制台打印“执行昂贵计算”），造成不必要的性能开销（大数据场景下更明显）。\n\n## 1.2 useMemo 核心原理\n`useMemo` 接收两个参数：\n- 第一个参数：**计算函数**，返回需要缓存的结果（如昂贵计算的结果）。\n- 第二个参数：**依赖项数组**（与 `useEffect`/`useCallback` 一致）。\n\n返回值：缓存的计算结果（仅当依赖项变化时，才会重新执行计算函数；依赖项不变时，直接返回缓存的结果）。\n\n## 1.3 基本语法\n```jsx\nimport { useMemo } from 'react';\n\nconst cachedValue = useMemo(() => {\n  // 昂贵计算逻辑\n  return expensiveCalculation(dep1, dep2);\n}, [dep1, dep2]); // 依赖项数组：仅当 dep1/dep2 变化时，重新计算\n```\n\n# 2. useMemo 基础用法：优化昂贵计算\n## 2.1 优化上述示例\n使用 `useMemo` 缓存排序结果，仅当 `data` 变化时重新排序：\n```jsx\nimport { useState, useMemo } from 'react';\n\nfunction expensiveCalculation(list) {\n  console.log('执行昂贵计算');\n  return list.sort((a, b) => b - a);\n}\n\nfunction DataProcessor() {\n  const [count, setCount] = useState(0);\n  const [data] = useState([1, 3, 2, 5, 4, 7, 6, 9, 8, 10]);\n\n  // 使用 useMemo 缓存计算结果，依赖项为 data\n  const sortedData = useMemo(() => {\n    return expensiveCalculation([...data]);\n  }, [data]); // 仅 data 变化时，重新执行昂贵计算\n\n  return (\n    <div>\n      <p>count：{count}</p>\n      <button onClick={() => setCount(prev => prev + 1)}>+1</button>\n      <ul>\n        {sortedData.map((item, index) => (\n          <li key={index}>{item}</li>\n        ))}\n      </ul>\n    </div>\n  );\n}\n```\n优化后，点击“+1”按钮时，组件重渲染但 `data` 未变化，`sortedData` 直接使用缓存结果，`expensiveCalculation` 不再执行（控制台仅首次渲染时打印“执行昂贵计算”），性能显著提升。\n\n## 2.2 带多依赖项的 useMemo\n若计算结果依赖多个变量，需将所有依赖项加入数组，确保计算结果的正确性：\n```jsx\nfunction PriceCalculator({ basePrice, discount, taxRate }) {\n  // 计算最终价格：(basePrice - discount) * (1 + taxRate)\n  const finalPrice = useMemo(() => {\n    console.log('计算最终价格');\n    return (basePrice - discount) * (1 + taxRate);\n  }, [basePrice, discount, taxRate]); // 依赖所有相关变量\n\n  return <p>最终价格：{finalPrice.toFixed(2)}</p>;\n}\n```\n此时，仅当 `basePrice`/`discount`/`taxRate` 中任意一个变化时，才会重新计算最终价格。\n\n# 3. useMemo 的其他适用场景\n## 场景1：避免传递给子组件的复杂 props 引用变化\n若父组件传递给子组件的 props 是复杂对象/数组（通过计算生成），每次渲染时会创建新的引用，即使内容未变化，也会导致子组件（使用 `React.memo`）重渲染。使用 `useMemo` 缓存该对象/数组，可避免此问题：\n```jsx\nimport { useState, memo, useMemo } from 'react';\n\n// 子组件：使用 memo 优化\nconst UserList = memo(({ users }) => {\n  console.log('UserList 重渲染');\n  return (\n    <ul>\n      {users.map(user => (\n        <li key={user.id}>{user.name}</li>\n      ))}\n    </ul>\n  );\n});\n\nfunction Parent() {\n  const [count, setCount] = useState(0);\n  const [rawUsers] = useState([\n    { id: 1, name: '张三', age: 20 },\n    { id: 2, name: '李四', age: 25 },\n    { id: 3, name: '王五', age: 30 }\n  ]);\n\n  // 过滤用户：仅显示年龄 ≥25 的用户\n  // 使用 useMemo 缓存过滤结果，避免每次渲染创建新数组\n  const filteredUsers = useMemo(() => {\n    return rawUsers.filter(user => user.age >= 25);\n  }, [rawUsers]); // 依赖 rawUsers\n\n  return (\n    <div>\n      <p>count：{count}</p>\n      <button onClick={() => setCount(prev => prev + 1)}>+1</button>\n      {/* 传递缓存的数组，UserList 不会因 count 变化而重渲染 */}\n      <UserList users={filteredUsers} />\n    </div>\n  );\n}\n```\n\n## 场景2：缓存组件的派生状态\n派生状态指由基础状态计算得到的状态（如从 `todos` 中计算未完成的数量），使用 `useMemo` 缓存派生状态，避免重复计算：\n```jsx\nfunction TodoStats() {\n  const [todos, setTodos] = useState([\n    { id: 1, text: '学习 React', done: false },\n    { id: 2, text: '学习 useMemo', done: true },\n    { id: 3, text: '写代码', done: false }\n  ]);\n\n  // 缓存派生状态：未完成的待办数量\n  const unfinishedCount = useMemo(() => {\n    console.log('计算未完成数量');\n    return todos.filter(todo => !todo.done).length;\n  }, [todos]); // 依赖 todos\n\n  return <p>未完成待办：{unfinishedCount}</p>;\n}\n```\n\n## 场景3：缓存 React 元素（减少组件重建）\n在某些场景下，可使用 `useMemo` 缓存 React 元素，避免每次渲染重建组件树（适用于静态元素或低频变化元素）：\n```jsx\nfunction StaticComponent() {\n  console.log('StaticComponent 渲染');\n  return <div>静态内容（无需频繁重建）</div>;\n}\n\nfunction Parent() {\n  const [count, setCount] = useState(0);\n\n  // 缓存静态组件，避免每次渲染重建\n  const cachedStaticComponent = useMemo(() => <StaticComponent />, []);\n\n  return (\n    <div>\n      <p>count：{count}</p>\n      <button onClick={() => setCount(prev => prev + 1)}>+1</button>\n      {cachedStaticComponent}\n    </div>\n  );\n}\n```\n\n# 4. useMemo 的使用误区\n## 误区1：滥用 useMemo（缓存简单计算）\n`useMemo` 本身有性能开销（需要维护缓存、对比依赖项），若计算逻辑简单（如加法、字符串拼接），使用 `useMemo` 反而会增加性能负担：\n```jsx\n// 错误示例：不必要的 useMemo\nfunction SimpleCalculation() {\n  const [a, setA] = useState(1);\n  const [b, setB] = useState(2);\n\n  // 简单加法，无需缓存\n  const sum = useMemo(() => a + b, [a, b]);\n\n  return <p>和：{sum}</p>;\n}\n```\n\n## 误区2：依赖项缺失或错误\n若计算函数使用了某个变量，但未加入依赖项数组，会导致缓存结果过期（使用旧值）：\n```jsx\n// 错误示例：依赖项缺失\nfunction MissingDeps() {\n  const [a, setA] = useState(1);\n  const [b, setB] = useState(2);\n\n  // 计算 a + b，但依赖项仅包含 a（缺失 b）\n  const sum = useMemo(() => a + b, [a]);\n\n  return (\n    <div>\n      <button onClick={() => setB(prev => prev + 1)}>b+1</button>\n      <p>和：{sum}</p> {/* b 变化后，sum 仍使用旧值 */}\n    </div>\n  );\n}\n```\n\n## 误区3：缓存不稳定的对象/数组\n若计算函数返回的是“不稳定”的对象/数组（如每次创建新对象），即使使用 `useMemo`，也可能导致子组件重渲染：\n```jsx\n// 错误示例：返回新对象，缓存无效\nfunction UnstableObject() {\n  const [count, setCount] = useState(0);\n\n  const user = useMemo(() => {\n    // 每次执行都会创建新对象（引用不同）\n    return { name: '张三', age: 20 };\n  }, []);\n\n  return <Child user={user} />; // 即使 useMemo，user 引用不变（此示例中是稳定的，仅说明风险）\n}\n```\n> 注意：上述示例中 `user` 是稳定的（依赖项为空），但如果计算函数内部使用变量生成对象，需确保对象引用稳定。\n\n## 误区4：将 useMemo 用于副作用\n`useMemo` 的第一个参数是**计算函数**，必须是纯函数（无副作用，如数据请求、DOM 操作），副作用应使用 `useEffect`：\n```jsx\n// 错误示例：useMemo 中执行副作用\nfunction SideEffectInUseMemo() {\n  useMemo(() => {\n    // 副作用：数据请求（错误用法）\n    fetch('/api/data').then(res => res.json());\n  }, []);\n\n  return <div>错误示例</div>;\n}\n```\n\n# 5. useMemo 与 useCallback 的区别与联系\n## 5.1 区别\n| 特性         | useMemo                          | useCallback                      |\n|--------------|---------------------------------|---------------------------------|\n| 缓存内容     | 函数执行的**结果**（值、对象、数组、元素） | 函数**引用**（未执行的函数）|\n| 执行时机     | 组件渲染时执行计算函数，返回结果 | 组件渲染时返回函数引用，函数需手动调用 |\n| 适用场景     | 缓存昂贵计算结果、稳定 props 引用 | 缓存回调函数、避免子组件重渲染 |\n| 语法         | `useMemo(() => compute(), deps)` | `useCallback(() => {}, deps)`   |\n\n## 5.2 联系\n- 均用于性能优化，依赖项数组机制完全一致。\n- 均在组件渲染时同步执行（阻塞渲染，因此不能缓存过于昂贵的计算，否则会延长渲染时间）。\n- `useCallback(fn, deps)` 等价于 `useMemo(() => fn, deps)`（缓存函数引用）。\n\n## 5.3 选择原则\n- 需要缓存“计算结果”→ 使用 `useMemo`。\n- 需要缓存“函数本身”→ 使用 `useCallback`。\n\n# 6. useMemo 最佳实践\n## 6.1 仅缓存昂贵计算\n遵循“成本收益”原则：\n- 计算时间 > 1ms（如大数据排序、深层对象处理）→ 使用 `useMemo`。\n- 简单计算（如四则运算、简单过滤）→ 无需使用。\n\n## 6.2 正确设置依赖项\n- 计算函数中使用的所有变量（state、props、局部变量）必须加入依赖项数组。\n- 使用 ESLint 规则 `react-hooks/exhaustive-deps` 检查依赖项完整性。\n- 依赖项数组为空 → 计算结果永久缓存（仅首次渲染执行）。\n\n## 6.3 避免缓存包含函数的对象\n若缓存的对象包含函数，需确保函数引用稳定（使用 `useCallback` 缓存函数）：\n```jsx\nfunction UserActions() {\n  const [user, setUser] = useState({ name: '张三' });\n\n  // 缓存包含函数的对象，函数需用 useCallback 缓存\n  const userActions = useMemo(() => ({\n    updateName: useCallback((newName) => {\n      setUser(prev => ({ ...prev, name: newName }));\n    }, [])\n  }), []);\n\n  return <Child actions={userActions} />;\n}\n```\n\n## 6.4 结合 React.memo 使用\n当缓存的结果作为 props 传递给子组件时，子组件必须使用 `React.memo` 优化，否则 `useMemo` 无法发挥作用。\n\n# 7. 核心总结\n1. **核心作用**：缓存昂贵计算的结果，避免组件每次渲染时重复执行复杂计算，优化渲染性能。\n2. **使用条件**：\n   - 计算逻辑昂贵（大数据处理、复杂运算）。\n   - 计算结果作为 props 传递给 `memo` 包装的子组件（需稳定引用）。\n   - 计算结果为派生状态（需避免重复计算）。\n3. **关键语法**：`useMemo(() => computeResult(), [deps])`，依赖项必须完整。\n4. **使用误区**：\n   - 滥用 `useMemo` 缓存简单计算。\n   - 依赖项缺失导致缓存结果过期。\n   - 在 `useMemo` 中执行副作用。\n5. **性能权衡**：\n   - `useMemo` 同步执行，过于昂贵的计算会阻塞渲染，建议将超大型计算放在 `useEffect` 中异步执行。\n   - 缓存的结果会占用内存，需避免缓存过大的数据（如百万级数组）。...","directory_id":"aac29662-babe-4c96-8f61-0a16830155d4","is_published":true,"created_at":"2025-12-19 15:19:02.89974+00","updated_at":"2025-12-22 02:38:56.145294+00"},{"id":"9cda2038-f2bf-414c-8a29-d825dad5c556","title":"异步错误处理（useErrorBoundary）","content":"React 内置的错误边界仅支持类组件，且无法直接捕获异步错误（如 `fetch` 请求、`setTimeout` 回调中的错误）。`react-error-boundary` 是社区主流的错误处理库，提供了函数组件友好的 API（如 `useErrorBoundary` Hook），支持捕获异步错误、自定义降级 UI 等功能，解决了原生错误边界的局限性。\n\n# 1. 安装 react-error-boundary\n```bash\nnpm install react-error-boundary\n\nyarn add react-error-boundary\n```\n\n# 2. 核心 API 介绍\n## 2.1 ErrorBoundary 组件（函数组件版）\n替代原生类组件错误边界，支持通过 `fallback` 属性自定义降级 UI，通过 `onError` 回调记录错误。\n\n## 2.2 useErrorBoundary Hook\n用于在函数组件内部手动触发错误边界，捕获异步错误或事件处理错误。\n\n## 2.3 FallbackComponent 组件\n可复用的降级 UI 组件，接收 `error`、`resetErrorBoundary` 等 props，实现错误展示和恢复逻辑。\n\n# 3. 基础使用：捕获渲染错误\n```javascript\nimport { ErrorBoundary } from 'react-error-boundary';\n\n// 自定义降级 UI 组件\nfunction ErrorFallback({ error, resetErrorBoundary }) {\n  return (\n    <div role=\"alert\">\n      <h2>出错了！</h2>\n      <p>{error.message}</p>\n      <button onClick={resetErrorBoundary}>重试</button>\n    </div>\n  );\n}\n\n// 可能抛出渲染错误的组件\nfunction BuggyComponent() {\n  // 模拟渲染错误\n  throw new Error('组件渲染失败！');\n  return <div>正常内容</div>;\n}\n\nfunction App() {\n  return (\n    <ErrorBoundary\n      FallbackComponent={ErrorFallback}\n      onError={(error, info) => {\n        // 错误上报逻辑\n        console.error('捕获到错误：', error, info);\n      }}\n    >\n      <BuggyComponent />\n    </ErrorBoundary>\n  );\n}\n```\n\n# 4. 捕获异步错误（useErrorBoundary Hook）\n原生错误边界无法捕获异步错误，`useErrorBoundary` 提供了 `showBoundary` 方法，可手动将异步错误传递给错误边界。\n\n## 4.1 示例：捕获数据请求错误\n```javascript\nimport { useErrorBoundary } from 'react-error-boundary';\nimport { useState, useEffect } from 'react';\n\nfunction DataFetchingComponent() {\n  const [data, setData] = useState(null);\n  // 获取手动触发错误边界的方法\n  const { showBoundary } = useErrorBoundary();\n\n  useEffect(() => {\n    // 异步请求数据\n    const fetchData = async () => {\n      try {\n        const res = await fetch('/api/invalid-endpoint'); // 无效接口，模拟错误\n        if (!res.ok) {\n          throw new Error(`请求失败：${res.status}`);\n        }\n        const data = await res.json();\n        setData(data);\n      } catch (error) {\n        // 手动触发错误边界，显示降级 UI\n        showBoundary(error);\n      }\n    };\n\n    fetchData();\n  }, [showBoundary]);\n\n  if (!data) {\n    return <div>加载中...</div>;\n  }\n\n  return <div>数据：{JSON.stringify(data)}</div>;\n}\n\n// 包裹错误边界\nfunction App() {\n  return (\n    <ErrorBoundary FallbackComponent={ErrorFallback}>\n      <DataFetchingComponent />\n    </ErrorBoundary>\n  );\n}\n```\n\n## 4.2 示例：捕获事件处理错误\n```javascript\nimport { useErrorBoundary } from 'react-error-boundary';\n\nfunction ButtonComponent() {\n  const { showBoundary } = useErrorBoundary();\n\n  const handleClick = () => {\n    try {\n      // 模拟事件处理错误\n      riskyFunction();\n    } catch (error) {\n      // 手动触发错误边界\n      showBoundary(error);\n    }\n  };\n\n  return <button onClick={handleClick}>点击触发可能的错误</button>;\n}\n```\n\n# 5. 高级用法\n## 5.1 重置错误状态\n`ErrorBoundary` 组件会传递 `resetErrorBoundary` 方法给 `FallbackComponent`，用于重置错误状态，重新渲染子组件：\n```javascript\nfunction ErrorFallback({ error, resetErrorBoundary }) {\n  return (\n    <div>\n      <p>{error.message}</p>\n      <button onClick={resetErrorBoundary}>重新加载</button>\n    </div>\n  );\n}\n```\n\n## 5.2 错误边界重试时传递参数\n若需在重置错误时传递参数（如重新请求的 ID），可通过 `resetKeys` 属性实现：\n```javascript\nfunction App() {\n  const [postId, setPostId] = useState(1);\n\n  return (\n    <ErrorBoundary\n      FallbackComponent={ErrorFallback}\n      resetKeys={[postId]} // 当 postId 变化时，自动重置错误边界\n    >\n      <PostComponent postId={postId} />\n      <button onClick={() => setPostId(postId + 1)}>加载下一篇</button>\n    </ErrorBoundary>\n  );\n}\n```\n\n## 5.3 全局错误监听\n结合 `react-error-boundary` 和全局错误监听，实现全量错误捕获：\n```javascript\nimport { ErrorBoundary } from 'react-error-boundary';\n\n// 全局监听未捕获的错误\nwindow.addEventListener('error', (event) => {\n  console.error('全局捕获的同步错误：', event.error);\n});\n\n// 全局监听未处理的 Promise 错误\nwindow.addEventListener('unhandledrejection', (event) => {\n  console.error('全局捕获的异步错误：', event.reason);\n});\n\nfunction App() {\n  return (\n    <ErrorBoundary\n      FallbackComponent={GlobalErrorFallback}\n      onError={(error, info) => {\n        // 上报到错误监控平台\n        logErrorToService(error, info);\n      }}\n    >\n      <MainApp />\n    </ErrorBoundary>\n  );\n}\n```\n\n# 6. 最佳实践\n1. **区分错误类型**：\n   - 渲染错误：直接用 `ErrorBoundary` 包裹；\n   - 异步/事件错误：用 `useErrorBoundary` 手动触发；\n2. **分级错误处理**：\n   - 页面级错误边界：处理单个页面的错误；\n   - 组件级错误边界：处理关键组件（如表单、列表）的错误；\n   - 全局错误边界：兜底捕获未处理的错误；\n3. **友好的降级体验**：\n   - 提供清晰的错误提示（避免技术术语）；\n   - 提供恢复操作（重试、刷新、返回首页）；\n   - 生产环境隐藏错误栈，开发环境显示详细信息；\n4. **错误日志标准化**：\n   - 统一错误上报格式（包含错误信息、组件栈、用户信息、时间戳）；\n   - 区分前端错误和后端错误（如 API 404/500）；\n\n# 7. 原生错误边界 vs react-error-boundary\n| 特性 | 原生错误边界 | react-error-boundary |\n|------|--------------|----------------------|\n| 组件类型 | 仅支持类组件 | 支持函数组件/类组件 |\n| 异步错误捕获 | 不支持 | 支持（通过 useErrorBoundary） |\n| 事件处理错误捕获 | 不支持 | 支持（通过 useErrorBoundary） |\n| 自定义降级 UI | 需手动实现 | 内置 FallbackComponent 支持 |\n| 错误重置 | 需手动实现 | 内置 resetErrorBoundary 方法 |\n| 错误上报 | 需手动实现 | 内置 onError 回调 |\n| 易用性 | 低（类组件、API 繁琐） | 高（Hook 化、API 简洁） |\n","directory_id":"a02f0182-c167-4bad-9395-1aa29e0a493f","is_published":true,"created_at":"2025-12-22 03:17:28.840032+00","updated_at":"2025-12-23 09:54:27.06283+00"},{"id":"9f5a67e8-a673-4edc-8867-9b60d6ceb531","title":"组件的生命周期","content":"组件的生命周期指组件从**创建**、**更新**到**销毁**的整个过程，React 为不同阶段提供了对应的钩子函数，让开发者可以在特定时机执行逻辑。类组件拥有明确的生命周期划分，而函数组件通过 **Hooks** 实现类似的生命周期能力。\n\n# 1. 类组件的生命周期\n类组件的生命周期分为 **3 个阶段**：**挂载阶段**、**更新阶段**、**卸载阶段**，React 16.3 之后对部分生命周期钩子进行了调整（废弃了 `componentWillMount`、`componentWillReceiveProps` 等）。\n\n## 1.1 挂载阶段（组件首次渲染到 DOM）\n组件第一次被创建并插入 DOM 树的阶段，该阶段只执行一次。\n- **constructor()**：组件构造函数，初始化 `this.state` 和绑定事件处理函数。\n  ```jsx\n  constructor(props) {\n    super(props);\n    this.state = { count: 0 };\n    this.handleClick = this.handleClick.bind(this);\n  }\n  ```\n- **static getDerivedStateFromProps(props, state)**：静态方法，根据 props 更新 state，返回新的 state 对象（避免直接修改 state）。\n- **render()**：必须实现的方法，返回组件的 JSX 结构，**纯函数（无副作用）**，不允许调用 setState。\n- **componentDidMount()**：组件挂载完成后执行，可执行 DOM 操作、数据请求、订阅事件等副作用逻辑。\n  ```jsx\n  componentDidMount() {\n    // 数据请求\n    fetch('/api/data').then(res => res.json()).then(data => this.setState({ data }));\n    // 订阅事件\n    this.timer = setInterval(() => this.setState({ count: this.state.count + 1 }), 1000);\n  }\n  ```\n\n## 1.2 更新阶段（组件状态或 props 变化）\n当组件的 `props` 或 `state` 发生变化时触发，会重复执行多次。\n- **static getDerivedStateFromProps(props, state)**：挂载阶段也会执行，更新阶段同样会根据 props 更新 state。\n- **shouldComponentUpdate(nextProps, nextState)**：返回布尔值，决定组件是否需要重新渲染。返回 `false` 则跳过后续的 render 和更新钩子，常用于性能优化。\n- **render()**：重新渲染组件 JSX 结构。\n- **getSnapshotBeforeUpdate(prevProps, prevState)**：在 DOM 更新之前执行，返回一个快照值，传递给 `componentDidUpdate`。\n- **componentDidUpdate(prevProps, prevState, snapshot)**：组件更新完成后执行，可根据前后 props/state 的变化执行 DOM 操作或数据请求（注意：需要加条件判断，避免无限循环）。\n  ```jsx\n  componentDidUpdate(prevProps) {\n    // 当 props.id 变化时重新请求数据\n    if (this.props.id !== prevProps.id) {\n      fetch(`/api/data/${this.props.id}`).then(res => res.json()).then(data => this.setState({ data }));\n    }\n  }\n  ```\n\n## 1.3 卸载阶段（组件从 DOM 移除）\n组件被销毁并从 DOM 树中移除的阶段，该阶段只执行一次。\n- **componentWillUnmount()**：组件卸载前执行，用于清理副作用，如清除定时器、取消订阅、取消网络请求等。\n  ```jsx\n  componentWillUnmount() {\n    clearInterval(this.timer); // 清除定时器\n  }\n  ```\n\n## 1.4 类组件生命周期流程图\n```\n挂载阶段：constructor → getDerivedStateFromProps → render → componentDidMount\n\n更新阶段：getDerivedStateFromProps → shouldComponentUpdate → render → getSnapshotBeforeUpdate → componentDidUpdate\n\n卸载阶段：componentWillUnmount\n```\n\n# 2. 函数组件的副作用（Hooks 实现生命周期）\n函数组件没有类组件的生命周期钩子，而是通过 **useEffect Hook** 统一处理**副作用**（即所有不在渲染过程中执行的逻辑，如数据请求、DOM 操作、订阅、定时器等）。`useEffect` 可以模拟类组件的多个生命周期钩子。\n\n## 2.1 useEffect 基本用法\n```jsx\nimport { useEffect } from 'react';\n\nfunction MyComponent() {\n  useEffect(() => {\n    // 副作用逻辑：如数据请求、DOM 操作\n    console.log('组件挂载/更新');\n\n    // 清理函数：组件卸载或依赖变化时执行\n    return () => {\n      console.log('组件卸载/依赖变化');\n    };\n  }, [依赖数组]); // 依赖数组：控制 useEffect 的执行时机\n}\n```\n\n## 2.2 useEffect 模拟类组件生命周期\n| 类组件生命周期钩子 | 函数组件 useEffect 实现方式 | 适用场景 |\n|--------------------|-----------------------------|----------|\n| componentDidMount | useEffect(() => { ... }, []) | 组件挂载后执行一次，如初始化数据请求、订阅事件 |\n| componentDidUpdate | useEffect(() => { ... }, [dep1, dep2]) | 依赖项（dep1/dep2）变化时执行，如 props 变化后重新请求数据 |\n| componentWillUnmount | useEffect(() => { return () => { ... } }, []) | 清理副作用，如清除定时器、取消订阅 |\n\n## 2.3 示例：useEffect 模拟生命周期\n```jsx\nimport { useState, useEffect } from 'react';\n\nfunction Timer() {\n  const [count, setCount] = useState(0);\n\n  // 模拟 componentDidMount + componentWillUnmount\n  useEffect(() => {\n    const timer = setInterval(() => {\n      setCount(prevCount => prevCount + 1);\n    }, 1000);\n    // 清理函数：模拟 componentWillUnmount\n    return () => clearInterval(timer);\n  }, []); // 空依赖数组：只执行一次\n\n  // 模拟 componentDidUpdate\n  useEffect(() => {\n    console.log(`count 更新为：${count}`);\n  }, [count]); // count 变化时执行\n\n  return <h1>Count: {count}</h1>;\n}\n```\n\n# 3. 核心区别总结\n- 类组件：生命周期划分清晰，钩子函数各司其职，但易出现逻辑分散、嵌套复杂的问题。\n- 函数组件：通过 useEffect 统一管理副作用，逻辑更聚合，可通过依赖数组精准控制执行时机，配合自定义 Hooks 可实现逻辑复用。","directory_id":"16d6f496-f7f3-422b-baf9-c5f027a71aaa","is_published":true,"created_at":"2025-12-19 10:04:12.060982+00","updated_at":"2025-12-19 10:04:12.060982+00"},{"id":"a2fcff48-e668-46d6-ac56-2f8e30cf1d48","title":"Hooks 常见陷阱","content":"React Hooks 虽简化了状态管理和副作用处理，但因对执行机制、依赖规则的理解不足，容易陷入各类陷阱。以下是最常见的三类陷阱及解决方案：\n\n# 1. 闭包问题\n## 1.1 陷阱表现\nHooks 依赖 JavaScript 闭包特性，若在异步操作（定时器、网络请求）中访问组件状态/属性，可能捕获到旧的闭包值，导致获取的状态不是最新的。\n\n## 1.2 示例：定时器中获取旧状态\n```jsx\nfunction Counter() {\n  const [count, setCount] = useState(0);\n\n  useEffect(() => {\n    const timer = setInterval(() => {\n      // 每次执行都打印初始值 0，而非最新count\n      console.log('当前count：', count);\n    }, 1000);\n    return () => clearInterval(timer);\n  }, []); // 依赖项为空，闭包捕获初始count=0\n\n  return <button onClick={() => setCount(prev => prev + 1)}>count: {count}</button>;\n}\n```\n\n## 1.3 根本原因\n`useEffect` 依赖项为空时，仅在组件挂载时执行一次，内部定时器的闭包捕获了挂载时的 `count`（值为 0），后续 `count` 更新不会触发 `useEffect` 重新执行，定时器始终访问旧值。\n\n## 1.4 解决方案\n1. **添加依赖项**：将使用的状态加入 `useEffect` 依赖数组，依赖变化时重新创建闭包。\n   ```jsx\n   useEffect(() => {\n     const timer = setInterval(() => {\n       console.log('当前count：', count);\n     }, 1000);\n     return () => clearInterval(timer);\n   }, [count]); // 依赖count，更新时重新执行\n   ```\n\n2. **使用 useRef 保存最新值**：通过 `ref` 同步最新状态（`ref.current` 不受闭包影响）。\n   ```jsx\n   function Counter() {\n     const [count, setCount] = useState(0);\n     const countRef = useRef(count);\n     // 同步最新count到ref\n     useEffect(() => {\n       countRef.current = count;\n     }, [count]);\n\n     useEffect(() => {\n       const timer = setInterval(() => {\n         // 访问ref.current获取最新值\n         console.log('当前count：', countRef.current);\n       }, 1000);\n       return () => clearInterval(timer);\n     }, []);\n\n     return <button onClick={() => setCount(prev => prev + 1)}>count: {count}</button>;\n   }\n   ```\n\n3. **函数式更新**：更新状态时使用函数式写法，直接获取最新状态（适用于更新逻辑）。\n   ```jsx\n   setCount(prev => {\n     console.log('最新count：', prev); // 始终获取最新值\n     return prev + 1;\n   });\n   ```\n\n# 2. 依赖项缺失\n## 2.1 陷阱表现\n使用 `useEffect`、`useCallback`、`useMemo` 时，未将内部使用的所有状态/属性/函数加入依赖数组，导致 Hooks 执行逻辑与预期不符（如副作用不触发、获取旧值）。\n\n## 2.2 示例：依赖项缺失导致副作用不更新\n```jsx\nfunction UserProfile({ userId }) {\n  const [user, setUser] = useState(null);\n\n  const fetchUser = async () => {\n    const res = await fetch(`https://api.example.com/user/${userId}`);\n    const data = await res.json();\n    setUser(data);\n  };\n\n  useEffect(() => {\n    fetchUser();\n    // 依赖项仅加了fetchUser，未加userId → userId变化时，fetchUser闭包捕获旧userId\n  }, [fetchUser]);\n\n  return <div>{user?.name || '加载中...'}</div>;\n}\n```\n\n## 2.3 根本原因\n`fetchUser` 内部依赖 `userId`，但 `useEffect` 仅依赖 `fetchUser`；每次 `userId` 变化时，组件重新渲染会创建新的 `fetchUser` 函数，触发 `useEffect` 执行，但 `fetchUser` 内部的 `userId` 是旧值（闭包捕获），导致请求的还是旧用户数据。\n\n## 2.4 解决方案\n1. **完整声明依赖项**：将 Hooks 内部使用的所有变量、函数加入依赖数组（可通过 ESLint 规则 `react-hooks/exhaustive-deps` 自动检查）。\n   ```jsx\n   useEffect(() => {\n     fetchUser();\n   }, [fetchUser, userId]); // 补充userId依赖\n   ```\n\n2. **优化函数依赖**：使用 `useCallback` 缓存函数，减少不必要的重执行，同时明确函数依赖。\n   ```jsx\n   const fetchUser = useCallback(async () => {\n     const res = await fetch(`https://api.example.com/user/${userId}`);\n     const data = await res.json();\n     setUser(data);\n   }, [userId]); // 函数依赖userId，变化时重新创建\n\n   useEffect(() => {\n     fetchUser();\n   }, [fetchUser]); // 仅依赖缓存后的fetchUser\n   ```\n\n3. **内联函数到 Hooks 中**：将函数直接写在 `useEffect` 内部，避免外部函数的依赖问题（适用于简单逻辑）。\n   ```jsx\n   useEffect(() => {\n     const fetchUser = async () => {\n       const res = await fetch(`https://api.example.com/user/${userId}`);\n       const data = await res.json();\n       setUser(data);\n     };\n     fetchUser();\n   }, [userId]); // 仅依赖userId\n   ```\n\n# 3. 无限循环\n## 3.1 陷阱表现\n组件渲染后触发副作用，副作用中更新状态，状态更新又触发副作用，形成无限循环（组件反复渲染，导致性能崩溃）。\n\n## 3.2 示例1：useEffect 中更新未加入依赖的状态\n```jsx\nfunction ListComponent() {\n  const [list, setList] = useState([]);\n\n  useEffect(() => {\n    // 模拟请求数据\n    const newList = [1, 2, 3];\n    setList(newList); // 更新list，触发组件重渲染\n    // 依赖项为空 → 仅挂载时执行一次？不！list是新数组（引用变化），但useEffect依赖为空，不会重复执行？\n    // 错误示例：若依赖项包含list，则会无限循环\n  }, [list]); // ❌ 依赖list，setList更新list → 触发useEffect → 再次setList → 无限循环\n}\n```\n\n## 3.3 示例2：useState 直接更新对象/数组（引用变化）\n```jsx\nfunction FormComponent() {\n  const [form, setForm] = useState({ name: '', age: 0 });\n\n  useEffect(() => {\n    // 模拟验证表单\n    console.log('表单变化：', form);\n  }, [form]); // 依赖form对象\n\n  const handleChange = () => {\n    // ❌ 每次创建新对象，form引用变化 → 触发useEffect → 若内部有更新逻辑则可能循环\n    setForm({ ...form, name: '张三' });\n  };\n\n  return <button onClick={handleChange}>修改表单</button>;\n}\n```\n\n## 3.4 根本原因\n1. 副作用依赖项中包含被更新的状态，状态更新后依赖项变化，触发副作用再次执行，形成闭环；\n2. 对象/数组的引用变化（即使内容相同），被 Hooks 判定为依赖变化，触发重复执行。\n\n## 3.5 解决方案\n1. **移除不必要的依赖项**：若副作用仅需执行一次（如初始化请求），依赖项设为空数组，避免依赖状态。\n   ```jsx\n   useEffect(() => {\n     const newList = [1, 2, 3];\n     setList(newList);\n   }, []); // ✅ 仅挂载时执行，无循环\n   ```\n\n2. **使用函数式更新**：更新状态时依赖旧状态，避免直接依赖新状态。\n   ```jsx\n   setForm(prev => ({ ...prev, name: '张三' })); // 不依赖外部form，仅依赖prev\n   ```\n\n3. **缓存对象/数组（useMemo/useCallback）**：对复杂类型依赖项进行缓存，避免不必要的引用变化。\n   ```jsx\n   const form = useMemo(() => ({ name: '', age: 0 }), []); // 缓存表单初始值\n   ```\n\n4. **依赖项精准化**：仅依赖必要的属性，而非整个对象/数组。\n   ```jsx\n   useEffect(() => {\n     console.log('姓名变化：', form.name);\n   }, [form.name]); // ✅ 仅依赖name，而非整个form对象\n   ```\n\n5. **避免在副作用中无条件更新状态**：仅在满足特定条件时更新状态（如数据未加载时）。\n   ```jsx\n   useEffect(() => {\n     if (list.length === 0) { // 仅初始为空时更新\n       const newList = [1, 2, 3];\n       setList(newList);\n     }\n   }, [list]);\n   ```\n\n# 4. 陷阱规避总结\n1. **启用 ESLint 规则**：开启 `react-hooks/rules-of-hooks` 和 `react-hooks/exhaustive-deps`，强制遵守 Hooks 规则，检测缺失的依赖项；\n2. **理解闭包特性**：明确异步操作中闭包对状态的捕获机制，使用 `ref` 或函数式更新获取最新值；\n3. **依赖项最小化**：仅将必要的变量/函数加入依赖数组，避免依赖复杂对象/数组；\n4. **调试工具辅助**：使用 React DevTools 查看 Hooks 依赖变化，定位无限循环或闭包问题。","directory_id":"9e07a04e-b6bb-488a-9725-08821605cfbc","is_published":true,"created_at":"2025-12-22 02:22:56.181921+00","updated_at":"2025-12-23 02:05:10.02051+00"},{"id":"aa7252fc-8035-472f-b5a6-e9d639c15a33","title":"协调（Reconciliation）与 Fiber 架构","content":"# 1. 什么是协调（Reconciliation）\n协调是 React 将**虚拟 DOM 差异转换为真实 DOM 更新**的全过程，包含两个核心步骤：\n1. **Diff 算法**：对比新旧虚拟 DOM 树，找出差异（“找不同”）；\n2. **Commit 阶段**：将差异批量应用到真实 DOM 中（“打补丁”）。\n\n在 React 16 之前，协调过程是**同步且不可中断**的：一旦开始协调，必须执行到底，若组件树庞大，会阻塞浏览器主线程（导致页面卡顿、交互无响应）。\n\n## 1.1 同步协调的问题\n- 浏览器主线程（JS 执行、DOM 渲染、事件处理）是单线程的；\n- 若协调过程耗时超过 16ms（浏览器刷新率 60fps，每帧约 16ms），会导致帧丢失，页面出现卡顿；\n- 例如：渲染 1000 个列表项的组件，协调过程耗时 100ms，期间用户点击按钮无响应，体验极差。\n\n# 2. Fiber 架构：React 16 的核心重构\n为解决同步协调的卡顿问题，React 16 引入 Fiber 架构，核心目标是**将协调过程从“同步不可中断”改为“异步可中断”**，允许 React 在执行耗时任务时，暂停并优先处理高优先级任务（如用户输入、动画），再继续执行低优先级任务（如组件渲染）。\n\n## 2.1 什么是 Fiber\nFiber 有两层含义：\n1. **数据结构**：Fiber 是虚拟 DOM 的升级版，是描述工作单元的 JavaScript 对象，包含节点信息、任务优先级、父子/兄弟节点引用等；\n   ```javascript\n   // Fiber 节点结构（简化版）\n   const fiberNode = {\n     type: 'div', // 节点类型\n     props: {}, // 节点属性\n     stateNode: null, // 对应真实 DOM 节点\n     child: null, // 子 Fiber 节点\n     sibling: null, // 兄弟 Fiber 节点\n     return: null, // 父 Fiber 节点\n     priority: 0, // 任务优先级\n     effectTag: null, // 副作用类型（更新/删除/插入）\n     nextEffect: null // 下一个有副作用的 Fiber 节点\n   };\n   ```\n2. **执行机制**：Fiber 是一种“增量式渲染”机制，将整个协调过程拆分为多个小的工作单元（每个 Fiber 节点对应一个工作单元），可按需暂停、恢复、终止。\n\n# 3. Fiber 架构的核心特性\n## 3.1 工作单元拆分\n将组件树的渲染任务拆分为单个 Fiber 节点的处理任务，每个工作单元执行时间极短（<16ms），避免阻塞主线程。\n\n## 3.2 优先级调度\nReact 为不同任务分配优先级（如用户输入 > 动画 > 数据加载 > 普通渲染），优先级高的任务可中断优先级低的任务：\n- 高优先级任务（如点击按钮）：立即执行，暂停当前低优先级任务；\n- 低优先级任务（如列表渲染）：执行一部分后，若有高优先级任务，保存当前进度，待高优先级任务完成后继续执行。\n\n## 3.3 双向链表遍历\nFiber 节点通过 `child`（子）、`sibling`（兄弟）、`return`（父）形成双向链表，支持：\n- **深度优先遍历**：先处理子节点，再处理兄弟节点，最后回到父节点；\n- **中断与恢复**：通过保存当前遍历位置，实现任务暂停后恢复。\n\n## 3.4 副作用收集\n协调过程中，React 不会立即更新真实 DOM，而是将所有需要修改的 Fiber 节点标记副作用（`effectTag`），待所有工作单元执行完成后，一次性批量更新真实 DOM（Commit 阶段），减少重排/重绘。\n\n# 4. Fiber 架构的工作流程\nFiber 架构将协调过程分为两个阶段：**Render 阶段（可中断）** 和 **Commit 阶段（不可中断）**。\n\n## 阶段 1：Render 阶段（异步可中断）\n核心任务：遍历 Fiber 树，执行 Diff 算法，收集副作用（更新/删除/插入）。\n1. **开始工作**：从根 Fiber 节点开始，创建新的 Fiber 树（WorkInProgress 树）；\n2. **处理工作单元**：逐个处理 Fiber 节点（创建/更新/删除），标记副作用；\n3. **检查优先级**：每处理完一个工作单元，检查是否有高优先级任务；\n   - 若无：继续处理下一个工作单元；\n   - 若有：暂停当前工作，保存进度，执行高优先级任务；\n4. **完成 Render 阶段**：所有工作单元处理完毕后，生成副作用链表（`nextEffect`）。\n\n## 阶段 2：Commit 阶段（同步不可中断）\n核心任务：将 Render 阶段收集的副作用批量应用到真实 DOM，执行生命周期钩子（如 `componentDidMount`/`useEffect`）。\n1. **Before Mutations**：执行 DOM 更新前的操作（如读取 DOM 布局）；\n2. **Mutations**：根据副作用链表更新真实 DOM（插入/删除/修改节点）；\n3. **Layout**：执行 DOM 更新后的操作（如调用 `useLayoutEffect`、更新组件引用）。\n\n# 5. Fiber 架构的价值\n- **解决卡顿问题**：异步可中断渲染避免了长时间阻塞主线程，提升页面流畅度；\n- **支持优先级调度**：优先处理用户交互等关键任务，优化用户体验；\n- **为新特性铺路**：是 React 18 并发渲染、Suspense、useTransition 等特性的基础；\n- **更高效的内存管理**：Fiber 节点的双向链表结构减少了内存占用，提升遍历效率。\n\n# 6. 常见疑问：Fiber 与虚拟 DOM 的关系\n- 虚拟 DOM 是“数据描述”（What），Fiber 是“执行机制”（How）；\n- Fiber 节点包含了虚拟 DOM 的信息（类型、属性），同时增加了执行相关的元数据（优先级、副作用）；\n- 虚拟 DOM 是 Fiber 架构的基础，Fiber 架构优化了虚拟 DOM 的渲染过程。","directory_id":"46554425-2ee6-405b-b46c-7720d50c48ec","is_published":true,"created_at":"2025-12-22 03:14:57.55+00","updated_at":"2025-12-23 09:31:38.48388+00"},{"id":"ab8119f9-af1c-4d91-9de4-732c8d9a6ba0","title":"父传子——props","content":"在 React 组件通信中，**父传子**是最基础、最常用的通信方式，核心依赖 `props`（properties 的缩写）实现。`props` 是父组件传递给子组件的数据容器，具有只读特性，子组件只能使用不能修改。\n\n# 1. props 基础用法\n## 1.1 基本传递流程\n父组件通过**标签属性**的形式传递数据，子组件通过**参数接收**并使用，步骤如下：\n### （1）父组件传递数据\n父组件在引用子组件时，像 HTML 标签添加属性一样，将需要传递的数据作为属性传入，支持任意 JavaScript 数据类型（字符串、数字、数组、对象、函数等）。\n```jsx\n// 父组件 Parent.jsx\nimport Child from './Child';\n\nfunction Parent() {\n  // 父组件的数据源\n  const name = 'React 组件';\n  const age = 3;\n  const skills = ['组件化', '声明式 UI', '虚拟 DOM'];\n  const info = { author: 'Facebook', type: '前端框架' };\n  const greet = () => console.log('Hello from Parent');\n\n  // 传递数据：通过标签属性传递给子组件\n  return (\n    <div>\n      <h1>父组件</h1>\n      <Child \n        title={name}  // 字符串类型\n        version={age} // 数字类型\n        features={skills} // 数组类型\n        meta={info} // 对象类型\n        sayHi={greet} // 函数类型\n        isPopular={true} // 布尔类型\n      />\n    </div>\n  );\n}\n```\n\n### （2）子组件接收并使用数据\n- 函数组件：直接通过**函数参数**接收 `props`，无需额外处理。\n- 类组件：通过 `this.props` 访问父组件传递的数据。\n\n```jsx\n// 子组件 Child.jsx（函数组件，推荐）\nfunction Child(props) {\n  // 直接通过 props.属性名 使用数据\n  return (\n    <div>\n      <h2>子组件接收的内容：</h2>\n      <p>框架名称：{props.title}</p>\n      <p>版本（简化）：{props.version}</p>\n      <p>核心特性：{props.features.join('、')}</p>\n      <p>作者：{props.meta.author}</p>\n      <p>是否流行：{props.isPopular ? '是' : '否'}</p>\n      <button onClick={props.sayHi}>调用父组件函数</button>\n    </div>\n  );\n}\n\n// 子组件 Child.jsx（类组件，兼容老项目）\nimport React from 'react';\nclass Child extends React.Component {\n  render() {\n    // 通过 this.props.属性名 使用数据\n    return (\n      <div>\n        <p>框架名称：{this.props.title}</p>\n        <button onClick={this.props.sayHi}>调用父组件函数</button>\n      </div>\n    );\n  }\n}\n```\n\n## 1.2 props 默认值\n当父组件未传递某个 props 时，子组件可通过 `defaultProps`（类组件）或**函数参数默认值**（函数组件）设置默认值，避免数据缺失导致报错。\n\n### （1）函数组件设置默认值（推荐）\n```jsx\n// 方式1：函数参数默认值（简洁直观）\nfunction Child(props = { title: '默认框架', version: 1 }) {\n  return <p>框架名称：{props.title}</p>;\n}\n\n// 方式2：通过 defaultProps 属性（兼容老写法）\nfunction Child(props) {\n  return <p>框架名称：{props.title}</p>;\n}\nChild.defaultProps = {\n  title: '默认框架',\n  version: 1\n};\n```\n\n### （2）类组件设置默认值\n```jsx\nclass Child extends React.Component {\n  render() {\n    return <p>框架名称：{this.props.title}</p>;\n  }\n}\n// 类组件通过静态属性 defaultProps 设置默认值\nChild.defaultProps = {\n  title: '默认框架',\n  version: 1\n};\n```\n\n## 1.3 解构赋值简化 props 使用\n当 props 数量较多时，可通过 ES6 解构赋值简化代码，直接提取需要的属性，提高可读性。\n```jsx\n// 函数组件解构（推荐）\nfunction Child({ title, version, features = [] }) {\n  return (\n    <div>\n      <p>框架名称：{title}</p>\n      <p>核心特性：{features.join('、')}</p>\n    </div>\n  );\n}\n\n// 类组件解构\nclass Child extends React.Component {\n  render() {\n    const { title, version } = this.props; // 解构 this.props\n    return <p>框架名称：{title}，版本：{version}</p>;\n  }\n}\n```\n\n# 2. props 只读特性（核心规则）\nReact 明确规定：**props 是只读的（read-only），子组件绝对不能修改 props 的值**。\n\n## 2.1 为什么 props 是只读的？\n- 组件设计原则：React 组件本质是“纯函数”，输入（props）决定输出（UI），修改输入会导致组件行为不可预测，违背纯函数特性。\n- 数据流向：React 是“单向数据流”，数据只能从父组件向下传递到子组件，子组件若需修改数据，必须通知父组件通过自身状态更新，再重新传递给子组件。\n\n## 2.2 错误示例（禁止修改 props）\n```jsx\nfunction Child(props) {\n  // 错误：直接修改 props 的属性值\n  props.version = 4; // 报错：Cannot assign to read only property 'version' of object '#<Object>'\n  \n  // 错误：尝试重新赋值 props\n  props = { title: '修改后的框架' }; // 虽然不报错，但破坏单向数据流，导致逻辑混乱\n  \n  return <p>版本：{props.version}</p>;\n}\n```\n\n## 2.3 正确做法（需修改数据时）\n若子组件需要基于 props 产生“可变数据”，应将 props 作为初始值，存入组件自身的状态（`useState` 或 `this.state`），再修改状态：\n```jsx\nfunction Child({ initialVersion = 1 }) {\n  // 将 props 作为初始值，存入组件自身状态\n  const [version, setVersion] = useState(initialVersion);\n  \n  // 正确：修改自身状态，而非 props\n  const handleUpdate = () => setVersion(prev => prev + 1);\n  \n  return (\n    <div>\n      <p>当前版本：{version}</p>\n      <button onClick={handleUpdate}>升级版本</button>\n    </div>\n  );\n}\n```\n\n# 3. 核心总结\n1. **传递规则**：父组件通过标签属性传值，子组件通过 `props`（函数组件）或 `this.props`（类组件）接收。\n2. **支持类型**：任意 JavaScript 类型（字符串、数字、数组、对象、函数等）。\n3. **只读特性**：props 不可修改，子组件需修改数据时，应基于 props 初始化自身状态。\n4. **默认值**：函数组件用参数默认值，类组件用 `defaultProps`，避免数据缺失。","directory_id":"803ada09-ee46-463c-b7f3-403560bfc20b","is_published":true,"created_at":"2025-12-19 10:42:47.60002+00","updated_at":"2025-12-19 10:42:47.60002+00"},{"id":"ae5d4a7d-fa74-4f81-a069-542a6fa08a31","title":"Axios 封装","content":"# 1. Axios 核心价值与封装意义\nAxios 是 React 项目中最常用的 HTTP 客户端，支持 Promise API、拦截请求/响应、取消请求、自动转换 JSON 数据等核心功能。直接使用 Axios 会导致代码冗余（如重复配置请求头、错误处理），封装后可实现：\n- 统一请求配置（基础路径、超时时间、请求头）；\n- 全局拦截器（添加 Token、处理 Token 过期、统一错误提示）；\n- 取消重复请求（避免同一接口多次触发）；\n- 统一错误处理（网络错误、业务错误、状态码错误）；\n- 类型安全（TypeScript 类型定义，适配接口返回格式）。\n\n# 2. 基础环境搭建\n## 2.1 安装依赖\n```bash\nnpm install axios # 核心依赖\nnpm install -D @types/axios # TypeScript 类型（可选）\n```\n\n## 2.2 目录结构设计\n```\nsrc/\n├── api/\n│   ├── index.ts        # Axios 实例封装\n│   ├── request.ts      # 请求工具函数（get/post/put/delete）\n│   ├── cancel.ts       # 取消请求相关工具\n│   └── modules/        # 按业务模块拆分接口（如 user.ts、goods.ts）\n└── utils/\n    └── toast.ts        # 全局提示工具（如 AntD Message）\n```\n\n# 3. 核心封装实现\n## 3.1 步骤 1：创建 Axios 实例（api/index.ts）\n配置基础路径、超时时间、默认请求头，创建可复用的 Axios 实例：\n```typescript\nimport axios, { AxiosInstance, AxiosRequestConfig, AxiosResponse } from 'axios';\nimport { handleRequestInterceptor, handleResponseInterceptor } from './interceptors';\nimport { setupCancelToken } from './cancel';\n\n// 创建 Axios 实例\nconst service: AxiosInstance = axios.create({\n  baseURL: import.meta.env.VITE_API_BASE_URL || '/api', // 基础路径（从环境变量读取）\n  timeout: 10000, // 超时时间（10s）\n  headers: {\n    'Content-Type': 'application/json;charset=utf-8', // 默认请求头\n  },\n  withCredentials: true, // 允许跨域携带 Cookie（根据业务需求配置）\n});\n\n// 注册请求/响应拦截器\nhandleRequestInterceptor(service);\n// 注册取消请求逻辑（在请求拦截器后执行）\nsetupCancelToken(service);\n// 注册响应拦截器\nhandleResponseInterceptor(service);\n\nexport default service;\n```\n\n## 3.2 步骤 2：实现拦截器（api/interceptors.ts）\n拦截请求添加 Token、处理响应错误、统一业务逻辑：\n```typescript\nimport { AxiosInstance, AxiosRequestConfig, AxiosResponse, AxiosError } from 'axios';\nimport { getToken, removeToken } from '@/utils/auth'; // Token 存储工具（如 localStorage）\nimport { toastError, toastWarning } from '@/utils/toast'; // 全局提示（如 AntD Message.error）\nimport router from '@/router'; // 路由实例（React Router）\n\n// 业务响应类型定义（适配后端返回格式）\ninterface ApiResponse<T = any> {\n  code: number; // 状态码（200 成功，其他失败）\n  message: string; // 提示信息\n  data: T; // 响应数据\n}\n\n/**\n * 请求拦截器：添加 Token、设置请求头等\n */\nexport const handleRequestInterceptor = (service: AxiosInstance) => {\n  service.interceptors.request.use(\n    (config: AxiosRequestConfig) => {\n      // 1. 添加 Token（如登录后存储在 localStorage 中的 Token）\n      const token = getToken();\n      if (token && config.headers) {\n        config.headers.Authorization = `Bearer ${token}`;\n      }\n\n      // 2. 处理 GET 请求参数序列化（可选，Axios 已默认处理）\n      if (config.method?.toUpperCase() === 'GET' && config.params) {\n        config.params = { ...config.params, _t: Date.now() }; // 添加时间戳防缓存\n      }\n\n      return config;\n    },\n    (error: AxiosError) => {\n      // 请求发送前的错误（如参数格式错误）\n      console.error('请求拦截器错误：', error);\n      return Promise.reject(error);\n    }\n  );\n};\n\n/**\n * 响应拦截器：统一错误处理、解析业务数据\n */\nexport const handleResponseInterceptor = (service: AxiosInstance) => {\n  service.interceptors.response.use(\n    (response: AxiosResponse<ApiResponse>) => {\n      const res = response.data;\n\n      // 1. 业务成功（根据后端状态码调整，如 200/0 为成功）\n      if (res.code === 200 || res.code === 0) {\n        return res.data; // 直接返回 data 层，简化业务组件使用\n      }\n\n      // 2. 业务失败（如参数错误、权限不足）\n      toastWarning(res.message || '操作失败');\n      return Promise.reject(res);\n    },\n    (error: AxiosError) => {\n      console.error('响应拦截器错误：', error);\n      const response = error.response;\n\n      // 3. 网络错误/超时错误\n      if (!response) {\n        toastError('网络异常，请检查网络连接');\n        return Promise.reject(error);\n      }\n\n      // 4. HTTP 状态码错误（4xx/5xx）\n      const status = response.status;\n      switch (status) {\n        case 401: // 未授权（Token 过期/未登录）\n          toastError('登录已过期，请重新登录');\n          removeToken(); // 清除无效 Token\n          router.push('/login'); // 跳转到登录页\n          break;\n        case 403: // 权限不足\n          toastError('暂无权限操作');\n          break;\n        case 404: // 接口不存在\n          toastError('请求资源不存在');\n          break;\n        case 500: // 服务器错误\n          toastError('服务器内部错误，请稍后重试');\n          break;\n        default:\n          toastError(`请求失败（${status}）`);\n      }\n\n      return Promise.reject(error);\n    }\n  );\n};\n```\n\n## 3.3 步骤 3：取消请求实现（api/cancel.ts）\n避免重复请求（如快速点击按钮触发多次同一接口），支持单个/全部取消：\n```typescript\nimport { AxiosInstance, AxiosRequestConfig } from 'axios';\nimport { v4 as uuidv4 } from 'uuid'; // 生成唯一标识（需安装：npm install uuid @types/uuid）\n\n// 存储取消请求的控制器（key: 请求标识，value: AbortController）\nconst cancelControllerMap = new Map<string, AbortController>();\n\n/**\n * 生成请求唯一标识（基于 URL + 方法 + 参数）\n */\nconst generateRequestKey = (config: AxiosRequestConfig) => {\n  const { url, method, params, data } = config;\n  return `${method?.toUpperCase()}-${url}-${JSON.stringify(params || {})}-${JSON.stringify(data || {})}`;\n};\n\n/**\n * 注册取消请求逻辑（在请求拦截器中添加）\n */\nexport const setupCancelToken = (service: AxiosInstance) => {\n  service.interceptors.request.use((config) => {\n    // 1. 生成请求标识\n    const requestKey = generateRequestKey(config);\n\n    // 2. 取消之前的重复请求\n    if (cancelControllerMap.has(requestKey)) {\n      const prevController = cancelControllerMap.get(requestKey);\n      prevController?.abort('取消重复请求');\n      cancelControllerMap.delete(requestKey);\n    }\n\n    // 3. 创建新的 AbortController（Axios 0.22+ 推荐使用，替代 CancelToken）\n    const controller = new AbortController();\n    config.signal = controller.signal;\n\n    // 4. 存储控制器\n    cancelControllerMap.set(requestKey, controller);\n\n    return config;\n  });\n\n  // 响应完成后移除控制器\n  service.interceptors.response.use(\n    (response) => {\n      const requestKey = generateRequestKey(response.config);\n      cancelControllerMap.delete(requestKey);\n      return response;\n    },\n    (error) => {\n      // 取消请求的错误不提示\n      if (error.name === 'CanceledError') {\n        console.log('请求已取消：', error.message);\n        return Promise.reject(new Error('请求已取消'));\n      }\n      return Promise.reject(error);\n    }\n  );\n};\n\n/**\n * 取消指定请求（如页面卸载时取消未完成的请求）\n * @param config 请求配置（如 { url: '/api/user', method: 'get' }）\n */\nexport const cancelRequest = (config: AxiosRequestConfig) => {\n  const requestKey = generateRequestKey(config);\n  if (cancelControllerMap.has(requestKey)) {\n    const controller = cancelControllerMap.get(requestKey);\n    controller?.abort();\n    cancelControllerMap.delete(requestKey);\n  }\n};\n\n/**\n * 取消所有未完成的请求\n */\nexport const cancelAllRequests = () => {\n  cancelControllerMap.forEach((controller) => {\n    controller.abort('取消所有请求');\n  });\n  cancelControllerMap.clear();\n};\n```\n\n## 3.4 步骤 4：封装请求工具函数（api/request.ts）\n统一封装 get/post/put/delete 方法，简化接口调用：\n```typescript\nimport service from './index';\nimport { AxiosRequestConfig } from 'axios';\n\n/**\n * GET 请求\n * @param url 接口地址\n * @param params 请求参数（拼接在 URL 上）\n * @param config 额外请求配置\n */\nexport const get = <T = any>(url: string, params?: any, config?: AxiosRequestConfig): Promise<T> => {\n  return service.get(url, { params, ...config });\n};\n\n/**\n * POST 请求（JSON 格式）\n * @param url 接口地址\n * @param data 请求体数据\n * @param config 额外请求配置\n */\nexport const post = <T = any>(url: string, data?: any, config?: AxiosRequestConfig): Promise<T> => {\n  return service.post(url, data, config);\n};\n\n/**\n * PUT 请求\n * @param url 接口地址\n * @param data 请求体数据\n * @param config 额外请求配置\n */\nexport const put = <T = any>(url: string, data?: any, config?: AxiosRequestConfig): Promise<T> => {\n  return service.put(url, data, config);\n};\n\n/**\n * DELETE 请求\n * @param url 接口地址\n * @param params 请求参数\n * @param config 额外请求配置\n */\nexport const del = <T = any>(url: string, params?: any, config?: AxiosRequestConfig): Promise<T> => {\n  return service.delete(url, { params, ...config });\n};\n\n/**\n * 上传文件（FormData 格式）\n * @param url 接口地址\n * @param file 上传的文件\n * @param config 额外配置（如进度回调）\n */\nexport const upload = <T = any>(\n  url: string,\n  file: File,\n  config?: AxiosRequestConfig\n): Promise<T> => {\n  const formData = new FormData();\n  formData.append('file', file);\n  return service.post(url, formData, {\n    headers: { 'Content-Type': 'multipart/form-data' },\n    ...config,\n  });\n};\n\n// 导出所有请求方法\nexport default { get, post, put, del, upload };\n```\n\n## 3.5 步骤 5：按业务模块拆分接口（api/modules/user.ts）\n```typescript\nimport { get, post, del } from '../request';\n\n// 用户登录接口\nexport const login = (data: { username: string; password: string }) => {\n  return post<{ token: string; userInfo: { id: number; name: string } }>('/user/login', data);\n};\n\n// 获取用户信息\nexport const getUserInfo = () => {\n  return get<{ id: number; name: string; role: string }>('/user/info');\n};\n\n// 退出登录\nexport const logout = () => {\n  return post('/user/logout');\n};\n\n// 分页获取用户列表\nexport const getUserList = (params: { page: number; pageSize: number; keyword?: string }) => {\n  return get<{\n    list: Array<{ id: number; name: string; age: number }>;\n    total: number;\n  }>('/user/list', params);\n};\n```\n\n# 4. 实际使用示例\n## 4.1 组件中调用接口\n```tsx\nimport React, { useState, useEffect } from 'react';\nimport { getUserList, logout } from '@/api/modules/user';\nimport { cancelRequest } from '@/api/cancel';\nimport { Button, Table, message } from 'antd';\n\nconst UserPage = () => {\n  const [userList, setUserList] = useState([]);\n  const [total, setTotal] = useState(0);\n  const [loading, setLoading] = useState(false);\n\n  // 加载用户列表\n  const fetchUserList = async (page = 1, pageSize = 10) => {\n    setLoading(true);\n    try {\n      const res = await getUserList({ page, pageSize, keyword: '张三' });\n      setUserList(res.list);\n      setTotal(res.total);\n    } catch (err) {\n      console.error('获取用户列表失败：', err);\n    } finally {\n      setLoading(false);\n    }\n  };\n\n  useEffect(() => {\n    fetchUserList();\n\n    // 页面卸载时取消未完成的请求\n    return () => {\n      cancelRequest({ url: '/user/list', method: 'get' });\n    };\n  }, []);\n\n  // 退出登录\n  const handleLogout = async () => {\n    try {\n      await logout();\n      message.success('退出成功');\n      // 跳转到登录页\n    } catch (err) {\n      message.error('退出失败');\n    }\n  };\n\n  return (\n    <div>\n      <Button type=\"primary\" danger onClick={handleLogout} style={{ marginBottom: 16 }}>\n        退出登录\n      </Button>\n      <Table\n        loading={loading}\n        dataSource={userList}\n        columns={[\n          { title: 'ID', dataIndex: 'id' },\n          { title: '姓名', dataIndex: 'name' },\n          { title: '年龄', dataIndex: 'age' },\n        ]}\n        pagination={{ current: 1, pageSize: 10, total }}\n        rowKey=\"id\"\n      />\n    </d...","directory_id":"f6ecfee0-71f1-4926-96ee-892bbcebe758","is_published":true,"created_at":"2025-12-22 03:21:35.858233+00","updated_at":"2025-12-23 14:20:53.584283+00"},{"id":"b3d3f2bf-4973-42a0-bff7-5a34799a7096","title":"React 元素渲染","content":"在 React 中，**元素渲染**是将我们编写的 React 元素转化为真实 DOM 节点，并挂载到页面上的过程。随着 React 版本的迭代，渲染的方式也从传统的 `ReactDOM.render` 升级为更高效的 `root.render`（React 18 引入）。\n\n# 1. React 元素的本质\nReact 元素是描述页面 UI 的**不可变 JavaScript 对象**，它不是真实的 DOM 节点，而是一个轻量级的“描述符”。我们可以通过 JSX 语法快速创建 React 元素，也可以直接调用 `React.createElement` 方法生成。\n\n示例：\n```jsx\n// JSX 形式（推荐）\nconst element = <h1>Hello, React 渲染！</h1>;\n\n// 等价于 React.createElement 形式\nconst element = React.createElement('h1', null, 'Hello, React 渲染！');\n```\nReact 元素的特点是**不可变性**，一旦创建就无法修改其属性或子元素，如果需要更新 UI，只能创建一个新的 React 元素。\n\n# 2. 传统渲染方式：ReactDOM.render\n`ReactDOM.render` 是 React 18 之前的核心渲染方法，用于将 React 元素挂载到指定的 DOM 容器中。\n\n## 2.1 基本用法\n语法：\n```jsx\nReactDOM.render(element, container[, callback]);\n```\n- `element`：要渲染的 React 元素（JSX 或 `React.createElement` 生成的对象）。\n- `container`：真实 DOM 容器，用于承载 React 元素渲染后的内容。\n- `callback`：可选参数，渲染完成后执行的回调函数。\n\n示例代码：\n```html\n<!-- HTML 容器 -->\n<div id=\"root\"></div>\n\n<!-- React 代码 -->\n<script src=\"https://unpkg.com/react@17/umd/react.development.js\"></script>\n<script src=\"https://unpkg.com/react-dom@17/umd/react-dom.development.js\"></script>\n<script>\n  const element = <h1>Hello, ReactDOM.render！</h1>;\n  // 渲染到 #root 容器中\n  ReactDOM.render(element, document.getElementById('root'), () => {\n    console.log('渲染完成！');\n  });\n</script>\n```\n\n## 2.2 特点与局限性\n1. **特点**\n    - 简单易用，直接关联 React 元素和 DOM 容器。\n    - 当传入新的 React 元素时，React 会对比新旧元素的差异（**Diff 算法**），只更新变化的部分，而不是重新渲染整个 DOM。\n2. **局限性**\n    - 不支持 React 18 的**并发特性**（如 Suspense、自动批处理等）。\n    - 无法实现更灵活的根节点配置，比如启用严格模式、并发模式等。\n\n# 3. 现代渲染方式：root.render（React 18+）\nReact 18 推出了全新的**根节点 API**，通过 `createRoot` 创建根节点，再调用 `root.render` 进行渲染，这是目前推荐的渲染方式。\n\n## 3.1 基本用法\n语法：\n```jsx\nimport { createRoot } from 'react-dom/client';\n\n// 1. 创建根节点\nconst root = createRoot(container);\n// 2. 渲染 React 元素\nroot.render(element);\n```\n- `createRoot`：接收 DOM 容器作为参数，返回一个根节点对象。\n- `root.render`：将 React 元素渲染到根节点对应的容器中，支持多次调用。\n\n示例代码：\n```html\n<!-- HTML 容器 -->\n<div id=\"root\"></div>\n\n<!-- React 18+ 代码 -->\n<script src=\"https://unpkg.com/react@18/umd/react.development.js\"></script>\n<script src=\"https://unpkg.com/react-dom@18/umd/react-dom.development.js\"></script>\n<script>\n  const element = <h1>Hello, root.render！</h1>;\n  // 创建根节点\n  const root = ReactDOM.createRoot(document.getElementById('root'));\n  // 渲染元素\n  root.render(element);\n</script>\n```\n\n## 3.2 核心优势\n1. **支持并发特性**\n    React 18 的并发模式允许 React 中断渲染、恢复渲染，优先处理高优先级任务（如用户输入），`root.render` 是开启这些特性的基础。\n2. **自动批处理更新**\n    批处理是指将多个状态更新合并为一次 DOM 更新，减少渲染次数。`root.render` 默认启用自动批处理，无论状态更新在 setTimeout、Promise 还是原生事件中，都会被合并处理。\n3. **多次渲染更高效**\n    当多次调用 `root.render` 时，React 会基于最新的 React 元素进行差异对比，避免重复渲染，比 `ReactDOM.render` 更高效。\n\n# 4. 渲染更新机制\n无论是 `ReactDOM.render` 还是 `root.render`，React 的渲染更新都遵循**虚拟 DOM + Diff 算法**的核心逻辑：\n1. 当页面需要更新时，创建一个新的 React 元素（虚拟 DOM 节点）。\n2. React 对比新旧虚拟 DOM 的差异，生成一个**差异补丁**。\n3. 只将差异部分应用到真实 DOM 中，完成 UI 更新。\n\n示例：多次渲染更新\n```jsx\nconst root = ReactDOM.createRoot(document.getElementById('root'));\n\n// 第一次渲染\nroot.render(<h1>计数：0</h1>);\n\n// 2 秒后更新渲染\nsetTimeout(() => {\n  root.render(<h1>计数：1</h1>);\n}, 2000);\n```\n在这个例子中，2 秒后 React 只会更新 `<h1>` 标签内的文本内容，而不会重新创建整个 `<h1>` 元素。\n\n# 5. 注意事项\n1. 一个 DOM 容器只能对应一个 React 根节点，多次调用 `createRoot` 会覆盖之前的根节点。\n2. React 元素渲染后，会完全控制容器内的内容，容器中原有的 DOM 节点会被替换。\n3. 开发环境下，`root.render` 会执行两次渲染（严格模式下），这是为了检测副作用，生产环境下只会渲染一次。","directory_id":"763e50ae-d5ad-4770-b985-cb78491214e1","is_published":true,"created_at":"2025-12-19 08:04:43.063725+00","updated_at":"2025-12-19 08:55:30.503531+00"},{"id":"bcbc4f3d-58a2-4e46-8284-de8c18b38377","title":"路由守卫","content":"**路由守卫**并非 React Router 提供的官方概念，而是开发者基于路由功能实现的“路由访问控制机制”——在用户跳转到某个路由前，验证其权限（如是否登录、是否有操作权限），根据验证结果决定允许访问、重定向到其他页面或提示无权限。\n\nReact Router v6 中实现路由守卫的核心方式是：利用组件的生命周期/渲染逻辑、`Navigate` 组件（重定向）、`useNavigate` 钩子（编程式跳转）。\n\n# 1. 核心应用场景\n1. 未登录用户访问需要授权的页面（如个人中心、后台管理），重定向到登录页；\n2. 已登录用户重复访问登录页，重定向到首页；\n3. 权限不足的用户访问特定页面（如普通用户访问管理员页面），提示无权限或重定向。\n\n# 2. 实现方式\n## 2.1 基础鉴权组件（通用守卫）\n封装一个可复用的鉴权组件，包裹需要保护的路由组件，实现“全局守卫逻辑”：\n```jsx\n// components/PrivateRoute.jsx\nimport { Navigate } from 'react-router-dom';\n\n// 模拟登录状态（实际项目中从状态管理库/本地存储获取）\nconst isLogin = () => {\n  return localStorage.getItem('token') !== null;\n};\n\n// 鉴权组件：children 为需要保护的组件\nexport default function PrivateRoute({ children }) {\n  if (!isLogin()) {\n    // 未登录：重定向到登录页，并记录当前路径（登录后可返回）\n    return <Navigate to=\"/login\" replace state={{ from: window.location.pathname }} />;\n  }\n  // 已登录：渲染受保护的组件\n  return children;\n}\n```\n\n## 2.2 在路由中使用鉴权组件\n将需要保护的路由组件用 `PrivateRoute` 包裹：\n```jsx\n// App.jsx\nimport { BrowserRouter, Routes, Route } from 'react-router-dom';\nimport PrivateRoute from './components/PrivateRoute';\nimport Login from './pages/Login';\nimport Dashboard from './pages/Dashboard'; // 需要登录才能访问\n\nfunction App() {\n  return (\n    <BrowserRouter>\n      <Routes>\n        <Route path=\"/login\" element={<Login />} />\n        {/* 受保护的路由 */}\n        <Route \n          path=\"/dashboard\" \n          element={\n            <PrivateRoute>\n              <Dashboard />\n            </PrivateRoute>\n          } \n        />\n      </Routes>\n    </BrowserRouter>\n  );\n}\n```\n\n## 2.3 登录页的“回跳逻辑”\n登录成功后，返回之前想要访问的页面（通过 `state` 传递的 `from` 参数）：\n```jsx\n// pages/Login.jsx\nimport { useNavigate, useLocation } from 'react-router-dom';\n\nexport default function Login() {\n  const navigate = useNavigate();\n  const location = useLocation();\n  // 获取之前的路径，默认值为首页\n  const from = location.state?.from || '/';\n\n  const handleLogin = () => {\n    // 模拟登录：存储 token\n    localStorage.setItem('token', 'fake-token-123');\n    // 跳转到之前想要访问的页面\n    navigate(from, { replace: true });\n  };\n\n  return (\n    <div>\n      <h1>登录页</h1>\n      <button onClick={handleLogin}>模拟登录</button>\n    </div>\n  );\n}\n```\n\n## 2.4 细粒度权限控制（角色鉴权）\n针对不同角色（如管理员、普通用户）设置路由访问权限：\n```jsx\n// components/RoleRoute.jsx\nimport { Navigate } from 'react-router-dom';\n\n// 模拟用户角色（实际从接口/本地存储获取）\nconst getUserRole = () => {\n  return localStorage.getItem('role') || 'user'; // admin / user\n};\n\n// 角色鉴权组件：需要指定允许的角色\nexport default function RoleRoute({ allowedRoles, children }) {\n  const currentRole = getUserRole();\n  if (!allowedRoles.includes(currentRole)) {\n    // 无权限：重定向到无权限页面或首页\n    return <Navigate to=\"/403\" replace />;\n  }\n  return children;\n}\n```\n\n使用方式：\n```jsx\n<Route \n  path=\"/admin\" \n  element={\n    <PrivateRoute>\n      <RoleRoute allowedRoles={['admin']}>\n        <AdminPage />\n      </RoleRoute>\n    </PrivateRoute>\n  } \n/>\n```\n\n## 2.5 编程式路由守卫（组件内守卫）\n在组件渲染时进行权限校验（适用于单个组件的特殊逻辑）：\n```jsx\n// pages/Profile.jsx\nimport { useEffect } from 'react';\nimport { useNavigate } from 'react-router-dom';\n\nexport default function Profile() {\n  const navigate = useNavigate();\n\n  useEffect(() => {\n    const isLogin = localStorage.getItem('token') === null;\n    if (isLogin) {\n      navigate('/login', { replace: true });\n    }\n  }, [navigate]);\n\n  return <div>个人中心页面</div>;\n}\n```\n\n# 3. 关键注意事项\n1. **`replace` 属性**：重定向时使用 `replace: true`，避免在浏览器历史记录中留下重定向的痕迹（防止用户点击返回按钮回到无权限页面）。\n2. **权限状态的实时性**：若项目中使用状态管理库（如 Redux、Pinia），需确保鉴权逻辑能响应状态变化（如用户登出后立即重定向）。\n3. **服务端校验**：前端路由守卫仅用于提升用户体验，**真正的权限控制必须在服务端实现**（防止用户通过修改前端代码绕过守卫）。\n4. **403/404 页面**：配置无权限页面（403）和页面不存在页面（404），提升用户体验：\n   ```jsx\n   <Route path=\"/403\" element={<NoPermission />} />\n   <Route path=\"*\" element={<NotFound />} />\n   ```\n","directory_id":"77b830a2-38dc-41a0-8e20-9f29ffc5a332","is_published":true,"created_at":"2025-12-22 02:08:44.933755+00","updated_at":"2025-12-23 02:51:59.324326+00"},{"id":"bfb9f726-f542-4e40-9dfb-553beae09d54","title":"错误边界（Error Boundary）捕获组件异常","content":"# 1. 错误边界的核心概念\nReact 中，组件内的 JavaScript 错误（如渲染错误、事件处理错误、生命周期错误）若未捕获，会导致整个组件树崩溃，页面白屏。**错误边界（Error Boundary）** 是一种特殊的 React 组件，用于捕获其子组件树中抛出的错误，记录错误信息，并显示降级 UI（替代崩溃的组件），避免整个应用崩溃。\n\n## 1.1 关键特性：\n- 错误边界仅能捕获**子组件**的错误，无法捕获自身的错误；\n- 错误边界能捕获的错误类型：\n  - 渲染阶段的错误（如 JSX 语法错误、组件渲染时的逻辑错误）；\n  - 生命周期方法中的错误（如 `componentDidMount`、`useEffect` 中的错误）；\n  - 子组件构造函数中的错误；\n- 错误边界**无法捕获**的错误类型：\n  - 事件处理函数中的错误（如点击按钮触发的函数错误）；\n  - 异步代码中的错误（如 `setTimeout`、`Promise` 回调中的错误）；\n  - 服务端渲染中的错误；\n  - 错误边界自身抛出的错误；\n\n# 2. 如何创建错误边界组件\n错误边界组件必须是**类组件**（React 暂不支持函数组件作为错误边界），需实现以下两个生命周期方法之一：\n1. `static getDerivedStateFromError(error)`：静态方法，用于更新组件状态，显示降级 UI；\n2. `componentDidCatch(error, info)`：实例方法，用于记录错误信息（如上报到日志系统）。\n\n## 2.1 基础示例：\n```javascript\nimport React, { Component } from 'react';\n\nclass ErrorBoundary extends Component {\n  constructor(props) {\n    super(props);\n    // 初始化状态：无错误\n    this.state = { hasError: false, error: null, errorInfo: null };\n  }\n\n  // 捕获子组件错误，更新状态以显示降级 UI\n  static getDerivedStateFromError(error) {\n    return { hasError: true };\n  }\n\n  // 捕获错误详情，用于日志上报\n  componentDidCatch(error, errorInfo) {\n    // 记录错误信息（可上报到 Sentry、LogRocket 等平台）\n    console.error('错误边界捕获到错误：', error, errorInfo);\n    this.setState({\n      error: error,\n      errorInfo: errorInfo\n    });\n  }\n\n  // 重置错误状态（可选）\n  resetError = () => {\n    this.setState({ hasError: false, error: null, errorInfo: null });\n  };\n\n  render() {\n    // 若有错误，显示降级 UI\n    if (this.state.hasError) {\n      return (\n        <div style={{ padding: '20px', textAlign: 'center' }}>\n          <h2>哎呀，组件出错了！</h2>\n          <p>{this.state.error?.message}</p>\n          <button onClick={this.resetError}>刷新组件</button>\n          {/* 开发环境可显示错误栈（生产环境隐藏） */}\n          {process.env.NODE_ENV === 'development' && (\n            <details style={{ marginTop: '10px', textAlign: 'left' }}>\n              <summary>错误详情</summary>\n              {this.state.errorInfo?.componentStack}\n            </details>\n          )}\n        </div>\n      );\n    }\n\n    // 无错误时，渲染子组件\n    return this.props.children;\n  }\n}\n\nexport default ErrorBoundary;\n```\n\n# 3. 错误边界的使用方式\n## 3.1 包裹单个组件（局部错误处理）\n```javascript\nimport ErrorBoundary from './ErrorBoundary';\nimport BuggyComponent from './BuggyComponent'; // 可能抛出错误的组件\n\nfunction App() {\n  return (\n    <div>\n      <h1>我的应用</h1>\n      {/* 用错误边界包裹易出错的组件 */}\n      <ErrorBoundary>\n        <BuggyComponent />\n      </ErrorBoundary>\n      {/* 其他组件不受影响 */}\n      <div>其他正常组件</div>\n    </div>\n  );\n}\n```\n\n## 3.2 包裹整个应用（全局错误处理）\n```javascript\nimport ErrorBoundary from './ErrorBoundary';\nimport MainContent from './MainContent';\n\nfunction App() {\n  return (\n    <ErrorBoundary>\n      <MainContent />\n    </ErrorBoundary>\n  );\n}\n```\n\n## 3.3 嵌套错误边界（精细化处理）\n```javascript\n// 全局错误边界（捕获根组件错误）\n<ErrorBoundary fallback={<GlobalFallback />}>\n  <div>\n    {/* 局部错误边界（捕获列表组件错误） */}\n    <ErrorBoundary fallback={<ListFallback />}>\n      <ProductList />\n    </ErrorBoundary>\n    {/* 局部错误边界（捕获表单组件错误） */}\n    <ErrorBoundary fallback={<FormFallback />}>\n      <CheckoutForm />\n    </ErrorBoundary>\n  </div>\n</ErrorBoundary>\n```\n\n# 4. 错误边界的最佳实践\n1. **精准包裹**：仅包裹可能抛出错误的组件（如第三方组件、动态渲染的组件），避免全局包裹导致小错误被放大；\n2. **分级降级 UI**：\n   - 局部错误边界：显示组件级降级 UI（如“该模块加载失败，请重试”）；\n   - 全局错误边界：显示应用级降级 UI（如“应用出错，请刷新页面”）；\n3. **错误日志上报**：在 `componentDidCatch` 中集成错误监控工具（如 Sentry），实时上报错误信息，便于定位问题；\n4. **开发与生产环境区分**：\n   - 开发环境：显示详细错误栈，帮助调试；\n   - 生产环境：隐藏敏感错误信息，仅显示友好提示；\n5. **提供恢复机制**：添加“刷新组件”“重试”按钮，让用户无需刷新整个页面即可恢复；\n\n# 5. 常见问题与解决方案\n## 问题1：函数组件无法作为错误边界\n解决方案：用类组件封装错误边界，或使用第三方库（如 `react-error-boundary`）提供的函数组件版错误边界。\n\n## 问题2：事件处理错误无法被捕获\n解决方案：在事件处理函数中手动 try/catch 捕获错误：\n```javascript\nfunction handleClick() {\n  try {\n    // 可能出错的代码\n    riskyOperation();\n  } catch (error) {\n    console.error('事件处理错误：', error);\n    // 显示错误提示或上报\n  }\n}\n```\n\n## 问题3：异步错误无法被捕获\n解决方案：在异步代码中手动 try/catch，或使用 `unhandledrejection` 全局监听 Promise 错误：\n```javascript\n// 全局监听未捕获的 Promise 错误\nwindow.addEventListener('unhandledrejection', (event) => {\n  console.error('未处理的 Promise 错误：', event.reason);\n  event.preventDefault(); // 阻止浏览器默认行为\n});\n\n// 异步函数内手动捕获\nasync function fetchData() {\n  try {\n    const res = await fetch('/api/data');\n    const data = await res.json();\n    return data;\n  } catch (error) {\n    console.error('数据请求错误：', error);\n    throw error; // 若需让错误边界捕获，可重新抛出（需在渲染阶段）\n  }\n}\n```","directory_id":"a02f0182-c167-4bad-9395-1aa29e0a493f","is_published":true,"created_at":"2025-12-22 03:17:02.268055+00","updated_at":"2025-12-23 09:52:44.136031+00"},{"id":"c278feac-3eab-425c-b067-82c2a805aeed","title":"事件处理","content":"在 React 中，事件处理是构建交互式 UI 的核心能力。React 并没有直接使用原生 DOM 事件，而是实现了一套**合成事件系统**，它兼具跨浏览器兼容性和性能优势。同时，事件处理函数的 `this` 指向和参数传递也是开发中需要重点掌握的知识点。\n\n# 1. React 合成事件系统\n## 1.1 合成事件的概念\n**合成事件（SyntheticEvent）** 是 React 模拟原生 DOM 事件的跨浏览器包装对象，它将不同浏览器的原生事件行为进行了标准化，提供了与原生事件一致的 API（如 `stopPropagation`、`preventDefault`）。\n\n简单来说，合成事件不是原生 DOM 事件，但它可以模拟原生事件的所有功能，并且在所有浏览器中表现一致。\n\n## 1.2 合成事件的特点\n1. **跨浏览器兼容性**\n    不同浏览器的原生事件存在差异（如 IE 的 `attachEvent` vs 标准浏览器的 `addEventListener`），React 合成事件封装了这些差异，开发者无需关心浏览器兼容问题。\n2. **事件委托机制**\n    React 并不会给每个元素绑定事件处理器，而是将所有事件委托到**根节点**（`document`）上。当事件触发时，React 会根据事件冒泡路径找到对应的组件，再执行事件处理函数。这种机制减少了大量的事件绑定操作，提升了性能。\n3. **与原生事件的关系**\n    合成事件内部持有原生事件的引用，可以通过 `e.nativeEvent` 获取原生事件对象。\n    ```jsx\n    function handleClick(e) {\n      // e 是合成事件对象\n      console.log(e.nativeEvent); // 获取原生 DOM 事件对象\n    }\n    ```\n4. **合成事件的生命周期**\n    合成事件对象会在事件处理函数执行完毕后被**回收复用**，因此不能在异步操作中访问合成事件对象的属性。如果需要在异步中使用，需要调用 `e.persist()` 方法保留事件对象。\n    ```jsx\n    function handleClick(e) {\n      e.persist(); // 保留合成事件对象\n      setTimeout(() => {\n        console.log(e.target); // 异步中可以正常访问\n      }, 1000);\n    }\n    ```\n\n## 1.3 合成事件与原生事件的区别\n| 特性 | React 合成事件 | 原生 DOM 事件 |\n|------|----------------|--------------|\n| 绑定方式 | 通过 JSX 属性（如 `onClick`） | 通过 `addEventListener` |\n| 事件名 | 小驼峰命名（如 `onMouseOver`） | 全小写（如 `mouseover`） |\n| 事件委托 | 委托到 document | 无默认委托 |\n| 跨浏览器兼容 | 自动兼容 | 需手动处理兼容 |\n| 事件对象 | SyntheticEvent | 原生 Event 对象 |\n\n# 2. 事件处理函数的 this 指向问题\n在 React 类组件中，事件处理函数的 `this` 指向是一个常见的坑。默认情况下，类组件的方法不会绑定 `this`，如果直接作为事件处理函数使用，`this` 会指向 `undefined`（严格模式下）。\n\n## 2.1 问题复现\n```jsx\nimport React, { Component } from 'react';\n\nclass Button extends Component {\n  constructor(props) {\n    super(props);\n    this.state = { count: 0 };\n  }\n\n  handleClick() {\n    // 这里的 this 是 undefined\n    this.setState({ count: this.state.count + 1 });\n  }\n\n  render() {\n    return <button onClick={this.handleClick}>点击计数</button>;\n  }\n}\n```\n当点击按钮时，会报错 `Cannot read property 'setState' of undefined`，原因是 `handleClick` 函数的 `this` 没有绑定到组件实例。\n\n## 2.2 解决方法\n### 方法1：构造函数中绑定 this（推荐）\n在组件的 `constructor` 中，通过 `bind` 方法将事件处理函数的 `this` 绑定到组件实例。\n```jsx\nconstructor(props) {\n  super(props);\n  this.state = { count: 0 };\n  // 绑定 this\n  this.handleClick = this.handleClick.bind(this);\n}\n```\n这种方法的优势是只需要绑定一次，性能较高。\n\n### 方法2：使用箭头函数定义事件处理函数\n箭头函数的 `this` 会继承外层作用域的 `this`（即组件实例），因此不需要手动绑定。\n```jsx\n// 箭头函数形式，this 指向组件实例\nhandleClick = () => {\n  this.setState({ count: this.state.count + 1 });\n};\n```\n这种方法写法简洁，是目前类组件中常用的方式。\n\n### 方法3：调用时使用箭头函数\n在 JSX 的事件绑定中，直接使用箭头函数包裹事件处理函数。\n```jsx\nrender() {\n  return (\n    <button onClick={() => this.handleClick()}>点击计数</button>\n  );\n}\n```\n这种方法的缺点是：每次组件渲染时都会创建一个新的箭头函数，可能会影响性能（尤其是在列表渲染中），并且会导致子组件的 `shouldComponentUpdate` 失效。\n\n## 2.3 函数组件中的 this 问题\n函数组件中没有 `this` 指向，因此不需要考虑 `this` 绑定问题，直接定义事件处理函数即可。\n```jsx\nimport { useState } from 'react';\n\nfunction Button() {\n  const [count, setCount] = useState(0);\n\n  const handleClick = () => {\n    setCount(count + 1);\n  };\n\n  return <button onClick={handleClick}>计数：{count}</button>;\n}\n```\n\n# 3. 事件处理函数的参数传递\n在实际开发中，我们经常需要给事件处理函数传递额外的参数（如列表项的 ID、索引等）。React 提供了多种事件传参的方式。\n\n## 方式1：箭头函数传参\n在事件绑定处使用箭头函数，直接传递参数给事件处理函数。\n```jsx\nimport { useState } from 'react';\n\nfunction ItemList() {\n  const [items] = useState(['苹果', '香蕉', '橙子']);\n\n  const handleItemClick = (item, index) => {\n    console.log(`点击了第 ${index} 项：${item}`);\n  };\n\n  return (\n    <ul>\n      {items.map((item, index) => (\n        <li key={index} onClick={() => handleItemClick(item, index)}>\n          {item}\n        </li>\n      ))}\n    </ul>\n  );\n}\n```\n这种方式直观易懂，是最常用的传参方法。\n\n## 方式2：bind 方法传参\n利用 `bind` 方法的特性，在绑定 `this` 的同时传递额外参数。\n```jsx\n// 类组件示例\nclass ItemList extends Component {\n  state = { items: ['苹果', '香蕉', '橙子'] };\n\n  handleItemClick(item, index) {\n    console.log(`点击了第 ${index} 项：${item}`);\n  }\n\n  render() {\n    return (\n      <ul>\n        {this.state.items.map((item, index) => (\n          <li key={index} onClick={this.handleItemClick.bind(this, item, index)}>\n            {item}\n          </li>\n        ))}\n      </ul>\n    );\n  }\n}\n```\n`bind` 方法的第一个参数是 `this` 指向，后续参数会作为事件处理函数的参数传入。\n\n## 方式3：通过自定义属性传参\n可以通过元素的自定义属性（如 `data-*`）存储参数，在事件处理函数中通过 `e.target.dataset` 获取。\n```jsx\nfunction ItemList() {\n  const [items] = useState(['苹果', '香蕉', '橙子']);\n\n  const handleItemClick = (e) => {\n    const item = e.target.dataset.item;\n    const index = e.target.dataset.index;\n    console.log(`点击了第 ${index} 项：${item}`);\n  };\n\n  return (\n    <ul>\n      {items.map((item, index) => (\n        <li \n          key={index} \n          data-item={item} \n          data-index={index} \n          onClick={handleItemClick}\n        >\n          {item}\n        </li>\n      ))}\n    </ul>\n  );\n}\n```\n这种方式适合参数较少的场景，避免创建额外的函数。\n\n# 4. 注意事项\n1. 合成事件的 `stopPropagation` 方法只能阻止合成事件的冒泡，无法阻止原生事件的冒泡；如果需要阻止原生事件冒泡，需要使用 `e.nativeEvent.stopImmediatePropagation()`。\n2. 避免在事件处理函数中直接修改 `state`，应该使用 `setState`（类组件）或 `setXxx`（函数组件）进行状态更新。\n3. 对于高频触发的事件（如 `onScroll`、`onMouseMove`），可以使用**防抖（debounce）**或**节流（throttle）**优化性能。","directory_id":"763e50ae-d5ad-4770-b985-cb78491214e1","is_published":true,"created_at":"2025-12-19 08:59:29.142825+00","updated_at":"2025-12-19 08:59:29.142825+00"},{"id":"c4af30a0-f1d1-46cd-89e4-f30a84d4f9fc","title":"props校验","content":"# 4. props 校验（PropTypes/TypeScript 接口）\n在多人协作或大型项目中，组件的 `props` 传递可能出现类型错误（如预期传递数字却传了字符串）、必填参数缺失等问题，导致组件运行异常且难以调试。React 支持通过 **PropTypes** 或 **TypeScript 接口** 对 `props` 进行类型校验，提前发现错误，提升代码健壮性。\n\n# 1. PropTypes 校验（JavaScript 项目常用）\nPropTypes 是 React 官方提供的 props 校验库（React 15.5 后需单独安装 `prop-types` 包），支持对 props 的类型、必填项、默认值等进行校验，开发环境下若校验失败，会在控制台输出警告。\n\n## 1.1 安装依赖\n```bash\nnpm install prop-types --save\n# 或 yarn add prop-types\n```\n\n## 1.2 基本使用\n### （1）函数组件校验\n```jsx\nimport PropTypes from 'prop-types';\n\nfunction UserCard(props) {\n  return (\n    <div>\n      <p>姓名：{props.name}</p>\n      <p>年龄：{props.age}</p>\n      <p>性别：{props.gender}</p>\n      <p>技能：{props.skills.join('、')}</p>\n    </div>\n  );\n}\n\n// 定义 props 校验规则\nUserCard.propTypes = {\n  // 姓名：字符串类型，必填（isRequired）\n  name: PropTypes.string.isRequired,\n  // 年龄：数字类型，可选\n  age: PropTypes.number,\n  // 性别：字符串类型，可选，且只能是指定值之一（oneOf）\n  gender: PropTypes.oneOf(['male', 'female', 'other']),\n  // 技能：数组类型，数组元素为字符串（arrayOf）\n  skills: PropTypes.arrayOf(PropTypes.string),\n  // 个人信息：对象类型，指定对象的属性类型（shape）\n  info: PropTypes.shape({\n    address: PropTypes.string,\n    phone: PropTypes.number\n  }),\n  // 回调函数：函数类型（func）\n  onHandle: PropTypes.func,\n  // 任意类型（不推荐，失去校验意义）\n  anyProp: PropTypes.any\n};\n\n// 可选：设置 props 默认值（与校验规则对应）\nUserCard.defaultProps = {\n  age: 18,\n  gender: 'other',\n  skills: [],\n  info: {},\n  onHandle: () => {}\n};\n```\n\n### （2）类组件校验\n```jsx\nimport React from 'react';\nimport PropTypes from 'prop-types';\n\nclass UserCard extends React.Component {\n  render() {\n    const { name, age } = this.props;\n    return (\n      <div>\n        <p>姓名：{name}</p>\n        <p>年龄：{age}</p>\n      </div>\n    );\n  }\n}\n\n// 类组件的 props 校验规则定义方式与函数组件一致\nUserCard.propTypes = {\n  name: PropTypes.string.isRequired,\n  age: PropTypes.number\n};\n\nUserCard.defaultProps = {\n  age: 18\n};\n```\n\n## 1.3 PropTypes 支持的校验类型\n| 校验类型 | 说明 | 示例 |\n|----------|------|------|\n| `PropTypes.string` | 字符串类型 | `name: PropTypes.string` |\n| `PropTypes.number` | 数字类型 | `age: PropTypes.number` |\n| `PropTypes.bool` | 布尔类型 | `isActive: PropTypes.bool` |\n| `PropTypes.func` | 函数类型 | `onClick: PropTypes.func` |\n| `PropTypes.array` | 数组类型 | `list: PropTypes.array` |\n| `PropTypes.object` | 对象类型 | `info: PropTypes.object` |\n| `PropTypes.symbol` | Symbol 类型 | `key: PropTypes.symbol` |\n| `PropTypes.node` | 可渲染节点（字符串、数字、JSX 等） | `children: PropTypes.node` |\n| `PropTypes.element` | React 元素（JSX 组件） | `child: PropTypes.element` |\n| `PropTypes.oneOf([...])` | 枚举类型，值必须是数组中的某一个 | `gender: PropTypes.oneOf(['male', 'female'])` |\n| `PropTypes.oneOfType([...])` | 多种类型之一 | `id: PropTypes.oneOfType([PropTypes.string, PropTypes.number])` |\n| `PropTypes.arrayOf(类型)` | 数组，且元素为指定类型 | `skills: PropTypes.arrayOf(PropTypes.string)` |\n| `PropTypes.objectOf(类型)` | 对象，且属性值为指定类型 | `scores: PropTypes.objectOf(PropTypes.number)` |\n| `PropTypes.shape({...})` | 对象，且指定属性的类型 | `info: PropTypes.shape({ address: PropTypes.string })` |\n| `PropTypes.instanceOf(类)` | 指定类的实例 | `date: PropTypes.instanceOf(Date)` |\n| `PropTypes.isRequired` | 必填项（可搭配任意类型） | `name: PropTypes.string.isRequired` |\n| `PropTypes.any` | 任意类型（不推荐） | `anyProp: PropTypes.any` |\n\n## 1.4 自定义校验规则\n若 PropTypes 内置的校验类型无法满足需求，可自定义校验函数，接收 `props`、`propName`（当前校验的属性名）、`componentName`（组件名）三个参数，校验失败时返回 Error 对象：\n```jsx\nUserCard.propTypes = {\n  // 自定义校验：年龄必须大于 0\n  age: function(props, propName, componentName) {\n    const age = props[propName];\n    if (age <= 0 || typeof age !== 'number') {\n      // 校验失败，返回 Error 警告\n      return new Error(`组件 ${componentName} 的 ${propName} 属性必须是大于 0 的数字`);\n    }\n  },\n  // 自定义数组校验：技能数组长度不能超过 5 个\n  skills: PropTypes.arrayOf(PropTypes.string).isRequired,\n  skills: function(props, propName, componentName) {\n    const skills = props[propName];\n    if (skills.length > 5) {\n      return new Error(`组件 ${componentName} 的 ${propName} 数组长度不能超过 5`);\n    }\n  }\n};\n```\n\n## 1.5 注意事项\n- **仅开发环境生效**：PropTypes 校验仅在开发环境（`process.env.NODE_ENV === 'development'`）输出警告，生产环境会自动移除，不影响性能。\n- **默认值与校验的配合**：`defaultProps` 定义的默认值会覆盖 `isRequired` 校验（即若设置了默认值，即使未传递该 props，也不会触发必填警告）。\n- **不阻止组件渲染**：校验失败仅输出警告，不会阻止组件渲染，需开发者主动修复问题。\n\n# 2. TypeScript 接口校验（TS 项目推荐）\nTypeScript（TS）是 JavaScript 的超集，支持静态类型检查，通过**接口（Interface）** 或**类型别名（Type）** 定义 props 的类型，在编译阶段就能发现类型错误，比 PropTypes 更严格、更强大，是 TS 项目的首选方案。\n\n## 2.1 基本使用（函数组件 + Interface）\n通过 `interface` 定义 props 的类型结构，组件通过泛型 `React.FC<PropsType>` 关联类型，TS 会自动校验 props 的类型和必填项：\n```tsx\nimport React from 'react';\n\n// 定义 props 接口（Interface）\ninterface UserCardProps {\n  name: string; // 字符串类型，必填（未加 ? 表示必填）\n  age?: number; // 数字类型，可选（加 ? 表示可选）\n  gender?: 'male' | 'female' | 'other'; // 枚举类型，可选\n  skills: string[]; // 字符串数组，必填\n  info?: {\n    address: string;\n    phone?: number;\n  }; // 嵌套对象类型，可选\n  onHandle?: () => void; // 函数类型，可选（无参数，无返回值）\n}\n\n// 组件通过泛型 React.FC<UserCardProps> 关联 props 类型\nconst UserCard: React.FC<UserCardProps> = (props) => {\n  // 解构 props，TS 会自动提示属性并校验类型\n  const { name, age = 18, gender = 'other', skills, info } = props;\n\n  return (\n    <div>\n      <p>姓名：{name}</p>\n      <p>年龄：{age}</p>\n      <p>性别：{gender}</p>\n      <p>技能：{skills.join('、')}</p>\n      <p>地址：{info?.address}</p> {/* 可选链操作符，避免 info 为 undefined 报错 */}\n    </div>\n  );\n};\n\n// 可选：设置默认值（与 Interface 可选属性对应）\nUserCard.defaultProps = {\n  age: 18,\n  gender: 'other',\n  info: {}\n};\n\nexport default UserCard;\n```\n\n## 2.2 类组件 + Interface\n类组件通过 `React.Component<PropsType, StateType>` 泛型关联 props 类型：\n```tsx\nimport React from 'react';\n\ninterface UserCardProps {\n  name: string;\n  age?: number;\n}\n\ninterface UserCardState {\n  isExpanded: boolean;\n}\n\n// 类组件泛型：第一个参数是 Props 类型，第二个是 State 类型\nclass UserCard extends React.Component<UserCardProps, UserCardState> {\n  // 初始化状态\n  state: UserCardState = {\n    isExpanded: false\n  };\n\n  render() {\n    const { name, age = 18 } = this.props; // TS 自动校验 this.props 类型\n    return (\n      <div>\n        <p>姓名：{name}</p>\n        <p>年龄：{age}</p>\n      </div>\n    );\n  }\n}\n\nexport default UserCard;\n```\n\n## 2.3 常用 TS 类型与 PropTypes 对应关系\n| PropTypes 类型 | TypeScript 类型 | 示例 |\n|----------------|----------------|------|\n| `PropTypes.string` | `string` | `name: string` |\n| `PropTypes.number` | `number` | `age: number` |\n| `PropTypes.bool` | `boolean` | `isActive: boolean` |\n| `PropTypes.func` | `() => void` / `(param: T) => R` | `onClick: () => void` |\n| `PropTypes.array` | `T[]` / `Array<T>` | `skills: string[]` |\n| `PropTypes.object` | `{ [key: string]: T }` / 接口 | `info: { address: string }` |\n| `PropTypes.oneOf([...])` | 联合类型 `A | B | C` | `gender: 'male' | 'female'` |\n| `PropTypes.oneOfType([...])` | 联合类型 `A | B` | `id: string | number` |\n| `PropTypes.arrayOf(类型)` | `T[]` | `scores: number[]` |\n| `PropTypes.shape({...})` | 接口 `interface` | `info: { phone: number }` |\n| `PropTypes.isRequired` | 未加 `?` 的属性 | `name: string`（必填） |\n| `PropTypes.node` | `React.ReactNode` | `children: React.ReactNode` |\n| `PropTypes.element` | `React.ReactElement` | `child: React.ReactElement` |\n\n## 2.4 高级用法：泛型 Props\n若组件的 props 类型需要动态适配（如列表组件支持不同类型的数据），可使用 TS 泛型定义 props：\n```tsx\nimport React from 'react';\n\n// 泛型接口：T 是动态类型，使用时指定\ninterface ListProps<T> {\n  data: T[]; // 数组元素类型为 T\n  renderItem: (item: T) => React.ReactNode; // 渲染函数，参数类型为 T\n}\n\n// 泛型组件：<T> 表示接收泛型参数\nfunction List<T>({ data, renderItem }: ListProps<T>) {\n  return (\n    <div>\n      {data.map((item, index) => renderItem(item))}\n    </div>\n  );\n}\n\n// 使用组件时，指定泛型类型为 User 接口\ninterface User {\n  id: number;\n  name: string;\n}\n\nfunction App() {\n  const userList: User[] = [\n    { id: 1, name: '张三' },\n    { id: 2, name: '李四' }\n  ];\n\n  return (\n    <List<User>\n      data={userList}\n      renderItem={(item) => <p>姓名：{item.name}</p>} // TS 自动提示 item 的属性\n    </List>\n  );\n}\n```\n\n# 3. PropTypes 与 TypeScript 对比\n| 维度 | PropTypes | TypeScript 接口 |\n|------|-----------|----------------|\n| **校验时机** | 运行时（开发环境控制台警告） | 编译时（编写代码/编译阶段报错） |\n| **严格性** | 宽松，仅警告不阻止运行 | 严格，类型不匹配无法编译通过 |\n| **功能丰富度** | 基础类型校验，支持自定义函数 | 支持泛型、联合类型、交叉类型等复杂场景 |\n| **代码侵入性** | 需额外定义 `propTypes` 属性 | 与组件类型定义融合，无额外冗余 |\n| **学习成本** | 低，API 简单直观 | 高，需掌握 TS 基础语法 |\n| **适用项目** | JavaScript 项目、小型项目 | TypeScript 项目、中大型项目、多人协作项目 |\n\n# 4. 核心总结\n1. **校验目的**：确保 props 类型正确、必填项不缺失，提前发现错误，提升代码健壮性。\n2. **方案选型**：\n   - JavaScript 项目：使用 PropTypes，学习成本低，快速实现基础校验。\n   - TypeScript 项目：使用接口/类型别名，编译时校验，支持复杂场景，推荐优先使用。\n3. **关键注意**：\n   - PropTypes 仅开发环境生效，不影响生产环境性能。\n   - TS 接口需与组件泛型关联，才能实现自动类型提示和校验。\n4. **最佳实践**：无论使用哪种方案，都应明确 props 的类型和必填项，配合默认值使用，减少潜在 bug。...","directory_id":"803ada09-ee46-463c-b7f3-403560bfc20b","is_published":true,"created_at":"2025-12-19 11:07:58.047397+00","updated_at":"2025-12-19 11:07:58.047397+00"},{"id":"cc52365e-6b7a-4d68-8d0e-381c9fc9b173","title":"memo/useMemo/useCallback 实战","content":"`memo`、`useMemo`、`useCallback` 是 React 提供的三大缓存工具，核心目标是**通过缓存避免不必要的重渲染和重复计算**，但滥用会增加内存开销，需精准使用。\n\n# 1. React.memo：组件缓存\n## 1.1 作用\n`React.memo` 是高阶组件（HOC），用于缓存函数组件，让组件仅在 props 发生**浅层对比变化**时重渲染，避免父组件重渲染导致子组件无意义重渲染。\n\n## 1.2 基本用法\n```javascript\nimport { memo } from 'react';\n\n// 子组件：仅在 name/age 变化时重渲染\nconst UserCard = memo(({ name, age }) => {\n  console.log('UserCard 渲染'); // 测试是否重渲染\n  return (\n    <div>\n      <h3>{name}</h3>\n      <p>年龄：{age}</p>\n    </div>\n  );\n});\n\n// 父组件\nfunction Parent() {\n  const [count, setCount] = useState(0);\n  const user = { name: '张三', age: 20 }; // 每次渲染生成新对象\n\n  return (\n    <div>\n      <button onClick={() => setCount(count + 1)}>计数：{count}</button>\n      {/* 问题：父组件重渲染时，user 是新对象 → UserCard 重渲染 */}\n      <UserCard name={user.name} age={user.age} />\n      {/* 优化：直接传递基础类型 props，避免新对象引用 */}\n      {/* <UserCard name=\"张三\" age={20} /> */}\n    </div>\n  );\n}\n```\n\n## 1.3 关键细节\n1. **浅层对比**：`React.memo` 默认对 props 进行浅层对比（基础类型比较值，引用类型比较引用），若 props 包含嵌套对象/数组，浅层对比无法识别内部变化，需自定义对比函数。\n2. **自定义对比函数**：\n   ```javascript\n   const UserCard = memo(({ user }) => {\n     return <div>{user.name}</div>;\n   }, (prevProps, nextProps) => {\n     // 自定义对比逻辑：仅当 user.name 变化时重渲染\n     return prevProps.user.name === nextProps.user.name;\n   });\n   ```\n3. **适用场景**：\n   - 子组件渲染成本高（如包含复杂 DOM 结构、大量计算）；\n   - 父组件频繁重渲染，但子组件 props 很少变化；\n   - 避免：纯展示型轻量组件（缓存开销 > 重渲染开销）。\n\n# 2. useCallback：函数缓存\n## 2.1 作用\n`useCallback` 用于缓存函数引用，避免每次组件渲染生成新的函数实例，从而防止因函数 props 变化触发子组件重渲染（配合 `React.memo` 使用）。\n\n## 2.2 基本用法\n```javascript\nimport { useState, memo, useCallback } from 'react';\n\nconst Button = memo(({ onClick, children }) => {\n  console.log('Button 渲染');\n  return <button onClick={onClick}>{children}</button>;\n});\n\nfunction Parent() {\n  const [count, setCount] = useState(0);\n  const [text, setText] = useState('');\n\n  // 问题：每次渲染生成新函数 → Button 重渲染\n  // const handleClick = () => {\n  //   console.log('点击按钮');\n  // };\n\n  // 优化：用 useCallback 缓存函数，仅依赖项变化时生成新函数\n  const handleClick = useCallback(() => {\n    console.log('点击按钮');\n  }, []); // 空依赖：组件生命周期内函数引用不变\n\n  return (\n    <div>\n      <input value={text} onChange={(e) => setText(e.target.value)} />\n      <Button onClick={handleClick}>点击我</Button>\n    </div>\n  );\n}\n```\n\n## 2.3 关键细节\n1. **依赖项数组**：`useCallback` 第二个参数是依赖项数组，当依赖项变化时，会生成新的函数实例；若依赖项为空数组，函数在组件挂载时生成一次，后续不变。\n2. **配合 React.memo 使用**：`useCallback` 仅在子组件使用 `React.memo` 时才有意义，否则即使缓存函数，子组件仍会因父组件重渲染而重渲染。\n3. **适用场景**：\n   - 函数作为 props 传递给子组件（且子组件用 `React.memo` 缓存）；\n   - 函数作为 `useEffect` 的依赖项（避免每次渲染触发 effect）；\n   - 避免：函数仅在组件内部使用（无需缓存）。\n\n# 3. useMemo：计算结果缓存\n## 3.1 作用\n`useMemo` 用于缓存复杂计算的结果，避免每次组件渲染重复执行昂贵的计算操作，同时可缓存引用类型（对象/数组），防止因新引用触发子组件重渲染。\n\n## 3.2 基本用法（缓存计算结果）\n```javascript\nimport { useState, useMemo } from 'react';\n\nfunction DataList() {\n  const [data, setData] = useState([1, 2, 3, 4, 5]);\n  const [filter, setFilter] = useState(3);\n\n  // 问题：每次渲染执行过滤+排序（昂贵计算）\n  // const filteredData = data.filter(item => item > filter).sort((a, b) => b - a);\n\n  // 优化：用 useMemo 缓存计算结果，仅 filter/data 变化时重新计算\n  const filteredData = useMemo(() => {\n    console.log('执行过滤排序');\n    return data.filter(item => item > filter).sort((a, b) => b - a);\n  }, [data, filter]);\n\n  return (\n    <div>\n      <input\n        type=\"number\"\n        value={filter}\n        onChange={(e) => setFilter(Number(e.target.value))}\n      />\n      <ul>\n        {filteredData.map(item => (\n          <li key={item}>{item}</li>\n        ))}\n      </ul>\n    </div>\n  );\n}\n```\n\n## 3.3 进阶用法（缓存引用类型）\n```javascript\nimport { useState, memo, useMemo } from 'react';\n\nconst UserInfo = memo(({ user }) => {\n  console.log('UserInfo 渲染');\n  return <div>{user.name} - {user.age}</div>;\n});\n\nfunction Parent() {\n  const [count, setCount] = useState(0);\n\n  // 问题：每次渲染生成新对象 → UserInfo 重渲染\n  // const user = { name: '张三', age: 20 };\n\n  // 优化：用 useMemo 缓存对象，引用不变\n  const user = useMemo(() => ({ name: '张三', age: 20 }), []);\n\n  return (\n    <div>\n      <button onClick={() => setCount(count + 1)}>计数：{count}</button>\n      <UserInfo user={user} />\n    </div>\n  );\n}\n```\n\n## 3.4 关键细节\n1. **依赖项数组**：`useMemo` 第二个参数是依赖项数组，仅当依赖项变化时重新计算；若依赖项为空数组，计算结果在组件挂载时生成一次。\n2. **与 useCallback 的区别**：\n   - `useCallback` 缓存函数引用；\n   - `useMemo` 缓存函数执行结果（可是任意类型）。\n3. **适用场景**：\n   - 执行昂贵计算（如大数据集过滤、排序、格式化）；\n   - 缓存引用类型（对象/数组）作为 props 传递给子组件；\n   - 避免：简单计算（如 `a + b`）、基础类型值（缓存开销 > 计算开销）。\n\n# 4. 三大缓存工具的使用原则\n1. **不滥用缓存**：缓存会占用内存，且对比依赖项也有微小开销，仅在确有性能问题时使用；\n2. **精准设置依赖项**：遗漏依赖项会导致缓存结果过期（Bug），多余依赖项会导致缓存失效（失去优化意义）；\n3. **配合使用**：\n   - 子组件用 `React.memo` 缓存；\n   - 传递给子组件的函数用 `useCallback` 缓存；\n   - 传递给子组件的引用类型用 `useMemo` 缓存；\n4. **优先优化代码结构**：拆分组件、减少 props 传递，比缓存更根本的优化方式。","directory_id":"e9432055-c489-48b5-964a-81d34278fc72","is_published":true,"created_at":"2025-12-22 03:15:40.945601+00","updated_at":"2025-12-23 09:43:28.148447+00"},{"id":"cea79b33-f4a1-4b54-8741-2349f1c8d323","title":"列表渲染优化","content":"当渲染**长列表**（如 1000+ 条数据）时，直接渲染所有列表项会导致：\n- 大量 DOM 节点创建，占用内存过高；\n- 虚拟 DOM Diff 算法耗时增加，渲染卡顿；\n- 页面滚动时帧率下降，交互不流畅。\n\n列表渲染优化的核心思路是：**只渲染可视区域内的列表项，动态销毁/创建非可视区域的列表项**，即“虚拟列表”（Virtual List）。\n\n# 1. 虚拟列表的核心原理\n1. **计算可视区域**：根据容器高度、滚动位置，计算当前能看到的列表项范围；\n2. **渲染可视项**：仅渲染可视区域内的列表项，非可视区域用空白占位符填充；\n3. **滚动监听**：监听滚动事件，动态更新可视区域范围，替换列表项内容；\n4. **复用 DOM 节点**：（可选）复用已创建的 DOM 节点，减少创建/销毁开销。\n\n# 2. React Window：轻量级虚拟列表库\n`react-window` 是 React 生态中最流行的虚拟列表库，体积小（~5KB gzip）、性能高，支持固定高度/可变高度列表、网格布局等。\n\n## 2.1 安装\n```bash\nnpm install react-window\n\nyarn add react-window\n```\n\n## 2.2 基础用法（固定高度列表）\n```javascript\nimport { FixedSizeList as List } from 'react-window';\n\n// 模拟 10000 条数据\nconst data = Array.from({ length: 10000 }, (_, index) => `列表项 ${index + 1}`);\n\n// 列表项组件\nconst Row = ({ index, style }) => {\n  // style 必须传递给根元素（用于定位）\n  return (\n    <div style={style}>\n      {data[index]}\n    </div>\n  );\n};\n\nfunction LongList() {\n  return (\n    // height：容器高度；width：容器宽度；itemCount：总项数；itemSize：每项高度\n    <List\n      height={500}\n      width=\"100%\"\n      itemCount={data.length}\n      itemSize={50} // 每项固定高度 50px\n    >\n      {Row}\n    </List>\n  );\n}\n```\n\n## 2.3 进阶用法（可变高度列表）\n若列表项高度不固定，使用 `VariableSizeList`：\n```javascript\nimport { VariableSizeList as List } from 'react-window';\n\n// 模拟可变高度数据（高度随机 30-100px）\nconst data = Array.from({ length: 10000 }, (_, index) => ({\n  text: `列表项 ${index + 1}`,\n  height: 30 + Math.floor(Math.random() * 70)\n}));\n\n// 获取每项高度\nconst getItemSize = (index) => data[index].height;\n\nconst Row = ({ index, style }) => {\n  return (\n    <div style={style}>\n      {data[index].text}（高度：{data[index].height}px）\n    </div>\n  );\n};\n\nfunction VariableHeightList() {\n  return (\n    <List\n      height={500}\n      width=\"100%\"\n      itemCount={data.length}\n      itemSize={getItemSize} // 动态获取每项高度\n    >\n      {Row}\n    </List>\n  );\n}\n```\n\n## 2.4 关键属性\n| 属性 | 作用 |\n|------|------|\n| `height` | 列表容器高度（必填）|\n| `width` | 列表容器宽度（必填）|\n| `itemCount` | 列表总项数（必填）|\n| `itemSize` | 每项高度（固定高度列表）或返回高度的函数（可变高度列表）|\n| `overscanCount` | 预渲染可视区域外的项数（默认 1，增加可减少滚动时的空白闪烁）|\n| `onScroll` | 滚动事件回调（可获取滚动位置、可视区域范围）|\n\n# 3. React Virtualized：功能更全的虚拟列表库\n`react-virtualized` 是 `react-window` 的前身，功能更丰富（支持表格、网格、瀑布流），但体积更大（~30KB gzip），适合复杂场景。\n\n## 3.1 安装\n```bash\nnpm install react-virtualized\n\nyarn add react-virtualized\n```\n\n## 3.2 基础用法（List 组件）\n```javascript\nimport { List, AutoSizer } from 'react-virtualized';\nimport 'react-virtualized/styles.css'; // 引入样式\n\nconst data = Array.from({ length: 10000 }, (_, index) => `列表项 ${index + 1}`);\n\nconst rowRenderer = ({ index, key, style }) => {\n  return (\n    <div key={key} style={style}>\n      {data[index]}\n    </div>\n  );\n};\n\nfunction LongList() {\n  return (\n    // AutoSizer：自动适配父容器尺寸\n    <AutoSizer>\n      {({ height, width }) => (\n        <List\n          height={height}\n          width={width}\n          rowCount={data.length}\n          rowHeight={50}\n          rowRenderer={rowRenderer}\n        />\n      )}\n    </AutoSizer>\n  );\n}\n```\n\n## 3.3 瀑布流布局（Masonry 组件）\n```javascript\nimport { Masonry, AutoSizer } from 'react-virtualized';\nimport 'react-virtualized/styles.css';\n\n// 模拟瀑布流数据（宽度固定，高度随机）\nconst data = Array.from({ length: 100 }, (_, index) => ({\n  id: index,\n  height: 100 + Math.floor(Math.random() * 200)\n}));\n\nconst cellRenderer = ({ index, key, style }) => {\n  const item = data[index];\n  return (\n    <div key={key} style={{ ...style, backgroundColor: '#f0f0f0', margin: '5px' }}>\n      瀑布流项 {item.id}（高度：{item.height}px）\n    </div>\n  );\n};\n\nfunction MasonryLayout() {\n  return (\n    <div style={{ height: 800 }}>\n      <AutoSizer>\n        {({ width }) => (\n          <Masonry\n            width={width}\n            height={800}\n            columnCount={3} // 列数\n            columnWidth={width / 3 - 10} // 列宽度（减去间距）\n            cellCount={data.length}\n            cellMeasurerCache={{\n              defaultHeight: 150,\n              defaultWidth: width / 3 - 10\n            }}\n            cellRenderer={cellRenderer}\n          />\n        )}\n      </AutoSizer>\n    </div>\n  );\n}\n```\n\n# 4. 列表渲染优化的其他策略\n1. **分页加载**：若无需滚动加载，可采用分页（每页渲染 20-50 条），减少单次渲染数量；\n2. **数据预加载**：滚动到列表底部时，提前加载下一页数据，避免用户等待；\n3. **列表项缓存**：用 `React.memo` 缓存列表项组件，避免因列表重渲染导致项组件无意义重渲染；\n4. **避免复杂列表项**：简化列表项 DOM 结构，减少项组件内的计算操作；\n5. **图片懒加载**：列表项中的图片使用 `loading=\"lazy\"` 或第三方懒加载库（如 `react-lazyload`），减少首屏加载时间。\n\n# 5. react-window vs react-virtualized\n| 特性 | react-window | react-virtualized |\n|------|--------------|-------------------|\n| 体积 | 极小（~5KB） | 较大（~30KB）|\n| 功能 | 基础（列表、网格） | 丰富（列表、表格、瀑布流、日历） |\n| 性能 | 高（专注核心场景） | 中（功能多导致开销增加） |\n| 易用性 | 简单（API 简洁） | 复杂（配置项多） |\n| 适用场景 | 简单长列表、移动端 | 复杂布局（表格、瀑布流）、PC 端 |","directory_id":"e9432055-c489-48b5-964a-81d34278fc72","is_published":true,"created_at":"2025-12-22 03:15:52.550016+00","updated_at":"2025-12-23 09:47:25.549385+00"},{"id":"d707298e-f817-4b74-9ce2-db6019393a7a","title":"懒加载路由","content":"默认情况下，React 项目打包后会将所有组件代码合并到一个或几个 bundle 文件中——当项目体积较大时，首屏加载时间会变长，影响用户体验。**路由懒加载**（也叫“代码分割”）的核心思想是：将不同路由对应的组件拆分成独立的代码块，只有当用户访问该路由时，才加载对应的代码块，从而减小首屏加载体积，提升加载速度。\n\nReact 中实现路由懒加载的核心工具是：\n- `React.lazy`：动态导入组件（返回一个 Promise），实现组件的懒加载；\n- `Suspense`：配合 `React.lazy` 使用，在懒加载组件加载完成前显示加载占位符（如加载动画、文字）。\n\n# 1. 基本使用步骤\n## 1.1 导入核心 API\n```jsx\nimport { BrowserRouter, Routes, Route } from 'react-router-dom';\nimport { lazy, Suspense } from 'react';\n```\n\n## 1.2 用 `React.lazy` 动态导入路由组件\n替换传统的 `import` 导入方式，改用 `lazy` 包裹动态导入函数：\n```jsx\n// 传统导入（打包时合并到主 bundle）\n// import Home from './pages/Home';\n// import About from './pages/About';\n// import Dashboard from './pages/Dashboard';\n\n// 懒加载导入（拆分为独立代码块）\nconst Home = lazy(() => import('./pages/Home'));\nconst About = lazy(() => import('./pages/About'));\nconst Dashboard = lazy(() => import('./pages/Dashboard'));\n```\n\n## 1.3 用 `Suspense` 包裹路由组件\n`Suspense` 必须包裹懒加载组件，用于指定加载过程中的占位内容（`fallback` 属性）：\n```jsx\nfunction App() {\n  return (\n    <BrowserRouter>\n      {/* Suspense 包裹所有懒加载路由组件，fallback 为加载占位符 */}\n      <Suspense fallback={<div>Loading...</div>}>\n        <Routes>\n          <Route path=\"/\" element={<Home />} />\n          <Route path=\"/about\" element={<About />} />\n          <Route path=\"/dashboard\" element={<Dashboard />} />\n        </Routes>\n      </Suspense>\n    </BrowserRouter>\n  );\n}\n```\n\n# 2. 进阶优化\n## 2.1 分路由配置 `Suspense`\n若希望不同路由使用不同的加载占位符，可给每个路由单独配置 `Suspense`：\n```jsx\nfunction App() {\n  return (\n    <BrowserRouter>\n      <Routes>\n        <Route path=\"/\" element={<Home />} />\n        <Route \n          path=\"/about\" \n          element={\n            <Suspense fallback={<div>正在加载关于页面...</div>}>\n              <About />\n            </Suspense>\n          } \n        />\n        <Route \n          path=\"/dashboard\" \n          element={\n            <Suspense fallback={<div>后台数据加载中...</div>}>\n              <Dashboard />\n            </Suspense>\n          } \n        />\n      </Routes>\n    </BrowserRouter>\n  );\n}\n```\n\n## 2.2 加载错误处理\n懒加载组件可能因网络问题加载失败，需配合错误边界（Error Boundary）捕获错误：\n```jsx\n// 定义错误边界组件\nclass ErrorBoundary extends React.Component {\n  state = { hasError: false };\n\n  static getDerivedStateFromError() {\n    return { hasError: true };\n  }\n\n  componentDidCatch(error) {\n    console.error('组件加载失败：', error);\n  }\n\n  render() {\n    if (this.state.hasError) {\n      return <div>页面加载失败，请刷新重试～</div>;\n    }\n    return this.props.children;\n  }\n}\n\n// 使用错误边界包裹懒加载组件\n<Route \n  path=\"/dashboard\" \n  element={\n    <ErrorBoundary>\n      <Suspense fallback={<div>加载中...</div>}>\n        <Dashboard />\n      </Suspense>\n    </ErrorBoundary>\n  } \n/>\n```\n\n## 2.3 预加载组件（可选）\n若预判用户可能会访问某个路由（如鼠标悬停在导航链接上时），可手动触发组件预加载，提升后续访问速度：\n```jsx\n// 预加载 About 组件的函数\nconst preloadAbout = () => {\n  import('./pages/About');\n};\n\n// 导航链接中添加预加载逻辑\n<Link to=\"/about\" onMouseEnter={preloadAbout}>关于我们</Link>\n```\n\n# 3. 关键注意事项\n1. **`React.lazy` 仅支持默认导出**：若组件使用命名导出，需在动态导入时手动指定默认导出：\n   ```jsx\n   // 若 About 组件是命名导出：export const About = () => {...}\n   const About = lazy(() => import('./pages/About').then(module => ({ default: module.About })));\n   ```\n2. **服务端渲染限制**：`React.lazy` 和 `Suspense` 仅支持客户端渲染（CSR），若项目使用服务端渲染（SSR），需使用 `loadable-components` 等第三方库替代。\n3. **代码分割的粒度**：避免将过小的组件拆分为独立代码块（会增加网络请求次数），建议按路由级别进行分割（一个路由对应一个代码块）。\n4. **fallback 内容设计**：占位符应简洁（如加载动画、文字），避免使用复杂组件（防止占位符本身加载耗时）。\n\n# 4. 懒加载的优势\n- 减小首屏 bundle 体积，提升首屏加载速度；\n- 按需加载代码，节省用户流量（仅加载访问到的内容）；\n- 降低服务器初始请求压力；\n- 配合预加载策略，可兼顾首屏速度和后续页面加载速度。","directory_id":"77b830a2-38dc-41a0-8e20-9f29ffc5a332","is_published":true,"created_at":"2025-12-22 02:12:15.583964+00","updated_at":"2025-12-23 02:53:33.20914+00"},{"id":"e279e2e5-ea25-4766-8385-f56b5406c099","title":"useCallback：缓存回调函数","content":"`useCallback` 是 React 中用于**缓存回调函数**的 Hook，核心作用是优化组件性能：避免因回调函数重新创建导致子组件不必要的重渲染。在 React 中，函数组件每次渲染时，内部定义的函数都会重新创建（生成新的引用），若将该函数作为 props 传递给子组件，即使子组件使用 `React.memo` 优化，也会因引用变化触发重渲染。`useCallback` 通过缓存函数引用，解决这一问题。\n\n# 1. useCallback 核心原理与问题背景\n## 1.1 问题背景：函数引用变化导致的重渲染\n函数组件每次渲染时，内部的函数会重新创建（引用不同），例如：\n```jsx\nimport { useState, memo } from 'react';\n\n// 子组件：使用 React.memo 优化，仅 props 变化时重渲染\nconst Child = memo(({ onClick }) => {\n  console.log('Child 组件重渲染');\n  return <button onClick={onClick}>子组件按钮</button>;\n});\n\nfunction Parent() {\n  const [count, setCount] = useState(0);\n\n  // 每次 Parent 渲染，都会创建新的 handleClick 函数（引用不同）\n  const handleClick = () => {\n    console.log('按钮点击');\n  };\n\n  return (\n    <div>\n      <p>count：{count}</p>\n      <button onClick={() => setCount(prev => prev + 1)}>+1</button>\n      {/* 每次 Parent 渲染，onClick 传递的函数引用不同，导致 Child 重渲染 */}\n      <Child onClick={handleClick} />\n    </div>\n  );\n}\n```\n上述代码中，点击“+1”按钮会触发 `Parent` 组件重渲染，`handleClick` 函数重新创建（引用变化），即使 `Child` 组件使用 `React.memo`，也会因 `onClick` props 变化而重渲染（但子组件的功能完全不需要依赖 `count` 状态），造成性能浪费。\n\n## 1.2 useCallback 核心原理\n`useCallback` 接收两个参数：\n- 第一个参数：需要缓存的回调函数。\n- 第二个参数：依赖项数组（与 `useEffect` 一致）。\n\n返回值：缓存的函数引用（仅当依赖项变化时，才会返回新的函数引用；依赖项不变时，始终返回同一个函数引用）。\n\n## 1.3 基本语法\n```jsx\nimport { useCallback } from 'react';\n\nconst cachedFunction = useCallback(() => {\n  // 回调函数逻辑\n  doSomething(dep1, dep2);\n}, [dep1, dep2]); // 依赖项数组\n```\n\n# 2. useCallback 基础用法：解决不必要的重渲染\n## 2.1 优化上述示例\n使用 `useCallback` 缓存 `handleClick` 函数，仅当依赖项变化时才重新创建：\n```jsx\nimport { useState, memo, useCallback } from 'react';\n\nconst Child = memo(({ onClick }) => {\n  console.log('Child 组件重渲染');\n  return <button onClick={onClick}>子组件按钮</button>;\n});\n\nfunction Parent() {\n  const [count, setCount] = useState(0);\n\n  // 使用 useCallback 缓存函数，依赖项为空数组（无依赖）\n  const handleClick = useCallback(() => {\n    console.log('按钮点击');\n  }, []); // 依赖项为空，函数引用永久缓存\n\n  return (\n    <div>\n      <p>count：{count}</p>\n      <button onClick={() => setCount(prev => prev + 1)}>+1</button>\n      {/* 传递缓存的函数引用，Child 组件不会因 Parent 重渲染而重渲染 */}\n      <Child onClick={handleClick} />\n    </div>\n  );\n}\n```\n优化后，点击“+1”按钮时，`Parent` 组件重渲染，但 `handleClick` 函数引用不变，`Child` 组件不会重渲染，仅在首次渲染时执行一次。\n\n## 2.2 带依赖项的 useCallback\n若回调函数依赖于组件的 state 或 props，需将依赖项加入数组，确保函数能获取最新值：\n```jsx\nfunction Parent() {\n  const [count, setCount] = useState(0);\n\n  // 回调函数依赖 count，需加入依赖项数组\n  const handleClick = useCallback(() => {\n    console.log('当前 count：', count);\n  }, [count]); // count 变化时，重新创建函数\n\n  return <Child onClick={handleClick} />;\n}\n```\n此时，仅当 `count` 变化时，`handleClick` 函数引用才会更新，`Child` 组件才会重渲染（符合预期）。\n\n# 3. useCallback 的适用场景\n## 场景1：传递给 memo 包装的子组件的回调函数\n这是 `useCallback` 最核心的适用场景：子组件使用 `React.memo` 优化，且接收的 props 包含回调函数时，用 `useCallback` 缓存回调函数，避免子组件不必要的重渲染。\n\n## 场景2：作为 useEffect/useLayoutEffect 的依赖项\n若回调函数作为 `useEffect` 的依赖项，使用 `useCallback` 缓存函数，可避免因函数引用变化导致 `useEffect` 频繁执行：\n```jsx\nfunction MyComponent({ id }) {\n  // 缓存回调函数\n  const fetchData = useCallback(async () => {\n    const res = await fetch(`/api/data/${id}`);\n    const data = await res.json();\n    setData(data);\n  }, [id]); // 依赖 id\n\n  // 仅当 fetchData 引用变化时（即 id 变化），执行 useEffect\n  useEffect(() => {\n    fetchData();\n  }, [fetchData]); // 依赖缓存的函数\n\n  // ...\n}\n```\n\n## 场景3：作为自定义 Hook 的参数\n自定义 Hook 若接收回调函数作为参数，使用 `useCallback` 缓存后传递，可避免自定义 Hook 内部不必要的逻辑执行：\n```jsx\n// 自定义 Hook：useEventListener\nfunction useEventListener(eventName, handler, element = window) {\n  // 缓存 handler，避免每次渲染重新添加监听\n  const cachedHandler = useCallback(handler, [handler]);\n\n  useEffect(() => {\n    const isSupported = element && element.addEventListener;\n    if (!isSupported) return;\n\n    element.addEventListener(eventName, cachedHandler);\n    return () => {\n      element.removeEventListener(eventName, cachedHandler);\n    };\n  }, [eventName, element, cachedHandler]);\n}\n\n// 组件中使用\nfunction MyComponent() {\n  // 缓存回调函数，传递给自定义 Hook\n  const handleResize = useCallback(() => {\n    console.log('窗口尺寸变化');\n  }, []);\n\n  useEventListener('resize', handleResize);\n  // ...\n}\n```\n\n# 4. useCallback 的使用误区\n## 误区1：滥用 useCallback（任何回调都缓存）\n`useCallback` 本身有性能开销（需要维护缓存、对比依赖项），若回调函数不传递给子组件、也不作为 useEffect 依赖项，使用 `useCallback` 反而会增加性能负担：\n```jsx\n// 错误示例：不必要的 useCallback\nfunction MyComponent() {\n  // 回调函数仅在组件内部使用，无需缓存\n  const handleClick = useCallback(() => {\n    console.log('内部按钮点击');\n  }, []);\n\n  return <button onClick={handleClick}>内部按钮</button>;\n}\n```\n\n## 误区2：依赖项缺失\n若回调函数使用了 state/props，但未加入依赖项数组，会导致函数捕获旧值（闭包陷阱）：\n```jsx\n// 错误示例：依赖项缺失\nfunction MyComponent() {\n  const [count, setCount] = useState(0);\n\n  const handleClick = useCallback(() => {\n    console.log('count：', count); // 始终输出初始值 0\n  }, []); // 缺失 count 依赖\n\n  return (\n    <div>\n      <button onClick={() => setCount(prev => prev + 1)}>+1</button>\n      <button onClick={handleClick}>打印 count</button>\n    </div>\n  );\n}\n```\n\n## 误区3：忽略子组件的 React.memo\n若子组件未使用 `React.memo` 优化，即使使用 `useCallback` 缓存回调函数，子组件仍会随父组件重渲染（`useCallback` 失去意义）：\n```jsx\n// 错误示例：子组件未使用 memo\nconst Child = ({ onClick }) => {\n  console.log('Child 重渲染');\n  return <button onClick={onClick}>子组件按钮</button>;\n};\n\nfunction Parent() {\n  const handleClick = useCallback(() => {}, []);\n  return <Child onClick={handleClick} />; // 子组件仍会重渲染\n}\n```\n\n# 5. useCallback 与 useMemo 的关系\n## 5.1 相似点\n- 均用于性能优化，通过缓存减少不必要的计算/重渲染。\n- 均接收依赖项数组，仅当依赖项变化时更新缓存。\n- 均在组件渲染时执行（同步）。\n\n## 5.2 区别\n| 特性         | useCallback                      | useMemo                            |\n|--------------|---------------------------------|------------------------------------|\n| 缓存内容     | 函数引用                        | 函数执行结果                      |\n| 返回值       | 缓存的函数（需调用才执行）| 缓存的计算结果（直接使用）|\n| 适用场景     | 缓存回调函数（传递给子组件/依赖项） | 缓存复杂计算结果（避免重复计算）|\n| 语法         | `useCallback(fn, deps)`         | `useMemo(() => fn(), deps)`        |\n\n## 5.3 等价关系\n`useCallback(fn, deps)` 等价于 `useMemo(() => fn, deps)`：\n```jsx\n// 两者完全等价\nconst cachedFn1 = useCallback(() => { /* ... */ }, [dep]);\nconst cachedFn2 = useMemo(() => () => { /* ... */ }, [dep]);\n```\n\n# 6. useCallback 最佳实践\n## 6.1 仅在必要时使用\n遵循“按需使用”原则：\n- 回调函数传递给 `memo` 包装的子组件 → 使用 `useCallback`。\n- 回调函数作为 `useEffect`/`useLayoutEffect` 的依赖项 → 使用 `useCallback`。\n- 其他场景（如组件内部使用的回调）→ 无需使用。\n\n## 6.2 正确设置依赖项\n- 回调函数中使用的所有 state/props/变量，必须加入依赖项数组。\n- 依赖项数组为空 → 函数永久缓存（仅创建一次）。\n- 可使用 ESLint 规则 `react-hooks/exhaustive-deps` 检查依赖项是否完整。\n\n## 6.3 结合 React.memo 使用\n`useCallback` 必须与 `React.memo`（或 `PureComponent`）配合使用，否则无法实现性能优化。\n\n## 6.4 避免缓存过于复杂的函数\n`useCallback` 适合缓存简单回调函数，若函数内部逻辑复杂，建议拆分逻辑（如抽离为独立函数），避免缓存大函数带来的额外开销。\n\n# 7. 核心总结\n1. **核心作用**：缓存回调函数引用，避免因函数重新创建导致的子组件不必要重渲染或 useEffect 频繁执行。\n2. **使用条件**：\n   - 回调函数作为 props 传递给 `memo` 包装的子组件。\n   - 回调函数作为 `useEffect`/`useLayoutEffect` 的依赖项。\n3. **关键语法**：`useCallback(fn, deps)`，依赖项必须包含函数内使用的所有变量。\n4. **使用误区**：\n   - 滥用 `useCallback`（内部回调无需缓存）。\n   - 依赖项缺失导致闭包陷阱。\n   - 未配合 `React.memo` 使用。\n5. **性能优化逻辑**：\n   - 父组件重渲染 → 缓存的函数引用不变 → 子组件 props 不变 → 子组件不重渲染。...","directory_id":"aac29662-babe-4c96-8f61-0a16830155d4","is_published":true,"created_at":"2025-12-19 15:16:32.190039+00","updated_at":"2025-12-22 02:34:34.659078+00"},{"id":"eba401ab-10dd-4f15-b870-357491915f78","title":"Vite 搭建 React 项目","content":"# 1. Vite 核心特性与优势\nVite 是由尤雨溪开发的新一代前端构建工具，采用“按需编译”+“原生 ES 模块”的设计理念，核心优势体现在：\n- **极速开发启动**：开发环境下无需打包，直接通过浏览器原生 ES 模块加载代码，启动时间通常在毫秒级（对比 CRA 的数十秒启动）；\n- **热更新（HMR）高效**：仅更新修改的模块，而非全量刷新，大型项目中热更新速度远超传统打包工具；\n- **开箱即用的优化**：内置对 TypeScript、JSX、CSS 预处理器的支持，无需额外配置；\n- **生产环境优化**：基于 Rollup 打包，默认开启 Tree Shaking、代码分割、压缩等优化，打包体积更小。\n\n# 2. Vite 搭建 React 项目步骤\n## 2.1 初始化项目\n确保已安装 Node.js（版本 ≥ 14.18.0），执行以下命令：\n```bash\nnpm create vite@latest my-react-vite-project -- --template react\n\nyarn create vite my-react-vite-project --template react\n\npnpm create vite my-react-vite-project -- --template react\n```\n- `--template react`：指定 React 模板（如需 TypeScript，使用 `react-ts` 模板）；\n- 进入项目目录并安装依赖：\n```bash\ncd my-react-vite-project\nnpm install # 或 yarn / pnpm install\n```\n\n## 2.2 启动开发服务器\n```bash\nnpm run dev # 开发环境\nnpm run build # 生产打包\nnpm run preview # 预览打包后的项目\n```\n\n# 3. Vite vs CRA（Create React App）核心对比\n| 维度                | Vite                          | CRA（基于 Webpack）|\n|---------------------|-------------------------------|---------------------------------|\n| 启动速度            | 毫秒级（无需打包）| 数十秒（全量打包）|\n| 热更新速度          | 即时更新（仅修改模块）| 随项目体积增大变慢              |\n| 配置灵活性          | 支持通过 `vite.config.js` 自定义，配置简洁 | 需 eject 或使用 react-app-rewired 才能修改底层配置，配置复杂 |\n| 内置功能            | 原生支持 TS、JSX、CSS 预处理器、静态资源 | 需手动安装插件支持 CSS 预处理器等 |\n| 生产打包工具        | Rollup（更适合库/应用打包）| Webpack                        |\n| 生态兼容性          | 兼容大部分 Webpack 插件（需适配）| 生态成熟，插件丰富              |\n| 适用场景            | 中小型 React 项目、快速迭代开发 | 大型复杂项目、依赖 Webpack 生态  |\n\n# 4. Vite 项目配置优化\nVite 配置文件为项目根目录的 `vite.config.js`（或 `vite.config.ts`），核心优化项如下：\n\n## 4.1 基础配置（端口、代理、别名）\n```javascript\nimport { defineConfig } from 'vite';\nimport react from '@vitejs/plugin-react';\nimport path from 'path';\n\nexport default defineConfig({\n  // 插件\n  plugins: [react()],\n  // 开发服务器配置\n  server: {\n    port: 3000, // 自定义端口\n    open: true, // 启动后自动打开浏览器\n    proxy: {\n      // 接口代理（解决跨域）\n      '/api': {\n        target: 'http://localhost:8080',\n        changeOrigin: true,\n        rewrite: (path) => path.replace(/^\\/api/, ''),\n      },\n    },\n  },\n  // 路径别名（简化导入）\n  resolve: {\n    alias: {\n      '@': path.resolve(__dirname, 'src'), // 用 @ 代替 src 目录\n    },\n  },\n  // 生产环境构建配置\n  build: {\n    outDir: 'dist', // 打包输出目录\n    sourcemap: false, // 关闭生产环境 sourcemap（减小体积）\n    rollupOptions: {\n      // 代码分割优化\n      output: {\n        chunkFileNames: 'js/[name]-[hash].js',\n        entryFileNames: 'js/[name]-[hash].js',\n        assetFileNames: '[ext]/[name]-[hash].[ext]',\n      },\n    },\n  },\n});\n```\n\n## 4.2 CSS 优化（预处理器、模块化）\n- 安装 CSS 预处理器（如 Sass）：\n```bash\nnpm install -D sass\n```\n- 开启 CSS 模块化与自动导入：\n```javascript\n// vite.config.js\nexport default defineConfig({\n  css: {\n    modules: {\n      localsConvention: 'camelCaseOnly', // 类名转为驼峰命名\n    },\n    preprocessorOptions: {\n      scss: {\n        additionalData: '@import \"@/styles/variables.scss\";', // 全局导入变量\n      },\n    },\n  },\n});\n```\n\n## 4.3 依赖预构建优化\nVite 会预构建第三方依赖（如 React、Antd），可通过 `optimizeDeps` 配置：\n```javascript\nexport default defineConfig({\n  optimizeDeps: {\n    include: ['react', 'react-dom', 'antd'], // 指定预构建依赖\n    exclude: ['some-package'], // 排除无需预构建的依赖\n  },\n});\n```\n\n# 5. 常见问题解决\n- **兼容性问题**：Vite 依赖原生 ES 模块，低版本浏览器需安装 `@vitejs/plugin-legacy` 插件；\n- **第三方库兼容**：部分非 ES 模块的库需通过 `optimizeDeps` 预构建；\n- **打包体积过大**：开启 `build.rollupOptions.output.manualChunks` 手动分割代码。","directory_id":"d8343213-03f7-4f4f-b6e3-6926e0f500a1","is_published":true,"created_at":"2025-12-22 03:19:26.871848+00","updated_at":"2025-12-23 13:17:03.180012+00"},{"id":"ec51e174-f9b8-4912-a4de-2db39020706e","title":"ESLint + Prettier 统一代码规范","content":"# 1. 核心价值与分工\n在多人协作的 React 项目中，代码规范工具能解决以下问题：\n- 避免语法错误、潜在 bug（如未定义变量、无效类型转换）；\n- 统一代码风格（缩进、引号、分号等），降低维护成本；\n- 强制遵循最佳实践（如 React 组件命名、Hook 使用规则）。\n\n工具分工：\n- **ESLint**：聚焦代码质量（语法正确性、逻辑合理性、最佳实践），支持自定义规则；\n- **Prettier**：聚焦代码格式（缩进、换行、引号），无代码质量检查，格式化能力更强；\n- 两者结合：ESLint 管“对不对”，Prettier 管“好不好看”。\n\n# 2. 环境搭建\n## 2.1 安装核心依赖\n```bash\nnpm install -D eslint prettier\n\nnpm install -D eslint-config-prettier eslint-plugin-prettier\n\nnpm install -D eslint-plugin-react eslint-plugin-react-hooks eslint-plugin-react-refresh\n\nnpm install -D @typescript-eslint/eslint-plugin @typescript-eslint/parser\n```\n\n## 2.2 配置文件创建\n### 2.2.1 ESLint 配置（.eslintrc.js / .eslintrc.json）\n```javascript\n// .eslintrc.js\nmodule.exports = {\n  // 环境：浏览器 + Node + ES2022 + React 18\n  env: {\n    browser: true,\n    es2022: true,\n    node: true,\n  },\n  // 解析器：TS 项目用 @typescript-eslint/parser，JS 项目用默认 espree\n  parser: '@typescript-eslint/parser',\n  // 解析器选项\n  parserOptions: {\n    ecmaVersion: 'latest',\n    sourceType: 'module',\n    ecmaFeatures: {\n      jsx: true, // 支持 JSX\n    },\n  },\n  // 插件\n  plugins: [\n    'react',\n    'react-hooks',\n    'react-refresh',\n    '@typescript-eslint',\n    'prettier',\n  ],\n  // 规则集（继承顺序：后序覆盖前序）\n  extends: [\n    'eslint:recommended', // ESLint 内置推荐规则\n    'plugin:@typescript-eslint/recommended', // TS 推荐规则\n    'plugin:react/recommended', // React 推荐规则\n    'plugin:react-hooks/recommended', // React Hooks 规则\n    'plugin:prettier/recommended', // Prettier 集成（开启 prettier 规则，禁用 ESLint 格式规则）\n    'prettier', // 禁用所有与 Prettier 冲突的 ESLint 规则\n  ],\n  // 自定义规则\n  rules: {\n    // React 相关\n    'react/react-in-jsx-scope': 'off', // React 17+ 无需导入 React\n    'react/prop-types': 'off', // TS 项目用类型定义替代 PropTypes\n    'react-refresh/only-export-components': 'warn', // 仅导出组件（避免热更新失效）\n    // React Hooks 强制规则\n    'react-hooks/rules-of-hooks': 'error', // 检查 Hooks 使用规则\n    'react-hooks/exhaustive-deps': 'warn', // 检查依赖数组完整性\n    // TS 相关\n    '@typescript-eslint/no-unused-vars': ['error', { argsIgnorePattern: '^_' }], // 未使用变量报错（忽略下划线开头参数）\n    '@typescript-eslint/no-explicit-any': 'warn', // 避免使用 any 类型\n    // Prettier 相关\n    'prettier/prettier': 'error', // Prettier 格式化错误视为 ESLint 错误\n    // 通用规则\n    'no-console': process.env.NODE_ENV === 'production' ? 'error' : 'warn', // 生产环境禁止 console\n    'no-debugger': process.env.NODE_ENV === 'production' ? 'error' : 'off', // 生产环境禁止 debugger\n  },\n  // 全局变量\n  globals: {\n    React: 'readonly',\n  },\n  // React 版本自动检测\n  settings: {\n    react: {\n      version: 'detect',\n    },\n  },\n};\n```\n\n### 2.2.2 Prettier 配置（.prettierrc.js / .prettierrc）\n```javascript\n// .prettierrc.js\nmodule.exports = {\n  printWidth: 100, // 每行最大字符数\n  tabWidth: 2, // 缩进空格数\n  useTabs: false, // 使用空格而非制表符\n  singleQuote: true, // 使用单引号\n  semi: true, // 语句末尾加分号\n  trailingComma: 'es5', // 多行对象/数组最后一个元素加逗号（ES5 兼容）\n  bracketSpacing: true, // 对象字面量括号两侧加空格（{ foo: bar }）\n  arrowParens: 'avoid', // 箭头函数单个参数省略括号\n  endOfLine: 'lf', // 换行符使用 LF\n  jsxSingleQuote: true, // JSX 中使用单引号\n  bracketSameLine: false, // JSX 标签闭合括号换行\n};\n```\n\n### 2.2.3 忽略文件（.eslintignore / .prettierignore）\n```\n# .eslintignore & .prettierignore 通用内容\nnode_modules/\ndist/\nbuild/\ncoverage/\n*.config.js\n*.d.ts\npublic/\n```\n\n### 2.2.4 package.json 脚本配置\n```json\n{\n  \"scripts\": {\n    \"lint\": \"eslint . --ext .js,.jsx,.ts,.tsx\", // 检查代码\n    \"lint:fix\": \"eslint . --ext .js,.jsx,.ts,.tsx --fix\", // 自动修复可修复问题\n    \"format\": \"prettier --write \\\"**/*.{js,jsx,ts,tsx,json,css,md}\\\"\" // 格式化所有文件\n  }\n}\n```\n\n# 3. 关键规则说明\n## 3.1 React 核心规则\n| 规则 | 作用 | 推荐配置 |\n|------|------|----------|\n| `react/react-in-jsx-scope` | 强制 JSX 文件导入 React | React 17+ 设为 `off` |\n| `react-hooks/rules-of-hooks` | 强制 Hooks 只能在组件/自定义 Hooks 中调用 | `error` |\n| `react-hooks/exhaustive-deps` | 检查 useEffect 等 Hooks 依赖数组完整性 | `warn` |\n| `react-refresh/only-export-components` | 避免组件文件导出非组件内容（影响热更新） | `warn` |\n\n## 3.2 Prettier 核心规则\n| 规则 | 作用 | 团队协作建议 |\n|------|------|--------------|\n| `singleQuote` | 单引号/双引号 | 统一设为 `true`（JS 生态更常用单引号） |\n| `trailingComma` | 多行末尾逗号 | 设为 `es5`（兼容旧环境，避免语法错误） |\n| `printWidth` | 每行最大字符数 | 设为 80/100（根据团队习惯） |\n\n# 4. 编辑器集成（VS Code）\n1. 安装插件：ESLint、Prettier - Code formatter；\n2. 配置 settings.json（用户/工作区）：\n   ```json\n   {\n     \"editor.formatOnSave\": true, // 保存时自动格式化\n     \"editor.defaultFormatter\": \"esbenp.prettier-vscode\", // 默认格式化工具为 Prettier\n     \"editor.codeActionsOnSave\": {\n       \"source.fixAll.eslint\": true // 保存时自动修复 ESLint 问题\n     },\n     \"eslint.validate\": [\"javascript\", \"javascriptreact\", \"typescript\", \"typescriptreact\"]\n   }\n   ```\n\n# 5. 常见问题解决\n## 5.1 ESLint 与 Prettier 规则冲突\n- 原因：ESLint 部分格式规则（如 `indent`、`quotes`）与 Prettier 冲突；\n- 解决：通过 `eslint-config-prettier` 禁用冲突规则，`eslint-plugin-prettier` 将 Prettier 规则转为 ESLint 规则。\n\n## 5.2 TS 项目中 ESLint 不识别 TS 类型\n- 安装 `@typescript-eslint/parser` 和 `@typescript-eslint/eslint-plugin`；\n- 确保 `parserOptions.project` 指向 `tsconfig.json`（如需类型检查规则）：\n  ```javascript\n  // .eslintrc.js\n  parserOptions: {\n    project: './tsconfig.json', // 启用类型检查规则需配置\n  },\n  ```\n\n## 5.3 自动修复不生效\n- 检查文件是否在 `.eslintignore` 中；\n- 确认规则是否支持自动修复（ESLint 规则文档中标注 `fixable`）；\n- 重启 VS Code ESLint 服务（Ctrl+Shift+P → ESLint: Restart ESLint Server）。\n\n# 6. 进阶配置（可选）\n## 6.1 提交前自动校验（husky + lint-staged）\n避免不合规代码提交到仓库：\n```bash\nnpm install -D husky lint-staged\nnpx husky install\nnpx husky add .husky/pre-commit \"npx lint-staged\"\n```\n\n配置 `package.json`：\n```json\n{\n  \"lint-staged\": {\n    \"*.{js,jsx,ts,tsx}\": [\"eslint --fix\", \"prettier --write\"],\n    \"*.{json,css,md}\": [\"prettier --write\"]\n  }\n}\n```\n\n## 6.2 自定义 ESLint 规则\n创建共享规则包或在项目中扩展规则：\n```javascript\n// .eslintrc.js\nrules: {\n  // 自定义规则：强制组件文件名使用 PascalCase\n  \"react/jsx-filename-extension\": [\"error\", { extensions: [\".tsx\"] }],\n  \"react/function-component-definition\": [\"error\", {\n    \"namedComponents\": \"function-declaration\" // 强制组件使用函数声明\n  }]\n}\n```","directory_id":"4e45758d-1053-4937-b961-5a3cef9e566a","is_published":true,"created_at":"2025-12-22 03:20:44.180687+00","updated_at":"2025-12-23 13:55:43.370909+00"},{"id":"f8103d18-4ed0-4746-acf7-b65119460f76","title":"组件测试实战","content":"# 1. 渲染测试（基础渲染/条件渲染/列表渲染）\n## 1.1 基础渲染测试\n验证组件是否正常渲染所有核心元素：\n```tsx\n// UserCard.tsx\nimport React from 'react';\n\ninterface UserCardProps {\n  name: string;\n  age: number;\n  avatar?: string;\n}\n\nconst UserCard = ({ name, age, avatar }: UserCardProps) => {\n  return (\n    <div className=\"user-card\">\n      {avatar && <img src={avatar} alt={name} data-testid=\"avatar\" />}\n      <h3>{name}</h3>\n      <p>年龄：{age}</p>\n    </div>\n  );\n};\n\nexport default UserCard;\n\n// UserCard.test.tsx\nimport React from 'react';\nimport { render, screen } from '@testing-library/react';\nimport UserCard from './UserCard';\n\ntest('UserCard 渲染基础信息', () => {\n  // 渲染组件\n  render(<UserCard name=\"张三\" age={20} />);\n  \n  // 验证名称和年龄显示\n  expect(screen.getByText('张三')).toBeInTheDocument();\n  expect(screen.getByText('年龄：20')).toBeInTheDocument();\n  \n  // 验证头像不存在（未传递 avatar 属性）\n  expect(screen.queryByTestId('avatar')).not.toBeInTheDocument();\n});\n\ntest('UserCard 渲染头像（当传递 avatar 时）', () => {\n  render(<UserCard name=\"李四\" age={25} avatar=\"https://example.com/avatar.jpg\" />);\n  \n  // 验证头像存在且属性正确\n  const avatar = screen.getByTestId('avatar');\n  expect(avatar).toBeInTheDocument();\n  expect(avatar).toHaveAttribute('src', 'https://example.com/avatar.jpg');\n  expect(avatar).toHaveAttribute('alt', '李四');\n});\n```\n\n## 1.2 条件渲染测试\n验证组件在不同条件下的渲染结果：\n```tsx\n// LoginStatus.tsx\nimport React from 'react';\n\ninterface LoginStatusProps {\n  isLogin: boolean;\n  username: string;\n}\n\nconst LoginStatus = ({ isLogin, username }: LoginStatusProps) => {\n  if (isLogin) {\n    return <div>欢迎回来，{username}！</div>;\n  } else {\n    return <button>请登录</button>;\n  }\n};\n\nexport default LoginStatus;\n\n// LoginStatus.test.tsx\nimport React from 'react';\nimport { render, screen } from '@testing-library/react';\nimport LoginStatus from './LoginStatus';\n\ntest('已登录时显示欢迎信息', () => {\n  render(<LoginStatus isLogin={true} username=\"张三\" />);\n  expect(screen.getByText(/欢迎回来，张三！/i)).toBeInTheDocument();\n  expect(screen.queryByRole('button')).not.toBeInTheDocument();\n});\n\ntest('未登录时显示登录按钮', () => {\n  render(<LoginStatus isLogin={false} username=\"\" />);\n  expect(screen.getByRole('button', { name: /请登录/i })).toBeInTheDocument();\n  expect(screen.queryByText(/欢迎回来/i)).not.toBeInTheDocument();\n});\n```\n\n## 1.3 列表渲染测试\n验证列表组件是否正确渲染所有项：\n```tsx\n// TodoList.tsx\nimport React from 'react';\n\ninterface Todo {\n  id: number;\n  text: string;\n  done: boolean;\n}\n\ninterface TodoListProps {\n  todos: Todo[];\n}\n\nconst TodoList = ({ todos }: TodoListProps) => {\n  if (todos.length === 0) {\n    return <div>暂无待办事项</div>;\n  }\n  return (\n    <ul>\n      {todos.map((todo) => (\n        <li key={todo.id} className={todo.done ? 'done' : ''}>\n          {todo.text}\n        </li>\n      ))}\n    </ul>\n  );\n};\n\nexport default TodoList;\n\n// TodoList.test.tsx\nimport React from 'react';\nimport { render, screen } from '@testing-library/react';\nimport TodoList from './TodoList';\n\nconst mockTodos = [\n  { id: 1, text: '学习 React 测试', done: false },\n  { id: 2, text: '完成作业', done: true },\n];\n\ntest('TodoList 渲染所有待办事项', () => {\n  render(<TodoList todos={mockTodos} />);\n  \n  // 验证两个待办项都存在\n  expect(screen.getByText('学习 React 测试')).toBeInTheDocument();\n  expect(screen.getByText('完成作业')).toBeInTheDocument();\n  \n  // 验证已完成项的 className\n  const doneItem = screen.getByText('完成作业').closest('li');\n  expect(doneItem).toHaveClass('done');\n});\n\ntest('TodoList 无数据时显示提示文本', () => {\n  render(<TodoList todos={[]} />);\n  expect(screen.getByText('暂无待办事项')).toBeInTheDocument();\n});\n```\n\n# 2. 事件测试（点击/输入/表单提交）\n## 2.1 点击事件测试\n模拟按钮点击、复选框切换等点击行为：\n```tsx\n// ToggleButton.tsx\nimport React, { useState } from 'react';\n\nconst ToggleButton = () => {\n  const [isOn, setIsOn] = useState(false);\n  \n  const toggle = () => {\n    setIsOn(!isOn);\n  };\n  \n  return (\n    <button onClick={toggle}>\n      {isOn ? '开启' : '关闭'}\n    </button>\n  );\n};\n\nexport default ToggleButton;\n\n// ToggleButton.test.tsx\nimport React from 'react';\nimport { render, screen } from '@testing-library/react';\nimport userEvent from '@testing-library/user-event';\nimport ToggleButton from './ToggleButton';\n\ntest('ToggleButton 点击切换状态', async () => {\n  const user = userEvent.setup();\n  render(<ToggleButton />);\n  \n  // 初始状态为“关闭”\n  let button = screen.getByRole('button', { name: /关闭/i });\n  expect(button).toBeInTheDocument();\n  \n  // 模拟点击\n  await user.click(button);\n  \n  // 状态切换为“开启”\n  button = screen.getByRole('button', { name: /开启/i });\n  expect(button).toBeInTheDocument();\n  \n  // 再次点击切换回“关闭”\n  await user.click(button);\n  expect(screen.getByRole('button', { name: /关闭/i })).toBeInTheDocument();\n});\n```\n\n## 2.2 输入事件测试\n模拟输入框、下拉框等输入行为：\n```tsx\n// SearchInput.tsx\nimport React, { useState } from 'react';\n\ninterface SearchInputProps {\n  onSearch: (value: string) => void;\n}\n\nconst SearchInput = ({ onSearch }: SearchInputProps) => {\n  const [value, setValue] = useState('');\n  \n  const handleChange = (e: React.ChangeEvent<HTMLInputElement>) => {\n    setValue(e.target.value);\n  };\n  \n  const handleSubmit = (e: React.FormEvent) => {\n    e.preventDefault();\n    onSearch(value);\n  };\n  \n  return (\n    <form onSubmit={handleSubmit}>\n      <input\n        type=\"text\"\n        placeholder=\"请输入搜索内容\"\n        value={value}\n        onChange={handleChange}\n        aria-label=\"搜索框\"\n      />\n      <button type=\"submit\">搜索</button>\n    </form>\n  );\n};\n\nexport default SearchInput;\n\n// SearchInput.test.tsx\nimport React from 'react';\nimport { render, screen } from '@testing-library/react';\nimport userEvent from '@testing-library/user-event';\nimport SearchInput from './SearchInput';\n\ntest('SearchInput 输入内容并提交', async () => {\n  const user = userEvent.setup();\n  const mockSearch = jest.fn();\n  \n  render(<SearchInput onSearch={mockSearch} />);\n  \n  // 获取输入框和提交按钮\n  const input = screen.getByLabelText('搜索框');\n  const submitButton = screen.getByRole('button', { name: /搜索/i });\n  \n  // 模拟输入内容\n  await user.type(input, 'React 测试');\n  expect(input).toHaveValue('React 测试');\n  \n  // 模拟提交表单\n  await user.click(submitButton);\n  \n  // 验证回调被调用，且参数正确\n  expect(mockSearch).toHaveBeenCalledTimes(1);\n  expect(mockSearch).toHaveBeenCalledWith('React 测试');\n});\n\ntest('SearchInput 空内容提交不触发回调', async () => {\n  const user = userEvent.setup();\n  const mockSearch = jest.fn();\n  \n  render(<SearchInput onSearch={mockSearch} />);\n  \n  // 直接提交空表单\n  await user.click(screen.getByRole('button', { name: /搜索/i }));\n  \n  // 验证回调未被调用\n  expect(mockSearch).not.toHaveBeenCalled();\n});\n```\n\n# 3. 异步测试（接口请求/定时器/状态延迟更新）\n## 3.1 接口请求模拟测试\n使用 Jest Mock 模拟接口请求，测试异步组件：\n```tsx\n// UserList.tsx\nimport React, { useEffect, useState } from 'react';\n\ninterface User {\n  id: number;\n  name: string;\n}\n\n// 模拟接口请求\nconst fetchUsers = async (): Promise<User[]> => {\n  const res = await fetch('/api/users');\n  return res.json();\n};\n\nconst UserList = () => {\n  const [users, setUsers] = useState<User[]>([]);\n  const [loading, setLoading] = useState(true);\n  const [error, setError] = useState('');\n  \n  useEffect(() => {\n    const loadUsers = async () => {\n      try {\n        const data = await fetchUsers();\n        setUsers(data);\n      } catch (err) {\n        setError('加载用户失败');\n      } finally {\n        setLoading(false);\n      }\n    };\n    \n    loadUsers();\n  }, []);\n  \n  if (loading) {\n    return <div>加载中...</div>;\n  }\n  \n  if (error) {\n    return <div className=\"error\">{error}</div>;\n  }\n  \n  return (\n    <ul>\n      {users.map((user) => (\n        <li key={user.id}>{user.name}</li>\n      ))}\n    </ul>\n  );\n};\n\nexport default UserList;\n\n// UserList.test.tsx\nimport React from 'react';\nimport { render, screen, waitFor } from '@testing-library/react';\nimport UserList from './UserList';\n\n// Mock 整个模块的 fetchUsers 函数\njest.mock('./UserList', () => {\n  const original = jest.requireActual('./UserList');\n  return {\n    ...original,\n    fetchUsers: jest.fn(),\n  };\n});\n\nconst mockFetchUsers = jest.mocked(require('./UserList').fetchUsers);\n\ntest('UserList 加载成功显示用户列表', async () => {\n  // 模拟接口返回数据\n  const mockUsers = [{ id: 1, name: '张三' }, { id: 2, name: '李四' }];\n  mockFetchUsers.mockResolvedValue(mockUsers);\n  \n  render(<UserList />);\n  \n  // 验证加载中状态\n  expect(screen.getByText('加载中...')).toBeInTheDocument();\n  \n  // 等待异步加载完成，验证用户列表显示\n  await waitFor(() => {\n    expect(screen.getByText('张三')).toBeInTheDocument();\n    expect(screen.getByText('李四')).toBeInTheDocument();\n  });\n  \n  // 验证加载中状态消失\n  expect(screen.queryByText('加载中...')).not.toBeInTheDocument();\n});\n\ntest('UserList 加载失败显示错误信息', async () => {\n  // 模拟接口抛出错误\n  mockFetchUsers.mockRejectedValue(new Error('Network Error'));\n  \n  render(<UserList />);\n  \n  // 等待错误状态显示\n  await waitFor(() => {\n    expect(screen.getByText('加载用户失败')).toBeInTheDocument();\n  });\n});\n```\n\n## 3.2 定时器模拟测试\n使用 Jest 定时器模拟功能测试延迟更新组件：\n```tsx\n// Countdown.tsx\nimport React, { useState, useEffect } from 'react';\n\nconst Countdown = ({ initial = 3 }: { initial?: number }) => {\n  const [count, setCount] = useState(initial);\n  \n  useEffect(() => {\n    if (count > 0) {\n      const timer = setTimeout(() => {\n        setCount(count - 1);\n      }, 1000);\n      return () => clearTimeout(timer);\n    }\n  }, [count]);\n  \n  return <div>{count === 0 ? '倒计时结束' : `倒计时：${count}`}</div>;\n};\n\nexport default Countdown;\n\n// Countdown.test.tsx\nimport React from 'react';\nimport { render, screen } from '@testing-library/react';\nimport Countdown from './Countdown';\n\n// 启用 Jest 定时器模拟\njest.useFakeTimers();\n\ntest('Countdown 倒计时功能正常', () => {\n  render(<Countdown initial={2} />);\n  \n  // 初始状态：倒计时 2\n  expect(screen.getByText('倒计时：2')).toBeInTheDocument();\n  \n  // 快进所有定时器\n  jest.runAllTimers();\n  \n  // 第一次倒计时：1\n  expect(screen.getByText('倒计时：1')).toBeInTheDocument();\n  \n  // 再次快进定时器\n  jest.runAllTimers();\n  \n  // 倒计时结束\n  expect(screen.getByText('倒计时结束')).toBeInTheDocument();\n});\n\ntest('Countdown 清理定时器（避免内存泄漏）', () => {\n  const { unmount } = render(<Countdown initial={3} />);\n  \n  // 模拟组件卸载\n  unmount();\n  \n  // 验证定时器被清除\n  expect(jest.clearAllTimers).toHaveBeenCalledTimes(1);\n});\n\n// 恢复真实定时器\njest.useRealTimers();\n```\n\n# 4. 特殊场景测试\n## 4.1 模态框测试\n测试模态框的显示/隐藏逻辑：\n```tsx\n// Modal.tsx\nimport React from 'react';\nimport ReactDOM from 'react-dom';\n\ninterface ModalProps {\n  isOpen: boolean;\n  onClose: () => void;\n  children: React.ReactNode;\n}\n\nconst Modal = ({ isOpen, onClose, children }: ModalProps) => {\n  if (!isOpen...","directory_id":"a563f346-3dac-4331-b926-8587cb32b144","is_published":true,"created_at":"2025-12-22 03:20:34.053001+00","updated_at":"2025-12-23 13:45:02.92106+00"},{"id":"faabe940-bda7-40c4-8247-1398f3826401","title":"Zustand 最佳实践","content":"在掌握 Zustand 基础用法和核心特性后，本文将聚焦“工程化实践”，涵盖 Store 模块化拆分、TypeScript 类型提示、性能优化技巧，帮助你在实际项目中规范使用 Zustand，兼顾可维护性和运行效率。\n\n# 1. 模块化拆分：按业务拆分 Store\n随着项目规模扩大，将所有状态放在一个 Store 中会导致代码臃肿、维护困难。最佳实践是**按业务领域拆分独立 Store**，每个 Store 负责管理特定模块的状态（如用户模块、购物车模块、全局设置模块）。\n\n## 1.1 模块化拆分原则\n- 单一职责：一个 Store 只管理一个业务模块的状态（如 `userStore` 仅管用户相关，`cartStore` 仅管购物车相关）；\n- 低耦合：Store 之间尽量独立，若需跨 Store 访问，优先通过“组件中转”或“组合状态”，避免直接依赖；\n- 统一目录：所有 Store 放在 `src/stores` 目录下，按模块命名（如 `userStore.ts`、`cartStore.ts`）。\n\n## 1.2 模块化示例\n### （1）用户模块 Store（stores/userStore.ts）\n```tsx\nimport { create } from 'zustand';\nimport { persist } from 'zustand/middleware';\n\n// 定义用户状态类型（TypeScript）\ninterface UserState {\n  userInfo: { id: number; name: string; avatar: string } | null;\n  token: string;\n  loading: boolean;\n  login: (token: string, user: UserState['userInfo']) => void;\n  logout: () => void;\n  fetchUserInfo: (userId: number) => Promise<void>;\n}\n\nconst useUserStore = create<UserState>()(\n  persist(\n    (set) => ({\n      userInfo: null,\n      token: '',\n      loading: false,\n\n      login: (token, user) => set({ token, userInfo: user }),\n      logout: () => set({ token: '', userInfo: null }),\n\n      fetchUserInfo: async (userId) => {\n        set({ loading: true });\n        try {\n          const res = await fetch(`/api/users/${userId}`);\n          const data = await res.json();\n          set({ userInfo: data, loading: false });\n        } catch (err) {\n          set({ loading: false });\n          console.error('获取用户信息失败：', err);\n        }\n      },\n    }),\n    { name: 'user-storage' }\n  )\n);\n\nexport default useUserStore;\n```\n\n### （2）购物车模块 Store（stores/cartStore.ts）\n```tsx\nimport { create } from 'zustand';\nimport { persist } from 'zustand/middleware';\n\n// 购物车商品类型\ninterface CartItem {\n  id: number;\n  name: string;\n  price: number;\n  quantity: number;\n}\n\n// 购物车状态类型\ninterface CartState {\n  items: CartItem[];\n  addItem: (item: Omit<CartItem, 'quantity'>) => void;\n  removeItem: (itemId: number) => void;\n  updateQuantity: (itemId: number, quantity: number) => void;\n  clearCart: () => void;\n  totalPrice: () => number; // 计算总价（衍生状态）\n}\n\nconst useCartStore = create<CartState>()(\n  persist(\n    (set, get) => ({\n      items: [],\n\n      // 添加商品（已存在则增加数量，否则新增）\n      addItem: (item) =>\n        set((state) => {\n          const existingItem = state.items.find((i) => i.id === item.id);\n          if (existingItem) {\n            return {\n              items: state.items.map((i) =>\n                i.id === item.id ? { ...i, quantity: i.quantity + 1 } : i\n              ),\n            };\n          }\n          return { items: [...state.items, { ...item, quantity: 1 }] };\n        }),\n\n      // 移除商品\n      removeItem: (itemId) =>\n        set((state) => ({\n          items: state.items.filter((i) => i.id !== itemId),\n        })),\n\n      // 更新商品数量\n      updateQuantity: (itemId, quantity) =>\n        set((state) => ({\n          items: state.items.map((i) =>\n            i.id === itemId ? { ...i, quantity: Math.max(1, quantity) } : i\n          ),\n        })),\n\n      // 清空购物车\n      clearCart: () => set({ items: [] }),\n\n      // 衍生状态：计算总价（通过 get() 获取当前状态）\n      totalPrice: () => {\n        const items = get().items;\n        return items.reduce((sum, item) => sum + item.price * item.quantity, 0);\n      },\n    }),\n    { name: 'cart-storage' }\n  )\n);\n\nexport default useCartStore;\n```\n\n### （3）组件中使用多个模块 Store\n```tsx\nimport useUserStore from '../stores/userStore';\nimport useCartStore from '../stores/cartStore';\n\nexport default function CartPage() {\n  // 从 userStore 获取用户信息\n  const { userInfo, login } = useUserStore((state) => ({\n    userInfo: state.userInfo,\n    login: state.login,\n  }));\n\n  // 从 cartStore 获取购物车状态和方法\n  const { items, addItem, totalPrice } = useCartStore((state) => ({\n    items: state.items,\n    addItem: state.addItem,\n    totalPrice: state.totalPrice,\n  }));\n\n  return (\n    <div>\n      {!userInfo ? (\n        <button onClick={() => login('fake-token', { id: 1, name: '张三', avatar: '' })}>\n          登录后查看购物车\n        </button>\n      ) : (\n        <div>\n          <h2>购物车（{items.length} 件商品）</h2>\n          <ul>\n            {items.map((item) => (\n              <li key={item.id}>\n                {item.name} - ￥{item.price} × {item.quantity}\n              </li>\n            ))}\n          </ul>\n          <p>总价：￥{totalPrice()}</p>\n          <button onClick={() => addItem({ id: 3, name: '手机', price: 3999 })}>\n            添加商品\n          </button>\n        </div>\n      )}\n    </div>\n  );\n}\n```\n\n## 1.3 跨 Store 通信（可选）\n若两个 Store 需相互依赖（如购物车结算时需获取用户地址），推荐以下两种方式：\n- 方式 1：组件中转（推荐）：在组件中同时获取两个 Store 的状态和方法，通过组件逻辑关联；\n- 方式 2：Store 内部引用：在一个 Store 中通过 `get` 函数获取另一个 Store 的状态（需注意循环依赖）：\n  ```tsx\n  // cartStore 中获取 userStore 的状态\n  import useUserStore from './userStore';\n\n  const useCartStore = create((set, get) => ({\n    // 结算时获取用户地址\n    checkout: () => {\n      const userAddress = useUserStore.getState().userInfo?.address;\n      if (!userAddress) throw new Error('请先完善收货地址');\n      // 结算逻辑...\n    },\n  }));\n  ```\n\n# 2. TypeScript 类型提示：提升开发效率与类型安全\nZustand 原生支持 TypeScript，通过定义状态接口（Interface），可实现全链路类型提示，避免类型错误。以下是完整的 TypeScript 实践方案。\n\n## 2.1 核心类型定义规范\n- 为每个 Store 定义单独的状态接口（如 `UserState`、`CartState`），包含“状态字段”和“方法类型”；\n- 方法类型需明确参数类型和返回值类型（尤其是异步方法，需指定 `Promise` 类型）；\n- 使用 `create<StateInterface>()` 泛型语法绑定类型，确保 `set`、`get` 函数的类型推导正确。\n\n## 2.2 类型提示示例（完整版）\n```tsx\nimport { create } from 'zustand';\nimport { devtools, persist } from 'zustand/middleware';\n\n// 1. 定义子类型（如商品类型、用户信息类型）\ninterface Product {\n  id: number;\n  name: string;\n  price: number;\n  stock: number;\n}\n\n// 2. 定义 Store 状态接口\ninterface ProductState {\n  products: Product[];\n  loading: boolean;\n  error: string | null;\n  // 同步方法：参数类型 + 返回值类型（void 可省略）\n  setLoading: (loading: boolean) => void;\n  // 异步方法：返回 Promise<void>\n  fetchProducts: (category?: string) => Promise<void>;\n  // 带参数的同步方法\n  updateStock: (productId: number, stock: number) => void;\n}\n\n// 3. 创建 Store 并绑定类型\nconst useProductStore = create<ProductState>()(\n  devtools(\n    persist(\n      (set, get) => ({\n        products: [],\n        loading: false,\n        error: null,\n\n        setLoading: (loading) => set({ loading }), // 自动推导参数类型\n\n        fetchProducts: async (category) => {\n          get().setLoading(true);\n          try {\n            const url = category \n              ? `/api/products?category=${category}` \n              : '/api/products';\n            const res = await fetch(url);\n            if (!res.ok) throw new Error('请求失败');\n            const data: Product[] = await res.json(); // 类型断言\n            set({ products: data, error: null });\n          } catch (err) {\n            set({ error: err instanceof Error ? err.message : '未知错误' });\n          } finally {\n            get().setLoading(false);\n          }\n        },\n\n        updateStock: (productId, stock) => {\n          set((state) => ({\n            products: state.products.map((p) =>\n              p.id === productId ? { ...p, stock } : p\n            ),\n          }));\n        },\n      }),\n      { name: 'product-storage' }\n    )\n  )\n);\n\nexport default useProductStore;\n```\n\n## 2.3 类型提示优势\n- 状态字段自动补全：在组件中通过 `useStore` 获取状态时，IDE 会自动提示所有可用字段和方法；\n- 类型错误提前暴露：若传递错误类型的参数（如给 `updateStock` 传递字符串类型的 `stock`），TypeScript 会编译报错；\n- 方法返回值类型推导：异步方法自动提示 `await` 语法，避免忘记处理 Promise；\n- 状态不可变性保障：通过类型定义限制状态字段的修改方式，避免直接修改状态。\n\n## 2.4 常见类型问题解决方案\n- **可选参数类型**：异步方法的可选参数需显式指定（如 `category?: string`）；\n- **联合类型**：若状态字段支持多种类型（如 `error: string | null`），需明确声明联合类型；\n- **类型断言**：从接口请求的数据需通过类型断言（`as Product[]`）绑定类型，确保数据结构正确；\n- **持久化状态类型**：持久化的状态需支持 JSON 序列化（避免包含 `Date`、`Function` 等类型，若需存储 `Date`，需手动转换为字符串）。\n\n# 3. 性能优化：避免不必要的重渲染\nZustand 本身性能优异（基于订阅-发布模式，仅依赖状态变化的组件会重渲染），但不合理的使用仍可能导致性能问题。以下是关键优化技巧。\n\n## 3.1 精准选择状态：避免“过度订阅”\n- 错误用法：获取整个 Store 或无关状态，导致组件因无关状态变化而重渲染；\n- 正确用法：仅获取组件所需的单个状态或部分状态，配合 `shallow` 比较优化多状态获取。\n\n```tsx\n// 错误：获取整个 Store，任意状态变化都会重渲染\nconst store = useProductStore();\n\n// 正确：仅获取需要的状态（单个状态）\nconst products = useProductStore((state) => state.products);\nconst loading = useProductStore((state) => state.loading);\n\n// 正确：获取多个状态时使用 shallow 比较\nimport { shallow } from 'zustand/shallow';\nconst { products, loading } = useProductStore(\n  (state) => ({ products: state.products, loading: state.loading }),\n  shallow // 仅当 products 或 loading 实际变化时重渲染\n);\n```\n\n## 3.2 衍生状态：避免重复计算\n若组件需要基于 Store 状态计算衍生值（如购物车总价、商品数量），推荐在 Store 中定义衍生状态方法，避免在组件中重复计算。\n\n```tsx\n// 推荐：在 Store 中定义衍生状态方法\nconst useCartStore = create((set, get) => ({\n  items: [],\n  // 衍生状态：计算总价（仅当 items 变化时重新计算）\n  totalPrice: () => {\n    return get().items.reduce((sum, item) => sum + item.price * item.quantity, 0);\n  },\n}));\n\n// 组件中直接调用，无需重复计算\nconst totalPrice = useCartStore((state) => state.totalPrice);\n<p>总价：￥{totalPrice()}</p>;\n```\n\n## 3.3 避免在选择器中创建新对象/函数\n选择器函数返回新对象、数组或函数时，会导致每次渲染都生成新引用，Zustand 会误判为“状态变化”，触发不必要的重渲染。\n\n```tsx\n// 错误：每次渲染返回新数组，导致组件频繁重渲染\nconst activeProducts = useProductStore((state) => \n  state.products.filter((p) => p.stock > 0) // 每次返回新数组\n);\n\n// 正确：优化方案1 - 在 Store 中定义筛选后的状态\nconst useProductStore = create((set, get) => ({\n  products: [],\n  // 存储筛选后的状态，仅当 products 变化时更新\n  activeProducts: [],\n  updateActiveProducts: () => {\n    const active = get().products.filter((p) => p.stock > 0);\n    set({ activeProducts: active });\n  },\n}));\n\n// 正确：优化方案2 - 使用 memo 缓存组件（适用于简单场景）\nimport { memo } from 'react';\nconst ActiveProducts = memo(() => {\n  const products = useProductStore((state) => state.products);\n  const activeProducts = products.filter((p) => p.stock > 0); // 组件内部计算，memo 避免重渲染\n  return <div>{activeProducts.map((p) => p.name)}</div>;\n});\n```\n\n## 3.4 批量更新状态\n若需同时修改多个状态，尽量在一个 `set` 函数中完成，避免多次调用 `set` 导致组件多次重渲染。\n\n```tsx\n// 优化前：多次调用 set，组件可能重渲染多次\nconst updateUser = () => {\n  set({ name: '李四' });\n  set({ age: 25 });\n  set({ address: '上海' });\n};\n\n// 优化后：一次 set 批量更新，组件仅重渲染一次\nconst updateUser = () => {\n  set({ name: '李四', age: 25, address: '上海' });\n};\n```\n\n## 3.5 防抖/节流状态更新\n若状态更新触发频繁（如输入框实时搜索），可对状态方法进行防抖/节流处理，减少不必要的接口请求和状态更新。\n\n```tsx\nimport { create } from 'zustand';\nimport { debounce } from 'lodash'; // 需安装 lodash：npm install lodash\n\nconst useSearchStore = create((set) => ({\n  keyword: '',\n  searchResult: [],\n  loading: false,\n\n  // 防抖处理：输入停止 500ms 后再触发搜索\n  search: debounce(async (keyword) => {\n    set({ loading: true });\n    try {\n      const res = await fetch(`/api/search?keyword=${keyword}`);\n      const data = await ...","directory_id":"ed2cdaf2-c966-4d9f-bfad-740b9f352c61","is_published":true,"created_at":"2025-12-22 03:10:53.057773+00","updated_at":"2025-12-23 03:15:58.614524+00"},{"id":"fb483696-bad2-475f-af69-f5ced7edc43c","title":"Redux Toolkit","content":"Redux 原生用法存在**样板代码冗余**（如手动定义 Action 类型、组合 Reducer、处理不可变状态）、**不可变操作繁琐**（需手动扩展对象/数组）等问题，Redux Toolkit（RTK）是官方推荐的“一站式解决方案”，内置常用工具（如 `createSlice`、`configureStore`），大幅简化开发流程。\n\n# 1. 核心优势\n- 内置 `immer` 库，支持“可变写法”实现不可变状态（无需手动扩展运算符）；\n- 自动生成 Action 类型和 Action 创建函数；\n- 简化 Store 配置（内置中间件、支持开发者工具）；\n- 集成常用功能（如异步请求处理、状态持久化）。\n\n# 2. 快速上手：安装 Redux Toolkit\n```bash\nnpm install @reduxjs/toolkit react-redux\n\nyarn add @reduxjs/toolkit react-redux\n```\n\n# 3. createSlice：一站式定义 Reducer 和 Action\n`createSlice` 是 RTK 的核心 API，用于封装“状态初始值 + Reducer 逻辑 + Action 创建”，自动生成唯一的 Action 类型和对应的 Action 创建函数。\n\n## 3.1 语法：\n```javascript\nimport { createSlice } from '@reduxjs/toolkit';\n\nconst slice = createSlice({\n  name: 'slice名称', // 作为 Action 类型的前缀（如 \"todo/addTodo\"）\n  initialState: 初始状态, // 模块初始状态\n  reducers: {\n    // 定义 Reducer 函数（支持“可变写法”，immer 自动转换为不可变状态）\n    函数名: (state, action) => {\n      // 直接修改 state（immer 处理不可变性）\n    }\n  }\n});\n\n// 自动生成的 Action 创建函数\nexport const { 函数名1, 函数名2 } = slice.actions;\n\n// 导出 Reducer（用于组合根 Reducer）\nexport default slice.reducer;\n```\n\n## 3.2 示例：创建 Todo Slice\n```javascript\nimport { createSlice } from '@reduxjs/toolkit';\n\n// 初始状态\nconst initialState = {\n  todos: []\n};\n\n// 创建 Todo Slice\nconst todoSlice = createSlice({\n  name: 'todo', // Action 类型前缀：\"todo/xxx\"\n  initialState,\n  reducers: {\n    // 添加待办：直接修改 state（immer 自动处理不可变）\n    addTodo: (state, action) => {\n      state.todos.push(action.payload); // 看似“可变”，实际生成新数组\n    },\n    // 删除待办\n    deleteTodo: (state, action) => {\n      state.todos = state.todos.filter(todo => todo.id !== action.payload.id);\n    },\n    // 修改待办状态\n    toggleTodo: (state, action) => {\n      const todo = state.todos.find(todo => todo.id === action.payload.id);\n      if (todo) {\n        todo.completed = !todo.completed; // 直接修改对象属性\n      }\n    }\n  }\n});\n\n// 自动生成的 Action 创建函数（无需手动定义）\nexport const { addTodo, deleteTodo, toggleTodo } = todoSlice.actions;\n\n// 导出 Todo Reducer\nexport default todoSlice.reducer;\n```\n\n# 4. configureStore：简化 Store 创建\n`configureStore` 是 RTK 替代原生 `createStore` 的 API，内置以下功能：\n- 自动组合 Reducer（支持对象形式传入）；\n- 内置 `redux-thunk` 中间件（支持异步 Action）；\n- 集成 Redux DevTools（无需手动配置）；\n- 自动处理中间件顺序和默认配置。\n\n## 4.1 示例：创建根 Store\n```javascript\nimport { configureStore } from '@reduxjs/toolkit';\nimport todoReducer from './features/todo/todoSlice';\nimport userReducer from './features/user/userSlice';\n\n// 配置 Store\nconst store = configureStore({\n  reducer: {\n    // 键名对应状态树的属性，值为对应 Slice 的 Reducer\n    todos: todoReducer,\n    user: userReducer\n  }\n  // 可选：自定义中间件、禁用 DevTools 等\n  // middleware: (getDefaultMiddleware) => getDefaultMiddleware().concat(logger),\n});\n\nexport default store;\n```\n\n# 5. 核心简化点对比（原生 Redux vs Redux Toolkit）\n| 功能                | 原生 Redux                          | Redux Toolkit                      |\n|---------------------|-------------------------------------|------------------------------------|\n| Action 类型定义      | 手动定义常量（如 ADD_TODO）         | 自动生成（基于 slice.name + 函数名）|\n| Action 创建函数      | 手动编写                            | 自动生成（slice.actions）          |\n| 不可变状态处理       | 手动扩展运算符/Object.assign        | 内置 immer，支持“可变写法”         |\n| Store 配置          | 手动组合 Reducer、添加中间件        | configureStore 一键配置            |\n| 代码量              | 冗余（每个 Action/Reducer 需单独写）| 高度封装（一个 slice 搞定模块逻辑）|\n","directory_id":"a3109983-f66b-42c0-afb5-8d07e97cbc4e","is_published":true,"created_at":"2025-12-22 03:11:55.580844+00","updated_at":"2025-12-23 08:29:46.26142+00"},{"id":"fd26fd36-2e29-4398-bf9c-b45d5a52239b","title":"组件的复用","content":"在 React 开发中，多个组件往往会出现相同的业务逻辑（如数据请求、表单验证、权限控制）。为了避免代码冗余，需要通过**组件复用**技术抽离公共逻辑。React 中主流的复用方案有三种：**高阶组件（HOC）**、**Render Props**、**自定义 Hooks**。\n\n# 1. 高阶组件（HOC - Higher-Order Component）\n## 1.1 核心概念\n高阶组件是**参数为组件，返回值为新组件**的函数，本质是一个函数，不是组件。它的作用是抽离公共逻辑，增强组件的功能。\n- **语法结构**：\n  ```jsx\n  function withHOC(WrappedComponent) {\n    // 返回一个新的类组件或函数组件\n    return function EnhancedComponent(props) {\n      // 公共逻辑处理\n      const [data, setData] = useState(null);\n      useEffect(() => {\n        fetch('/api/data').then(res => res.json()).then(data => setData(data));\n      }, []);\n      // 将公共逻辑的结果通过 props 传递给被包装组件\n      return <WrappedComponent {...props} data={data} />;\n    };\n  }\n\n  // 使用：增强目标组件\n  const MyComponent = (props) => <div>{props.data?.name}</div>;\n  const EnhancedMyComponent = withHOC(MyComponent);\n  ```\n\n## 1.2 核心特性\n- **不修改原组件**：高阶组件是纯函数，不会改变传入的组件，而是通过包装生成新组件，遵循“开闭原则”。\n- **复用逻辑灵活**：可以传递参数，实现更灵活的逻辑定制。\n  ```jsx\n  // 带参数的高阶组件\n  function withFetch(url) {\n    return function(WrappedComponent) {\n      return function EnhancedComponent(props) {\n        const [data, setData] = useState(null);\n        useEffect(() => {\n          fetch(url).then(res => res.json()).then(data => setData(data));\n        }, [url]);\n        return <WrappedComponent {...props} data={data} />;\n      };\n    };\n  }\n\n  // 使用：传入不同的 URL\n  const UserComponent = withFetch('/api/users')(MyComponent);\n  ```\n- **常见使用场景**：权限控制、数据请求、日志埋点、样式包装。\n\n## 1.3 优缺点\n| 优点 | 缺点 |\n|------|------|\n| 逻辑复用能力强，适用于类组件和函数组件 | 易产生嵌套地狱（多个 HOC 嵌套使用时，组件层级过深） |\n| 可以通过参数定制逻辑 | 命名冲突风险（多个 HOC 传递相同名称的 props 时会覆盖） |\n| 社区大量库使用 HOC（如 react-redux 的 connect） | 难以调试（组件被包装后，React DevTools 显示的是增强后的组件） |\n\n# 2. Render Props\n## 2.1 核心概念\nRender Props 是指**组件通过一个名为 render 的 props 接收一个函数，该函数返回组件需要渲染的内容**。核心思想是将组件的渲染逻辑交给父组件控制，从而实现逻辑复用。\n- **语法结构**：\n  ```jsx\n  // 封装公共逻辑的组件\n  class FetchData extends React.Component {\n    state = { data: null };\n\n    componentDidMount() {\n      fetch('/api/data').then(res => res.json()).then(data => this.setState({ data }));\n    }\n\n    render() {\n      // 调用 render props 函数，传递公共逻辑的结果\n      return this.props.render(this.state.data);\n    }\n  }\n\n  // 使用：父组件控制渲染逻辑\n  function App() {\n    return (\n      <FetchData \n        render={(data) => (\n          data ? <div>{data.name}</div> : <div>Loading...</div>\n        )} \n      />\n    );\n  }\n  ```\n- **注意**：Render Props 不一定叫 `render`，也可以是其他名称的 props，只要是函数即可（如 `children`）。\n  ```jsx\n  // 使用 children 作为 render props\n  <FetchData>\n    {(data) => (data ? <div>{data.name}</div> : <div>Loading...</div>)}\n  </FetchData>\n  ```\n\n## 2.2 核心特性\n- **逻辑与视图分离**：公共逻辑封装在组件内部，渲染逻辑由父组件决定，灵活性高。\n- **避免嵌套地狱**：相比 HOC，Render Props 的组件层级更扁平，调试更友好。\n- **常见使用场景**：鼠标位置监听、数据缓存、表单状态管理。\n\n## 2.3 优缺点\n| 优点 | 缺点 |\n|------|------|\n| 灵活性高，父组件完全控制渲染内容 | 写法相对繁琐，需要额外定义渲染函数 |\n| 组件层级扁平，调试方便 | 容易出现闭包陷阱（渲染函数中使用的变量可能不是最新值） |\n| 无命名冲突问题（props 由父组件传递） | 不适用于复杂逻辑的复用（多个 Render Props 嵌套时代码可读性下降） |\n\n# 3. 自定义 Hooks\n## 3.1 核心概念\n自定义 Hooks 是**基于 React 内置 Hooks 封装的函数，用于抽离和复用组件的业务逻辑**，是 React 16.8 推出 Hooks 之后的推荐复用方案。自定义 Hooks 以 `use` 开头，遵循 Hooks 的使用规则。\n- **语法结构**：\n  ```jsx\n  // 封装公共逻辑的自定义 Hook\n  function useFetch(url) {\n    const [data, setData] = useState(null);\n    const [loading, setLoading] = useState(true);\n    const [error, setError] = useState(null);\n\n    useEffect(() => {\n      const fetchData = async () => {\n        try {\n          setLoading(true);\n          const res = await fetch(url);\n          const result = await res.json();\n          setData(result);\n        } catch (err) {\n          setError(err);\n        } finally {\n          setLoading(false);\n        }\n      };\n      fetchData();\n    }, [url]);\n\n    // 返回组件需要的状态和方法\n    return { data, loading, error };\n  }\n\n  // 使用：在函数组件中调用自定义 Hook\n  function UserComponent() {\n    const { data, loading, error } = useFetch('/api/users');\n\n    if (loading) return <div>Loading...</div>;\n    if (error) return <div>Error: {error.message}</div>;\n    return <div>{data?.name}</div>;\n  }\n  ```\n\n## 3.2 核心特性\n- **只适用于函数组件**：基于 React 内置 Hooks，只能在函数组件或其他自定义 Hooks 中调用。\n- **逻辑复用粒度更细**：可以将复杂逻辑拆分为多个小的自定义 Hooks，组合使用。\n- **遵循 Hooks 规则**：\n  1. 只能在函数组件的顶层调用 Hooks，不能在条件、循环、嵌套函数中调用。\n  2. 只能在函数组件或自定义 Hooks 中调用 Hooks，不能在普通 JavaScript 函数中调用。\n- **常见使用场景**：数据请求、表单处理、状态管理、事件监听。\n\n## 3.3 优缺点\n| 优点 | 缺点 |\n|------|------|\n| 逻辑复用粒度细，代码简洁易维护 | 只支持函数组件，无法在类组件中使用 |\n| 无嵌套地狱，组件层级清晰 | 受 Hooks 规则限制，使用不当容易出错 |\n| 调试友好，React DevTools 可显示 Hook 状态 | 需要理解 Hooks 的工作原理，学习成本较高 |\n| 社区生态丰富，大量新库基于自定义 Hooks |  |\n\n# 4. 三种复用方案对比与选型建议\n| 方案 | 适用场景 | 推荐指数 |\n|------|----------|----------|\n| 高阶组件（HOC） | 类组件项目、需要兼容老库、简单逻辑复用 | ★★★☆☆ |\n| Render Props | 函数组件/类组件通用、需要灵活控制渲染逻辑 | ★★★★☆ |\n| 自定义 Hooks | 函数组件项目、复杂逻辑复用、细粒度逻辑拆分 | ★★★★★ |\n\n**选型建议**：\n1. 新项目优先使用 **自定义 Hooks**，代码简洁、逻辑清晰，是 React 官方推荐方案。\n2. 若需要兼容类组件，可使用 **Render Props**，避免 HOC 的嵌套问题。\n3. 老项目维护或使用依赖 HOC 的库时，可继续使用 **HOC**，但建议逐步迁移到自定义 Hooks。\n","directory_id":"16d6f496-f7f3-422b-baf9-c5f027a71aaa","is_published":true,"created_at":"2025-12-19 10:06:06.985007+00","updated_at":"2025-12-19 10:06:06.985007+00"},{"id":"fd654025-a806-4586-86bf-ae08ce95a3a6","title":"JSX基本语法","content":"# 1. 什么是 JSX\nJSX 的全称是 **JavaScript XML**，是 React 提供的一种语法糖，允许开发者在 JavaScript 代码中直接编写类 HTML 的结构。它既不是字符串，也不是 HTML，最终会被编译为 `React.createElement` 函数调用，生成对应的 React 元素（虚拟 DOM 节点）。\n\n使用 JSX 可以让 UI 结构的描述更直观、简洁，相比纯 JavaScript 代码创建元素，可读性大幅提升。\n\n**简单示例**：\n```jsx\n// JSX 写法\nconst element = <h1>Hello, React!</h1>;\n\n// 等价的 JavaScript 写法（不使用 JSX）\nconst element = React.createElement('h1', null, 'Hello, React!');\n```\n\n# 2. 核心语法规则\n## （1）表达式嵌入\nJSX 中可以通过 `{}` 嵌入任意有效的 JavaScript 表达式，表达式的结果会被渲染到页面中。\n\n**支持的表达式类型**：\n- 变量、常量\n- 算术运算\n- 函数调用\n- 三元运算符\n- 对象属性访问\n\n**示例代码**：\n```jsx\nimport React from 'react';\n\nfunction App() {\n  // 定义变量\n  const name = '小学生';\n  // 定义算术表达式\n  const num1 = 10;\n  const num2 = 20;\n  // 定义函数\n  const getGreeting = () => {\n    return `欢迎学习 React！`;\n  };\n\n  return (\n    <div>\n      <h1>你好，{name}！</h1>\n      <p>10 + 20 = {num1 + num2}</p>\n      <p>{getGreeting()}</p>\n      <p>{name === '小学生' ? '适合儿童学习' : '适合成人学习'}</p>\n    </div>\n  );\n}\n\nexport default App;\n```\n\n**注意事项**：\n- `{}` 中只能写**表达式**，不能写**语句**（如 `if`、`for` 循环）。如果需要条件判断，可使用三元运算符或在外部定义函数。\n- 表达式的值为 `null`、`undefined`、`false` 时，不会在页面渲染任何内容。\n\n## （2）注释写法\nJSX 中的注释需要写在 `{}` 内，且遵循 JavaScript 注释规范，有两种常用写法：\n- 单行注释：`// 注释内容`\n- 多行注释：`/* 多行注释内容 */`\n\n**示例代码**：\n```jsx\nfunction App() {\n  return (\n    <div>\n      {/* 这是多行注释\n          适用于大段说明 */}\n      <h1>Hello JSX</h1>\n      {/* 单行注释也可以这样写 */}\n      <p>{/* 注释不会显示在页面上 */} 这是一段文本</p>\n    </div>\n  );\n}\n```\n\n**注意事项**：\n- 注释不能写在 JSX 标签的外面（除非是普通 JavaScript 注释）。\n- 注释内容不会被编译到最终的 DOM 结构中。\n\n## （3）属性定义\nJSX 标签的属性写法与 HTML 类似，但有几个关键区别，核心规则如下：\n1. **属性名使用驼峰命名法**：由于 JSX 最终会被编译为 JavaScript，而 JavaScript 中不允许使用 `-` 连接符，因此属性名需要改为驼峰式。\n   例如：`class` → `className`，`tabindex` → `tabIndex`。\n2. **属性值写法**\n    - 字符串值：使用双引号 `\"` 包裹，与 HTML 一致。\n    - JavaScript 表达式值：使用 `{}` 包裹，不能加引号。\n3. **布尔属性**：如果属性值为 `true`，可以只写属性名；如果为 `false`，可以省略该属性。\n\n**示例代码**：\n```jsx\nfunction App() {\n  const titleText = \"JSX 属性示例\";\n  return (\n    <div>\n      {/* 字符串属性值 */}\n      <h2 title=\"这是标题提示\">字符串属性</h2>\n      {/* 表达式属性值 */}\n      <h3 title={titleText}>表达式属性</h3>\n      {/* 布尔属性：disabled 为 true */}\n      <button disabled>不可点击按钮</button>\n      {/* 布尔属性：disabled 为 false，省略属性 */}\n      <button>可点击按钮</button>\n    </div>\n  );\n}\n```\n\n## （4）样式设置\nJSX 中设置样式有两种常用方式：**行内样式**和**类名样式**。\n\n### 方式1：行内样式（推荐用于简单样式）\n- 行内样式需要通过 `style` 属性设置，属性值是一个 **JavaScript 对象**。\n- 样式属性名使用驼峰命名法（如 `background-color` → `backgroundColor`）。\n- 样式值如果是数值类型（如 `width`、`height`），可以省略单位（默认单位是 `px`）；如果是其他单位（如 `rem`），需要写为字符串。\n\n**示例代码**：\n```jsx\nfunction App() {\n  // 定义样式对象\n  const textStyle = {\n    color: \"red\",\n    fontSize: \"20px\", // 字体大小，带单位\n    backgroundColor: \"#f5f5f5\", // 背景色\n    padding: 10 // 内边距，省略单位，默认 px\n  };\n  return (\n    <div>\n      <p style={textStyle}>行内样式示例</p>\n      {/* 直接在标签内写样式对象 */}\n      <p style={{ color: \"blue\", fontSize: \"16px\" }}>直接设置行内样式</p>\n    </div>\n  );\n}\n```\n\n### 方式2：类名样式（推荐用于复杂样式）\n- 与 HTML 类似，通过 `className` 属性指定样式类名。\n- 样式定义在 `.css` 文件中，然后在组件中引入该 CSS 文件。\n\n**示例代码**：\n```css\n/* App.css */\n.text-class {\n  color: green;\n  font-size: 18px;\n  font-weight: bold;\n}\n```\n\n```jsx\n// App.jsx\nimport React from 'react';\nimport './App.css'; // 引入样式文件\n\nfunction App() {\n  return (\n    <p className=\"text-class\">类名样式示例</p>\n  );\n}\n```\n\n# 3. 其他重要规则\n1. **JSX 必须有且仅有一个根节点**：如果需要渲染多个元素，必须用一个父元素包裹（如 `div`、`Fragment`）。\n   ```jsx\n   // 错误写法：多个根节点\n   function App() {\n     return (\n       <h1>标题</h1>\n       <p>文本</p>\n     );\n   }\n\n   // 正确写法：用 div 包裹\n   function App() {\n     return (\n       <div>\n         <h1>标题</h1>\n         <p>文本</p>\n       </div>\n     );\n   }\n\n   // 正确写法：用 Fragment 包裹（无额外 DOM 节点）\n   function App() {\n     return (\n       <React.Fragment>\n         <h1>标题</h1>\n         <p>文本</p>\n       </React.Fragment>\n     );\n     // 简写形式：<>...</>\n     // return (\n     //   <>\n     //     <h1>标题</h1>\n     //     <p>文本</p>\n     //   </>\n     // );\n   }\n   ```\n2. **标签必须闭合**：JSX 是严格的 XML 语法，所有标签都必须闭合，包括自闭合标签（如 `<img>` → `<img />`、`<input>` → `<input />`）。","directory_id":"22e948d7-98f2-4c47-8ae2-4abb0990f9f7","is_published":true,"created_at":"2025-12-19 07:29:14.249044+00","updated_at":"2025-12-19 09:20:04.662094+00"},{"id":"fe01f2e0-a917-4111-a1b7-d2192c066b0e","title":"JSX 本质","content":"很多开发者会误以为 JSX 是 React 独有的模板语言，但实际上 **JSX 只是 `React.createElement` 函数的语法糖**。所有的 JSX 代码，最终都会被 Babel 等编译工具转换为 `React.createElement` 函数的调用，进而生成 React 元素（虚拟 DOM 节点）。\n\n# 1. JSX 编译过程\n我们可以通过一个简单的例子，直观地看 JSX 是如何被编译的。\n\n**步骤1：编写 JSX 代码**\n```jsx\nconst element = <h1 className=\"title\">Hello JSX</h1>;\n```\n\n**步骤2：Babel 编译为 `React.createElement` 调用**\n上述 JSX 代码会被编译为以下 JavaScript 代码：\n```javascript\nconst element = React.createElement(\n  'h1', // 标签名/组件名\n  { className: 'title' }, // 属性对象\n  'Hello JSX' // 子元素/文本内容\n);\n```\n\n**步骤3：执行函数生成 React 元素**\n`React.createElement` 函数执行后，会返回一个**React 元素对象**（虚拟 DOM 节点），结构如下：\n```javascript\nconst element = {\n  type: 'h1',\n  props: {\n    className: 'title',\n    children: 'Hello JSX'\n  },\n  // 其他内部属性（如 key、ref 等）\n};\n```\n这个对象描述了 DOM 节点的类型、属性和子元素，React 会根据这个对象构建真实的 DOM 结构。\n\n#  2. `React.createElement` 函数参数详解\n`React.createElement` 函数的作用是创建并返回一个 React 元素对象，其函数签名如下：\n```javascript\nReact.createElement(type, [props], [...children]);\n```\n\n参数说明：\n1. **`type`**（必选）\n    - 表示要创建的元素类型，可以是：\n        - 字符串：代表 HTML 原生标签（如 `'div'`、`'h1'`、`'p'`）。\n        - React 组件：自定义的函数组件或类组件（如 `Button`、`App`）。\n2. **`props`**（可选）\n    - 一个对象，包含元素的所有属性（如 `className`、`onClick`、`style` 等）。\n    - 如果没有属性，该参数可以传 `null` 或省略。\n3. **`children`**（可选，可变参数）\n    - 表示元素的子节点，可以是：\n        - 字符串：文本内容。\n        - React 元素：嵌套的 JSX 元素。\n        - 表达式：通过 `{}` 嵌入的 JavaScript 表达式结果。\n    - 多个子节点可以依次传入。\n\n# 3. 复杂 JSX 编译示例\n对于嵌套的复杂 JSX 结构，编译后的 `React.createElement` 调用也会相应嵌套。\n\n**复杂 JSX 代码**：\n```jsx\nconst element = (\n  <div className=\"container\">\n    <h1>Hello React</h1>\n    <p>JSX 本质是函数调用</p>\n  </div>\n);\n```\n\n**编译后的 JavaScript 代码**：\n```javascript\nconst element = React.createElement(\n  'div',\n  { className: 'container' },\n  React.createElement('h1', null, 'Hello React'),\n  React.createElement('p', null, 'JSX 本质是函数调用')\n);\n```\n\n**生成的 React 元素对象**：\n```javascript\nconst element = {\n  type: 'div',\n  props: {\n    className: 'container',\n    children: [\n      {\n        type: 'h1',\n        props: { children: 'Hello React' }\n      },\n      {\n        type: 'p',\n        props: { children: 'JSX 本质是函数调用' }\n      }\n    ]\n  }\n};\n```\n\n# 4. 为什么需要 JSX\n既然 JSX 最终会被编译为 `React.createElement` 调用，那我们为什么不直接写 `React.createElement`，而是要用 JSX 呢？\n\n核心原因有两点：\n1. **提高可读性**：对于复杂的 UI 结构，JSX 的类 HTML 写法比嵌套的函数调用更直观，更容易理解和维护。\n2. **降低学习成本**：前端开发者对 HTML 语法非常熟悉，使用 JSX 可以快速上手 React，无需记忆复杂的函数调用参数顺序。\n\n# 5. 不使用 JSX 的 React 开发\n虽然 JSX 很方便，但 React 并不强制要求使用它。如果项目中没有配置 Babel 编译 JSX，或者开发者不想使用 JSX，完全可以通过直接调用 `React.createElement` 来开发 React 应用。\n\n**示例：不使用 JSX 开发组件**\n```javascript\nimport React from 'react';\nimport ReactDOM from 'react-dom/client';\n\n// 不使用 JSX 的函数组件\nfunction App() {\n  return React.createElement(\n    'div',\n    { className: 'app' },\n    React.createElement('h1', null, '不使用 JSX 的 React 应用'),\n    React.createElement('p', null, '直接调用 React.createElement')\n  );\n}\n\n// 渲染组件\nconst root = ReactDOM.createRoot(document.getElementById('root'));\nroot.render(React.createElement(App));\n```\n\n这种写法虽然可行，但对于复杂组件来说，代码会变得非常冗长且难以维护，因此**推荐使用 JSX 开发 React 应用**。\n","directory_id":"22e948d7-98f2-4c47-8ae2-4abb0990f9f7","is_published":true,"created_at":"2025-12-19 07:39:01.729432+00","updated_at":"2025-12-23 03:18:33.282112+00"}]